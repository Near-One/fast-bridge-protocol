#![feature(prelude_import)]
#[prelude_import]
use std::prelude::rust_2021::*;
#[macro_use]
extern crate std;
use crate::lp_relayer::EthTransferEvent;
use fast_bridge_common::*;
use near_plugins::{
    access_control, access_control_any, pause, AccessControlRole, AccessControllable,
    Pausable, Upgradable,
};
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::{LookupMap, UnorderedMap, UnorderedSet};
use near_sdk::env::{block_timestamp, current_account_id};
use near_sdk::json_types::U128;
use near_sdk::serde::{Deserialize, Serialize};
#[allow(unused_imports)]
use near_sdk::Promise;
use near_sdk::{
    env, ext_contract, near_bindgen, promise_result_as_success, require, AccountId,
    BorshStorageKey, Duration, PanicOnDefault, PromiseOrValue,
};
use parse_duration::parse;
use whitelist::WhitelistMode;
pub use crate::ft::*;
mod ft {
    use crate::*;
    use near_contract_standards::fungible_token::receiver::FungibleTokenReceiver;
    use near_sdk::{base64, AccountId};
    impl FastBridgeExt {
        pub fn ft_on_transfer(
            self,
            sender_id: AccountId,
            amount: U128,
            msg: String,
        ) -> near_sdk::Promise {
            let __args = {
                #[serde(crate = "near_sdk::serde")]
                struct Input<'nearinput> {
                    sender_id: &'nearinput AccountId,
                    amount: &'nearinput U128,
                    msg: &'nearinput String,
                }
                #[doc(hidden)]
                #[allow(
                    non_upper_case_globals,
                    unused_attributes,
                    unused_qualifications
                )]
                const _: () = {
                    use near_sdk::serde as _serde;
                    #[automatically_derived]
                    impl<'nearinput> near_sdk::serde::Serialize for Input<'nearinput> {
                        fn serialize<__S>(
                            &self,
                            __serializer: __S,
                        ) -> near_sdk::serde::__private::Result<__S::Ok, __S::Error>
                        where
                            __S: near_sdk::serde::Serializer,
                        {
                            let mut __serde_state = match _serde::Serializer::serialize_struct(
                                __serializer,
                                "Input",
                                false as usize + 1 + 1 + 1,
                            ) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            };
                            match _serde::ser::SerializeStruct::serialize_field(
                                &mut __serde_state,
                                "sender_id",
                                &self.sender_id,
                            ) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            };
                            match _serde::ser::SerializeStruct::serialize_field(
                                &mut __serde_state,
                                "amount",
                                &self.amount,
                            ) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            };
                            match _serde::ser::SerializeStruct::serialize_field(
                                &mut __serde_state,
                                "msg",
                                &self.msg,
                            ) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            };
                            _serde::ser::SerializeStruct::end(__serde_state)
                        }
                    }
                };
                let __args = Input {
                    sender_id: &sender_id,
                    amount: &amount,
                    msg: &msg,
                };
                near_sdk::serde_json::to_vec(&__args)
                    .expect("Failed to serialize the cross contract args using JSON.")
            };
            near_sdk::Promise::new(self.account_id)
                .function_call_weight(
                    "ft_on_transfer".to_string(),
                    __args,
                    self.deposit,
                    self.static_gas,
                    self.gas_weight,
                )
        }
    }
    impl FungibleTokenReceiver for FastBridge {
        /// Transfers tokens to the Fast Bridge contract and initiates a transfer to Ethereum if the `msg` parameter is not empty.
        ///
        /// This function is called when the smart contract receives tokens from a sender. If `msg` is not empty, the function decodes the `msg` parameter, which is a `TransferMessage` in borsh Base64 format, and uses it to initiate a token transfer to Ethereum. Otherwise, the function treats it as a deposit action, increases the balance of the sender, and emits a `FastBridgeDepositEvent`.
        ///
        /// Note that this function overrides a standard NEP-141 implementation of `ft_on_transfer()` so the arguments of the function are the same.
        ///
        /// # Arguments
        ///
        /// * `sender_id` - The account ID of the sender.
        /// * `amount` - The amount of tokens being transferred.
        /// * `msg` - The transfer message in borsh Base64 format.
        fn ft_on_transfer(
            &mut self,
            sender_id: AccountId,
            amount: U128,
            msg: String,
        ) -> PromiseOrValue<U128> {
            let mut __check_paused = true;
            let __except_roles: Vec<&str> = ::alloc::vec::Vec::new();
            let __except_roles: Vec<String> = __except_roles
                .iter()
                .map(|&x| x.into())
                .collect();
            let may_bypass = self
                .acl_has_any_role(
                    __except_roles,
                    ::near_sdk::env::predecessor_account_id(),
                );
            if may_bypass {
                __check_paused = false;
            }
            if __check_paused {
                if true {
                    let msg: &str = &"Pausable: Method is paused";
                    if !!self.pa_is_paused("ft_on_transfer".to_string()) {
                        {
                            ::core::panicking::panic_display(&msg);
                        }
                    }
                } else if !!self.pa_is_paused("ft_on_transfer".to_string()) {
                    ::near_sdk::env::panic_str(&"Pausable: Method is paused")
                }
            }
            let token_account_id = env::predecessor_account_id();
            self.check_whitelist_token_and_account(&token_account_id, &sender_id);
            if !msg.is_empty() {
                let decoded_base64 = base64::decode(&msg)
                    .unwrap_or_else(|_| env::panic_str("Invalid base64 message"));
                let transfer_message = TransferMessage::try_from_slice(&decoded_base64)
                    .unwrap_or_else(|_| {
                        env::panic_str("Invalid borsh format of the `TransferMessage`")
                    });
                let update_balance = UpdateBalance {
                    sender_id: sender_id.clone(),
                    token: token_account_id,
                    amount,
                };
                self.init_transfer_internal(
                        transfer_message,
                        sender_id,
                        Some(update_balance),
                    )
                    .into()
            } else {
                self.increase_balance(&sender_id, &token_account_id, &amount.0);
                Event::FastBridgeDepositEvent {
                    sender_id,
                    token: token_account_id,
                    amount,
                }
                    .emit();
                PromiseOrValue::Value(U128::from(0))
            }
        }
    }
    /// Transfers tokens to the Fast Bridge contract and initiates a transfer to Ethereum if the `msg` parameter is not empty.
    ///
    /// This function is called when the smart contract receives tokens from a sender. If `msg` is not empty, the function decodes the `msg` parameter, which is a `TransferMessage` in borsh Base64 format, and uses it to initiate a token transfer to Ethereum. Otherwise, the function treats it as a deposit action, increases the balance of the sender, and emits a `FastBridgeDepositEvent`.
    ///
    /// Note that this function overrides a standard NEP-141 implementation of `ft_on_transfer()` so the arguments of the function are the same.
    ///
    /// # Arguments
    ///
    /// * `sender_id` - The account ID of the sender.
    /// * `amount` - The amount of tokens being transferred.
    /// * `msg` - The transfer message in borsh Base64 format.
    #[cfg(target_arch = "wasm32")]
    #[no_mangle]
    pub extern "C" fn ft_on_transfer() {
        near_sdk::env::setup_panic_hook();
        if near_sdk::env::attached_deposit() != 0 {
            near_sdk::env::panic_str("Method ft_on_transfer doesn't accept deposit");
        }
        #[serde(crate = "near_sdk::serde")]
        struct Input {
            sender_id: AccountId,
            amount: U128,
            msg: String,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            use near_sdk::serde as _serde;
            #[automatically_derived]
            impl<'de> near_sdk::serde::Deserialize<'de> for Input {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> near_sdk::serde::__private::Result<Self, __D::Error>
                where
                    __D: near_sdk::serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "sender_id" => _serde::__private::Ok(__Field::__field0),
                                "amount" => _serde::__private::Ok(__Field::__field1),
                                "msg" => _serde::__private::Ok(__Field::__field2),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"sender_id" => _serde::__private::Ok(__Field::__field0),
                                b"amount" => _serde::__private::Ok(__Field::__field1),
                                b"msg" => _serde::__private::Ok(__Field::__field2),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<Input>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = Input;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct Input",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match match _serde::de::SeqAccess::next_element::<
                                AccountId,
                            >(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct Input with 3 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match match _serde::de::SeqAccess::next_element::<
                                U128,
                            >(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct Input with 3 elements",
                                        ),
                                    );
                                }
                            };
                            let __field2 = match match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            2usize,
                                            &"struct Input with 3 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(Input {
                                sender_id: __field0,
                                amount: __field1,
                                msg: __field2,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<AccountId> = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<U128> = _serde::__private::None;
                            let mut __field2: _serde::__private::Option<String> = _serde::__private::None;
                            while let _serde::__private::Some(__key) = match _serde::de::MapAccess::next_key::<
                                __Field,
                            >(&mut __map) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "sender_id",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<
                                                AccountId,
                                            >(&mut __map) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("amount"),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<
                                                U128,
                                            >(&mut __map) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field2 => {
                                        if _serde::__private::Option::is_some(&__field2) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("msg"),
                                            );
                                        }
                                        __field2 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<
                                                String,
                                            >(&mut __map) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    _ => {
                                        let _ = match _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        };
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("sender_id") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("amount") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field2 = match __field2 {
                                _serde::__private::Some(__field2) => __field2,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("msg") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            _serde::__private::Ok(Input {
                                sender_id: __field0,
                                amount: __field1,
                                msg: __field2,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &[
                        "sender_id",
                        "amount",
                        "msg",
                    ];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "Input",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<Input>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        let Input { sender_id, amount, msg }: Input = near_sdk::serde_json::from_slice(
                &near_sdk::env::input()
                    .expect("Expected input since method has arguments."),
            )
            .expect("Failed to deserialize input from JSON.");
        let mut contract: FastBridge = near_sdk::env::state_read().unwrap_or_default();
        let result = contract.ft_on_transfer(sender_id, amount, msg);
        let result = near_sdk::serde_json::to_vec(&result)
            .expect("Failed to serialize the return value using JSON.");
        near_sdk::env::value_return(&result);
        near_sdk::env::state_write(&contract);
    }
}
mod lp_relayer {
    use eth_types::{LogEntry, H256};
    use ethabi::{Event, EventParam, Hash, ParamType, RawLog};
    use fast_bridge_common::*;
    use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
    type EthEventParams = Vec<(String, ParamType, bool)>;
    const EVENT_NAME: &str = "TransferTokens";
    pub struct EthTransferEvent {
        pub eth_bridge_contract: EthAddress,
        pub nonce: u128,
        pub relayer: EthAddress,
        pub token: EthAddress,
        pub recipient: EthAddress,
        pub amount: u128,
        pub unlock_recipient: String,
        pub transfer_id: H256,
    }
    impl borsh::de::BorshDeserialize for EthTransferEvent
    where
        EthAddress: borsh::BorshDeserialize,
        u128: borsh::BorshDeserialize,
        EthAddress: borsh::BorshDeserialize,
        EthAddress: borsh::BorshDeserialize,
        EthAddress: borsh::BorshDeserialize,
        u128: borsh::BorshDeserialize,
        String: borsh::BorshDeserialize,
        H256: borsh::BorshDeserialize,
    {
        fn deserialize(
            buf: &mut &[u8],
        ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
            Ok(Self {
                eth_bridge_contract: borsh::BorshDeserialize::deserialize(buf)?,
                nonce: borsh::BorshDeserialize::deserialize(buf)?,
                relayer: borsh::BorshDeserialize::deserialize(buf)?,
                token: borsh::BorshDeserialize::deserialize(buf)?,
                recipient: borsh::BorshDeserialize::deserialize(buf)?,
                amount: borsh::BorshDeserialize::deserialize(buf)?,
                unlock_recipient: borsh::BorshDeserialize::deserialize(buf)?,
                transfer_id: borsh::BorshDeserialize::deserialize(buf)?,
            })
        }
    }
    impl borsh::ser::BorshSerialize for EthTransferEvent
    where
        EthAddress: borsh::ser::BorshSerialize,
        u128: borsh::ser::BorshSerialize,
        EthAddress: borsh::ser::BorshSerialize,
        EthAddress: borsh::ser::BorshSerialize,
        EthAddress: borsh::ser::BorshSerialize,
        u128: borsh::ser::BorshSerialize,
        String: borsh::ser::BorshSerialize,
        H256: borsh::ser::BorshSerialize,
    {
        fn serialize<W: borsh::maybestd::io::Write>(
            &self,
            writer: &mut W,
        ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
            borsh::BorshSerialize::serialize(&self.eth_bridge_contract, writer)?;
            borsh::BorshSerialize::serialize(&self.nonce, writer)?;
            borsh::BorshSerialize::serialize(&self.relayer, writer)?;
            borsh::BorshSerialize::serialize(&self.token, writer)?;
            borsh::BorshSerialize::serialize(&self.recipient, writer)?;
            borsh::BorshSerialize::serialize(&self.amount, writer)?;
            borsh::BorshSerialize::serialize(&self.unlock_recipient, writer)?;
            borsh::BorshSerialize::serialize(&self.transfer_id, writer)?;
            Ok(())
        }
    }
    impl EthTransferEvent {
        pub fn event_params() -> EthEventParams {
            <[_]>::into_vec(
                #[rustc_box]
                ::alloc::boxed::Box::new([
                    ("nonce".to_string(), ParamType::Uint(256), true),
                    ("relayer".to_string(), ParamType::Address, false),
                    ("token".to_string(), ParamType::Address, false),
                    ("recipient".to_string(), ParamType::Address, false),
                    ("amount".to_string(), ParamType::Uint(256), false),
                    ("unlock_recipient".to_string(), ParamType::String, false),
                    ("transfer_id".to_string(), ParamType::FixedBytes(32), true),
                ]),
            )
        }
        pub fn parse(proof: Proof) -> Self {
            let data = proof.log_entry_data;
            let params = EthTransferEvent::event_params();
            let event = Event {
                name: EVENT_NAME.to_string(),
                inputs: params
                    .into_iter()
                    .map(|(name, kind, indexed)| EventParam { name, kind, indexed })
                    .collect(),
                anonymous: false,
            };
            let log_entry: LogEntry = rlp::decode(&data).expect("Invalid RLP");
            let locker_address = (log_entry.address.0).0;
            let topics = log_entry
                .topics
                .iter()
                .map(|h| Hash::from(&((h.0).0)))
                .collect();
            let raw_log = RawLog {
                topics,
                data: log_entry.data,
            };
            let log = event.parse_log(raw_log).expect("Failed to parse event log");
            let nonce = log.params[0].value.clone().to_uint().unwrap().as_u128();
            let relayer = log.params[1].value.clone().to_address().unwrap().0;
            let token = log.params[2].value.clone().to_address().unwrap().0;
            let recipient = log.params[3].value.clone().to_address().unwrap().0;
            let amount = log.params[4].value.clone().to_uint().unwrap().as_u128();
            let unlock_recipient = log.params[5].value.clone().to_string().unwrap();
            let transfer_id: H256 = log
                .params[6]
                .value
                .clone()
                .to_fixed_bytes()
                .unwrap()
                .try_into()
                .unwrap();
            Self {
                eth_bridge_contract: EthAddress(locker_address),
                nonce,
                relayer: EthAddress(relayer),
                token: EthAddress(token),
                recipient: EthAddress(recipient),
                amount,
                unlock_recipient,
                transfer_id,
            }
        }
    }
}
mod utils {
    pub const TGAS: near_sdk::Gas = near_sdk::Gas::ONE_TERA;
    pub const NO_DEPOSIT: u128 = 0;
    const STORAGE_KEY_SLOT: u32 = 302;
    pub fn tera_gas(gas: u64) -> near_sdk::Gas {
        TGAS * gas
    }
    pub fn get_eth_storage_key_hash(
        token: fast_bridge_common::EthAddress,
        recipient: fast_bridge_common::EthAddress,
        nonce: eth_types::U256,
        amount: eth_types::U256,
    ) -> Vec<u8> {
        let slot = eth_types::U256(STORAGE_KEY_SLOT.into());
        let mut be_slot = [0u8; 32];
        slot.0.to_big_endian(&mut be_slot);
        let encoded_slot_key = [
            get_transfer_id(token, recipient, nonce, amount).as_slice(),
            be_slot.as_slice(),
        ]
            .concat();
        near_sdk::env::keccak256(&near_sdk::env::keccak256(&encoded_slot_key))
    }
    pub fn get_transfer_id(
        token: fast_bridge_common::EthAddress,
        recipient: fast_bridge_common::EthAddress,
        nonce: eth_types::U256,
        amount: eth_types::U256,
    ) -> Vec<u8> {
        let mut be_nonce = [0u8; 32];
        nonce.0.to_big_endian(&mut be_nonce);
        let mut be_amount = [0u8; 32];
        amount.0.to_big_endian(&mut be_amount);
        let encoded = [
            token.0.as_slice(),
            recipient.0.as_slice(),
            be_nonce.as_slice(),
            be_amount.as_slice(),
        ]
            .concat();
        near_sdk::env::keccak256(encoded.as_slice())
    }
}
mod whitelist {
    use near_plugins::access_control_any;
    use near_sdk::serde::{Deserialize, Serialize};
    use near_sdk::{env, AccountId};
    use crate::*;
    #[serde(crate = "near_sdk::serde")]
    pub enum WhitelistMode {
        Blocked,
        CheckToken,
        CheckAccountAndToken,
    }
    impl borsh::de::BorshDeserialize for WhitelistMode {
        fn deserialize(
            buf: &mut &[u8],
        ) -> core::result::Result<Self, borsh::maybestd::io::Error> {
            let variant_idx: u8 = borsh::BorshDeserialize::deserialize(buf)?;
            let return_value = match variant_idx {
                0u8 => WhitelistMode::Blocked,
                1u8 => WhitelistMode::CheckToken,
                2u8 => WhitelistMode::CheckAccountAndToken,
                _ => {
                    let msg = {
                        let res = ::alloc::fmt::format(
                            format_args!("Unexpected variant index: {0:?}", variant_idx),
                        );
                        res
                    };
                    return Err(
                        borsh::maybestd::io::Error::new(
                            borsh::maybestd::io::ErrorKind::InvalidInput,
                            msg,
                        ),
                    );
                }
            };
            Ok(return_value)
        }
    }
    impl borsh::ser::BorshSerialize for WhitelistMode {
        fn serialize<W: borsh::maybestd::io::Write>(
            &self,
            writer: &mut W,
        ) -> core::result::Result<(), borsh::maybestd::io::Error> {
            let variant_idx: u8 = match self {
                WhitelistMode::Blocked => 0u8,
                WhitelistMode::CheckToken => 1u8,
                WhitelistMode::CheckAccountAndToken => 2u8,
            };
            writer.write_all(&variant_idx.to_le_bytes())?;
            match self {
                WhitelistMode::Blocked => {}
                WhitelistMode::CheckToken => {}
                WhitelistMode::CheckAccountAndToken => {}
            }
            Ok(())
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        use near_sdk::serde as _serde;
        #[automatically_derived]
        impl<'de> near_sdk::serde::Deserialize<'de> for WhitelistMode {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> near_sdk::serde::__private::Result<Self, __D::Error>
            where
                __D: near_sdk::serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "variant identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::invalid_value(
                                        _serde::de::Unexpected::Unsigned(__value),
                                        &"variant index 0 <= i < 3",
                                    ),
                                )
                            }
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "Blocked" => _serde::__private::Ok(__Field::__field0),
                            "CheckToken" => _serde::__private::Ok(__Field::__field1),
                            "CheckAccountAndToken" => {
                                _serde::__private::Ok(__Field::__field2)
                            }
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"Blocked" => _serde::__private::Ok(__Field::__field0),
                            b"CheckToken" => _serde::__private::Ok(__Field::__field1),
                            b"CheckAccountAndToken" => {
                                _serde::__private::Ok(__Field::__field2)
                            }
                            _ => {
                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<WhitelistMode>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = WhitelistMode;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "enum WhitelistMode",
                        )
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match match _serde::de::EnumAccess::variant(__data) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            (__Field::__field0, __variant) => {
                                match _serde::de::VariantAccess::unit_variant(__variant) {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                };
                                _serde::__private::Ok(WhitelistMode::Blocked)
                            }
                            (__Field::__field1, __variant) => {
                                match _serde::de::VariantAccess::unit_variant(__variant) {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                };
                                _serde::__private::Ok(WhitelistMode::CheckToken)
                            }
                            (__Field::__field2, __variant) => {
                                match _serde::de::VariantAccess::unit_variant(__variant) {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                };
                                _serde::__private::Ok(WhitelistMode::CheckAccountAndToken)
                            }
                        }
                    }
                }
                #[doc(hidden)]
                const VARIANTS: &'static [&'static str] = &[
                    "Blocked",
                    "CheckToken",
                    "CheckAccountAndToken",
                ];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "WhitelistMode",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<WhitelistMode>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        use near_sdk::serde as _serde;
        #[automatically_derived]
        impl near_sdk::serde::Serialize for WhitelistMode {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> near_sdk::serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: near_sdk::serde::Serializer,
            {
                match *self {
                    WhitelistMode::Blocked => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "WhitelistMode",
                            0u32,
                            "Blocked",
                        )
                    }
                    WhitelistMode::CheckToken => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "WhitelistMode",
                            1u32,
                            "CheckToken",
                        )
                    }
                    WhitelistMode::CheckAccountAndToken => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "WhitelistMode",
                            2u32,
                            "CheckAccountAndToken",
                        )
                    }
                }
            }
        }
    };
    #[automatically_derived]
    impl ::core::fmt::Debug for WhitelistMode {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(
                f,
                match self {
                    WhitelistMode::Blocked => "Blocked",
                    WhitelistMode::CheckToken => "CheckToken",
                    WhitelistMode::CheckAccountAndToken => "CheckAccountAndToken",
                },
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for WhitelistMode {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for WhitelistMode {
        #[inline]
        fn eq(&self, other: &WhitelistMode) -> bool {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            __self_tag == __arg1_tag
        }
    }
    fn get_token_account_key(token: Option<&AccountId>, account: &AccountId) -> String {
        if let Some(token) = token {
            {
                let res = ::alloc::fmt::format(format_args!("{0}:{1}", token, account));
                res
            }
        } else {
            account.to_string()
        }
    }
    impl FastBridgeExt {
        pub fn set_token_whitelist_mode(
            self,
            token: AccountId,
            mode: WhitelistMode,
        ) -> near_sdk::Promise {
            let __args = {
                #[serde(crate = "near_sdk::serde")]
                struct Input<'nearinput> {
                    token: &'nearinput AccountId,
                    mode: &'nearinput WhitelistMode,
                }
                #[doc(hidden)]
                #[allow(
                    non_upper_case_globals,
                    unused_attributes,
                    unused_qualifications
                )]
                const _: () = {
                    use near_sdk::serde as _serde;
                    #[automatically_derived]
                    impl<'nearinput> near_sdk::serde::Serialize for Input<'nearinput> {
                        fn serialize<__S>(
                            &self,
                            __serializer: __S,
                        ) -> near_sdk::serde::__private::Result<__S::Ok, __S::Error>
                        where
                            __S: near_sdk::serde::Serializer,
                        {
                            let mut __serde_state = match _serde::Serializer::serialize_struct(
                                __serializer,
                                "Input",
                                false as usize + 1 + 1,
                            ) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            };
                            match _serde::ser::SerializeStruct::serialize_field(
                                &mut __serde_state,
                                "token",
                                &self.token,
                            ) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            };
                            match _serde::ser::SerializeStruct::serialize_field(
                                &mut __serde_state,
                                "mode",
                                &self.mode,
                            ) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            };
                            _serde::ser::SerializeStruct::end(__serde_state)
                        }
                    }
                };
                let __args = Input {
                    token: &token,
                    mode: &mode,
                };
                near_sdk::serde_json::to_vec(&__args)
                    .expect("Failed to serialize the cross contract args using JSON.")
            };
            near_sdk::Promise::new(self.account_id)
                .function_call_weight(
                    "set_token_whitelist_mode".to_string(),
                    __args,
                    self.deposit,
                    self.static_gas,
                    self.gas_weight,
                )
        }
        pub fn add_token_to_account_whitelist(
            self,
            token: Option<AccountId>,
            account: AccountId,
        ) -> near_sdk::Promise {
            let __args = {
                #[serde(crate = "near_sdk::serde")]
                struct Input<'nearinput> {
                    token: &'nearinput Option<AccountId>,
                    account: &'nearinput AccountId,
                }
                #[doc(hidden)]
                #[allow(
                    non_upper_case_globals,
                    unused_attributes,
                    unused_qualifications
                )]
                const _: () = {
                    use near_sdk::serde as _serde;
                    #[automatically_derived]
                    impl<'nearinput> near_sdk::serde::Serialize for Input<'nearinput> {
                        fn serialize<__S>(
                            &self,
                            __serializer: __S,
                        ) -> near_sdk::serde::__private::Result<__S::Ok, __S::Error>
                        where
                            __S: near_sdk::serde::Serializer,
                        {
                            let mut __serde_state = match _serde::Serializer::serialize_struct(
                                __serializer,
                                "Input",
                                false as usize + 1 + 1,
                            ) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            };
                            match _serde::ser::SerializeStruct::serialize_field(
                                &mut __serde_state,
                                "token",
                                &self.token,
                            ) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            };
                            match _serde::ser::SerializeStruct::serialize_field(
                                &mut __serde_state,
                                "account",
                                &self.account,
                            ) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            };
                            _serde::ser::SerializeStruct::end(__serde_state)
                        }
                    }
                };
                let __args = Input {
                    token: &token,
                    account: &account,
                };
                near_sdk::serde_json::to_vec(&__args)
                    .expect("Failed to serialize the cross contract args using JSON.")
            };
            near_sdk::Promise::new(self.account_id)
                .function_call_weight(
                    "add_token_to_account_whitelist".to_string(),
                    __args,
                    self.deposit,
                    self.static_gas,
                    self.gas_weight,
                )
        }
        pub fn remove_token_from_account_whitelist(
            self,
            token: Option<AccountId>,
            account: AccountId,
        ) -> near_sdk::Promise {
            let __args = {
                #[serde(crate = "near_sdk::serde")]
                struct Input<'nearinput> {
                    token: &'nearinput Option<AccountId>,
                    account: &'nearinput AccountId,
                }
                #[doc(hidden)]
                #[allow(
                    non_upper_case_globals,
                    unused_attributes,
                    unused_qualifications
                )]
                const _: () = {
                    use near_sdk::serde as _serde;
                    #[automatically_derived]
                    impl<'nearinput> near_sdk::serde::Serialize for Input<'nearinput> {
                        fn serialize<__S>(
                            &self,
                            __serializer: __S,
                        ) -> near_sdk::serde::__private::Result<__S::Ok, __S::Error>
                        where
                            __S: near_sdk::serde::Serializer,
                        {
                            let mut __serde_state = match _serde::Serializer::serialize_struct(
                                __serializer,
                                "Input",
                                false as usize + 1 + 1,
                            ) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            };
                            match _serde::ser::SerializeStruct::serialize_field(
                                &mut __serde_state,
                                "token",
                                &self.token,
                            ) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            };
                            match _serde::ser::SerializeStruct::serialize_field(
                                &mut __serde_state,
                                "account",
                                &self.account,
                            ) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            };
                            _serde::ser::SerializeStruct::end(__serde_state)
                        }
                    }
                };
                let __args = Input {
                    token: &token,
                    account: &account,
                };
                near_sdk::serde_json::to_vec(&__args)
                    .expect("Failed to serialize the cross contract args using JSON.")
            };
            near_sdk::Promise::new(self.account_id)
                .function_call_weight(
                    "remove_token_from_account_whitelist".to_string(),
                    __args,
                    self.deposit,
                    self.static_gas,
                    self.gas_weight,
                )
        }
        pub fn check_whitelist_token_and_account(
            self,
            token: &AccountId,
            account: &AccountId,
        ) -> near_sdk::Promise {
            let __args = {
                #[serde(crate = "near_sdk::serde")]
                struct Input<'nearinput> {
                    token: &'nearinput AccountId,
                    account: &'nearinput AccountId,
                }
                #[doc(hidden)]
                #[allow(
                    non_upper_case_globals,
                    unused_attributes,
                    unused_qualifications
                )]
                const _: () = {
                    use near_sdk::serde as _serde;
                    #[automatically_derived]
                    impl<'nearinput> near_sdk::serde::Serialize for Input<'nearinput> {
                        fn serialize<__S>(
                            &self,
                            __serializer: __S,
                        ) -> near_sdk::serde::__private::Result<__S::Ok, __S::Error>
                        where
                            __S: near_sdk::serde::Serializer,
                        {
                            let mut __serde_state = match _serde::Serializer::serialize_struct(
                                __serializer,
                                "Input",
                                false as usize + 1 + 1,
                            ) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            };
                            match _serde::ser::SerializeStruct::serialize_field(
                                &mut __serde_state,
                                "token",
                                &self.token,
                            ) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            };
                            match _serde::ser::SerializeStruct::serialize_field(
                                &mut __serde_state,
                                "account",
                                &self.account,
                            ) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            };
                            _serde::ser::SerializeStruct::end(__serde_state)
                        }
                    }
                };
                let __args = Input {
                    token: &token,
                    account: &account,
                };
                near_sdk::serde_json::to_vec(&__args)
                    .expect("Failed to serialize the cross contract args using JSON.")
            };
            near_sdk::Promise::new(self.account_id)
                .function_call_weight(
                    "check_whitelist_token_and_account".to_string(),
                    __args,
                    self.deposit,
                    self.static_gas,
                    self.gas_weight,
                )
        }
        pub fn set_whitelist_mode_enabled(self, enabled: bool) -> near_sdk::Promise {
            let __args = {
                #[serde(crate = "near_sdk::serde")]
                struct Input<'nearinput> {
                    enabled: &'nearinput bool,
                }
                #[doc(hidden)]
                #[allow(
                    non_upper_case_globals,
                    unused_attributes,
                    unused_qualifications
                )]
                const _: () = {
                    use near_sdk::serde as _serde;
                    #[automatically_derived]
                    impl<'nearinput> near_sdk::serde::Serialize for Input<'nearinput> {
                        fn serialize<__S>(
                            &self,
                            __serializer: __S,
                        ) -> near_sdk::serde::__private::Result<__S::Ok, __S::Error>
                        where
                            __S: near_sdk::serde::Serializer,
                        {
                            let mut __serde_state = match _serde::Serializer::serialize_struct(
                                __serializer,
                                "Input",
                                false as usize + 1,
                            ) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            };
                            match _serde::ser::SerializeStruct::serialize_field(
                                &mut __serde_state,
                                "enabled",
                                &self.enabled,
                            ) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            };
                            _serde::ser::SerializeStruct::end(__serde_state)
                        }
                    }
                };
                let __args = Input { enabled: &enabled };
                near_sdk::serde_json::to_vec(&__args)
                    .expect("Failed to serialize the cross contract args using JSON.")
            };
            near_sdk::Promise::new(self.account_id)
                .function_call_weight(
                    "set_whitelist_mode_enabled".to_string(),
                    __args,
                    self.deposit,
                    self.static_gas,
                    self.gas_weight,
                )
        }
        pub fn get_whitelist_tokens(self) -> near_sdk::Promise {
            let __args = ::alloc::vec::Vec::new();
            near_sdk::Promise::new(self.account_id)
                .function_call_weight(
                    "get_whitelist_tokens".to_string(),
                    __args,
                    self.deposit,
                    self.static_gas,
                    self.gas_weight,
                )
        }
        pub fn get_whitelist_accounts(self) -> near_sdk::Promise {
            let __args = ::alloc::vec::Vec::new();
            near_sdk::Promise::new(self.account_id)
                .function_call_weight(
                    "get_whitelist_accounts".to_string(),
                    __args,
                    self.deposit,
                    self.static_gas,
                    self.gas_weight,
                )
        }
    }
    impl FastBridge {
        pub fn set_token_whitelist_mode(
            &mut self,
            token: AccountId,
            mode: WhitelistMode,
        ) {
            let __acl_any_roles: Vec<&str> = <[_]>::into_vec(
                #[rustc_box]
                ::alloc::boxed::Box::new([
                    Role::WhitelistManager.into(),
                    Role::DAO.into(),
                ]),
            );
            let __acl_any_roles_ser: Vec<String> = __acl_any_roles
                .iter()
                .map(|&role| role.into())
                .collect();
            let __acl_any_account_id = ::near_sdk::env::predecessor_account_id();
            if !self.acl_has_any_role(__acl_any_roles_ser, __acl_any_account_id) {
                let message = {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "Insufficient permissions for method {0} restricted by access control. Requires one of these roles: {1:?}",
                            "set_token_whitelist_mode",
                            __acl_any_roles,
                        ),
                    );
                    res
                };
                near_sdk::env::panic_str(&message);
            }
            self.whitelist_tokens.insert(&token, &mode);
        }
        pub fn add_token_to_account_whitelist(
            &mut self,
            token: Option<AccountId>,
            account: AccountId,
        ) {
            let __acl_any_roles: Vec<&str> = <[_]>::into_vec(
                #[rustc_box]
                ::alloc::boxed::Box::new([
                    Role::WhitelistManager.into(),
                    Role::DAO.into(),
                ]),
            );
            let __acl_any_roles_ser: Vec<String> = __acl_any_roles
                .iter()
                .map(|&role| role.into())
                .collect();
            let __acl_any_account_id = ::near_sdk::env::predecessor_account_id();
            if !self.acl_has_any_role(__acl_any_roles_ser, __acl_any_account_id) {
                let message = {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "Insufficient permissions for method {0} restricted by access control. Requires one of these roles: {1:?}",
                            "add_token_to_account_whitelist",
                            __acl_any_roles,
                        ),
                    );
                    res
                };
                near_sdk::env::panic_str(&message);
            }
            if let Some(token) = &token {
                if !self.whitelist_tokens.get(token).is_some() {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!("The whitelisted token mode is not set"),
                        );
                    }
                }
            }
            self.whitelist_accounts
                .insert(&get_token_account_key(token.as_ref(), &account));
        }
        pub fn remove_token_from_account_whitelist(
            &mut self,
            token: Option<AccountId>,
            account: AccountId,
        ) -> bool {
            let __acl_any_roles: Vec<&str> = <[_]>::into_vec(
                #[rustc_box]
                ::alloc::boxed::Box::new([
                    Role::WhitelistManager.into(),
                    Role::DAO.into(),
                ]),
            );
            let __acl_any_roles_ser: Vec<String> = __acl_any_roles
                .iter()
                .map(|&role| role.into())
                .collect();
            let __acl_any_account_id = ::near_sdk::env::predecessor_account_id();
            if !self.acl_has_any_role(__acl_any_roles_ser, __acl_any_account_id) {
                let message = {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "Insufficient permissions for method {0} restricted by access control. Requires one of these roles: {1:?}",
                            "remove_token_from_account_whitelist",
                            __acl_any_roles,
                        ),
                    );
                    res
                };
                near_sdk::env::panic_str(&message);
            }
            self.whitelist_accounts
                .remove(&get_token_account_key(token.as_ref(), &account))
        }
        pub fn check_whitelist_token_and_account(
            &self,
            token: &AccountId,
            account: &AccountId,
        ) {
            if !self.is_whitelist_mode_enabled {
                return;
            }
            let token_whitelist_mode = self
                .whitelist_tokens
                .get(token)
                .unwrap_or_else(|| {
                    env::panic_str(
                        {
                            let res = ::alloc::fmt::format(
                                format_args!("The token `{0}` is not whitelisted", token),
                            );
                            res
                        }
                            .as_str(),
                    )
                });
            match token_whitelist_mode {
                WhitelistMode::CheckAccountAndToken => {
                    let token_account_key = get_token_account_key(Some(token), account);
                    if true {
                        let msg: &str = &{
                            let res = ::alloc::fmt::format(
                                format_args!(
                                    "The token `{0}` isn\'t whitelisted for the account `{1}`",
                                    token,
                                    account,
                                ),
                            );
                            res
                        };
                        if !(self.whitelist_accounts.contains(&token_account_key)
                            || self.whitelist_accounts.contains(&account.to_string()))
                        {
                            {
                                ::core::panicking::panic_display(&msg);
                            }
                        }
                    } else if !(self.whitelist_accounts.contains(&token_account_key)
                        || self.whitelist_accounts.contains(&account.to_string()))
                    {
                        ::near_sdk::env::panic_str(
                            &{
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "The token `{0}` isn\'t whitelisted for the account `{1}`",
                                        token,
                                        account,
                                    ),
                                );
                                res
                            },
                        )
                    }
                }
                WhitelistMode::CheckToken => {}
                WhitelistMode::Blocked => {
                    env::panic_str(
                        {
                            let res = ::alloc::fmt::format(
                                format_args!("The token `{0}` is blocked", token),
                            );
                            res
                        }
                            .as_str(),
                    )
                }
            }
        }
        pub fn set_whitelist_mode_enabled(&mut self, enabled: bool) {
            let __acl_any_roles: Vec<&str> = <[_]>::into_vec(
                #[rustc_box]
                ::alloc::boxed::Box::new([
                    Role::WhitelistManager.into(),
                    Role::DAO.into(),
                ]),
            );
            let __acl_any_roles_ser: Vec<String> = __acl_any_roles
                .iter()
                .map(|&role| role.into())
                .collect();
            let __acl_any_account_id = ::near_sdk::env::predecessor_account_id();
            if !self.acl_has_any_role(__acl_any_roles_ser, __acl_any_account_id) {
                let message = {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "Insufficient permissions for method {0} restricted by access control. Requires one of these roles: {1:?}",
                            "set_whitelist_mode_enabled",
                            __acl_any_roles,
                        ),
                    );
                    res
                };
                near_sdk::env::panic_str(&message);
            }
            self.is_whitelist_mode_enabled = enabled;
        }
        pub fn get_whitelist_tokens(&self) -> Vec<(AccountId, WhitelistMode)> {
            self.whitelist_tokens.iter().collect::<Vec<_>>()
        }
        pub fn get_whitelist_accounts(&self) -> Vec<String> {
            self.whitelist_accounts.iter().collect::<Vec<_>>()
        }
    }
    #[cfg(target_arch = "wasm32")]
    #[no_mangle]
    pub extern "C" fn set_token_whitelist_mode() {
        near_sdk::env::setup_panic_hook();
        if near_sdk::env::attached_deposit() != 0 {
            near_sdk::env::panic_str(
                "Method set_token_whitelist_mode doesn't accept deposit",
            );
        }
        #[serde(crate = "near_sdk::serde")]
        struct Input {
            token: AccountId,
            mode: WhitelistMode,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            use near_sdk::serde as _serde;
            #[automatically_derived]
            impl<'de> near_sdk::serde::Deserialize<'de> for Input {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> near_sdk::serde::__private::Result<Self, __D::Error>
                where
                    __D: near_sdk::serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "token" => _serde::__private::Ok(__Field::__field0),
                                "mode" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"token" => _serde::__private::Ok(__Field::__field0),
                                b"mode" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<Input>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = Input;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct Input",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match match _serde::de::SeqAccess::next_element::<
                                AccountId,
                            >(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct Input with 2 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match match _serde::de::SeqAccess::next_element::<
                                WhitelistMode,
                            >(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct Input with 2 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(Input {
                                token: __field0,
                                mode: __field1,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<AccountId> = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<WhitelistMode> = _serde::__private::None;
                            while let _serde::__private::Some(__key) = match _serde::de::MapAccess::next_key::<
                                __Field,
                            >(&mut __map) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("token"),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<
                                                AccountId,
                                            >(&mut __map) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("mode"),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<
                                                WhitelistMode,
                                            >(&mut __map) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    _ => {
                                        let _ = match _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        };
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("token") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("mode") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            _serde::__private::Ok(Input {
                                token: __field0,
                                mode: __field1,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &["token", "mode"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "Input",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<Input>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        let Input { token, mode }: Input = near_sdk::serde_json::from_slice(
                &near_sdk::env::input()
                    .expect("Expected input since method has arguments."),
            )
            .expect("Failed to deserialize input from JSON.");
        let mut contract: FastBridge = near_sdk::env::state_read().unwrap_or_default();
        contract.set_token_whitelist_mode(token, mode);
        near_sdk::env::state_write(&contract);
    }
    #[cfg(target_arch = "wasm32")]
    #[no_mangle]
    pub extern "C" fn add_token_to_account_whitelist() {
        near_sdk::env::setup_panic_hook();
        if near_sdk::env::attached_deposit() != 0 {
            near_sdk::env::panic_str(
                "Method add_token_to_account_whitelist doesn't accept deposit",
            );
        }
        #[serde(crate = "near_sdk::serde")]
        struct Input {
            token: Option<AccountId>,
            account: AccountId,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            use near_sdk::serde as _serde;
            #[automatically_derived]
            impl<'de> near_sdk::serde::Deserialize<'de> for Input {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> near_sdk::serde::__private::Result<Self, __D::Error>
                where
                    __D: near_sdk::serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "token" => _serde::__private::Ok(__Field::__field0),
                                "account" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"token" => _serde::__private::Ok(__Field::__field0),
                                b"account" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<Input>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = Input;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct Input",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match match _serde::de::SeqAccess::next_element::<
                                Option<AccountId>,
                            >(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct Input with 2 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match match _serde::de::SeqAccess::next_element::<
                                AccountId,
                            >(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct Input with 2 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(Input {
                                token: __field0,
                                account: __field1,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<
                                Option<AccountId>,
                            > = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<AccountId> = _serde::__private::None;
                            while let _serde::__private::Some(__key) = match _serde::de::MapAccess::next_key::<
                                __Field,
                            >(&mut __map) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("token"),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<
                                                Option<AccountId>,
                                            >(&mut __map) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "account",
                                                ),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<
                                                AccountId,
                                            >(&mut __map) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    _ => {
                                        let _ = match _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        };
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("token") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("account") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            _serde::__private::Ok(Input {
                                token: __field0,
                                account: __field1,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &["token", "account"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "Input",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<Input>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        let Input { token, account }: Input = near_sdk::serde_json::from_slice(
                &near_sdk::env::input()
                    .expect("Expected input since method has arguments."),
            )
            .expect("Failed to deserialize input from JSON.");
        let mut contract: FastBridge = near_sdk::env::state_read().unwrap_or_default();
        contract.add_token_to_account_whitelist(token, account);
        near_sdk::env::state_write(&contract);
    }
    #[cfg(target_arch = "wasm32")]
    #[no_mangle]
    pub extern "C" fn remove_token_from_account_whitelist() {
        near_sdk::env::setup_panic_hook();
        if near_sdk::env::attached_deposit() != 0 {
            near_sdk::env::panic_str(
                "Method remove_token_from_account_whitelist doesn't accept deposit",
            );
        }
        #[serde(crate = "near_sdk::serde")]
        struct Input {
            token: Option<AccountId>,
            account: AccountId,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            use near_sdk::serde as _serde;
            #[automatically_derived]
            impl<'de> near_sdk::serde::Deserialize<'de> for Input {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> near_sdk::serde::__private::Result<Self, __D::Error>
                where
                    __D: near_sdk::serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "token" => _serde::__private::Ok(__Field::__field0),
                                "account" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"token" => _serde::__private::Ok(__Field::__field0),
                                b"account" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<Input>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = Input;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct Input",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match match _serde::de::SeqAccess::next_element::<
                                Option<AccountId>,
                            >(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct Input with 2 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match match _serde::de::SeqAccess::next_element::<
                                AccountId,
                            >(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct Input with 2 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(Input {
                                token: __field0,
                                account: __field1,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<
                                Option<AccountId>,
                            > = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<AccountId> = _serde::__private::None;
                            while let _serde::__private::Some(__key) = match _serde::de::MapAccess::next_key::<
                                __Field,
                            >(&mut __map) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("token"),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<
                                                Option<AccountId>,
                                            >(&mut __map) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "account",
                                                ),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<
                                                AccountId,
                                            >(&mut __map) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    _ => {
                                        let _ = match _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        };
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("token") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("account") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            _serde::__private::Ok(Input {
                                token: __field0,
                                account: __field1,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &["token", "account"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "Input",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<Input>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        let Input { token, account }: Input = near_sdk::serde_json::from_slice(
                &near_sdk::env::input()
                    .expect("Expected input since method has arguments."),
            )
            .expect("Failed to deserialize input from JSON.");
        let mut contract: FastBridge = near_sdk::env::state_read().unwrap_or_default();
        let result = contract.remove_token_from_account_whitelist(token, account);
        let result = near_sdk::serde_json::to_vec(&result)
            .expect("Failed to serialize the return value using JSON.");
        near_sdk::env::value_return(&result);
        near_sdk::env::state_write(&contract);
    }
    #[cfg(target_arch = "wasm32")]
    #[no_mangle]
    pub extern "C" fn check_whitelist_token_and_account() {
        near_sdk::env::setup_panic_hook();
        #[serde(crate = "near_sdk::serde")]
        struct Input {
            token: AccountId,
            account: AccountId,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            use near_sdk::serde as _serde;
            #[automatically_derived]
            impl<'de> near_sdk::serde::Deserialize<'de> for Input {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> near_sdk::serde::__private::Result<Self, __D::Error>
                where
                    __D: near_sdk::serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "token" => _serde::__private::Ok(__Field::__field0),
                                "account" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"token" => _serde::__private::Ok(__Field::__field0),
                                b"account" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<Input>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = Input;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct Input",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match match _serde::de::SeqAccess::next_element::<
                                AccountId,
                            >(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct Input with 2 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match match _serde::de::SeqAccess::next_element::<
                                AccountId,
                            >(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct Input with 2 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(Input {
                                token: __field0,
                                account: __field1,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<AccountId> = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<AccountId> = _serde::__private::None;
                            while let _serde::__private::Some(__key) = match _serde::de::MapAccess::next_key::<
                                __Field,
                            >(&mut __map) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("token"),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<
                                                AccountId,
                                            >(&mut __map) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "account",
                                                ),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<
                                                AccountId,
                                            >(&mut __map) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    _ => {
                                        let _ = match _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        };
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("token") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("account") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            _serde::__private::Ok(Input {
                                token: __field0,
                                account: __field1,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &["token", "account"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "Input",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<Input>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        let Input { token, account }: Input = near_sdk::serde_json::from_slice(
                &near_sdk::env::input()
                    .expect("Expected input since method has arguments."),
            )
            .expect("Failed to deserialize input from JSON.");
        let contract: FastBridge = near_sdk::env::state_read().unwrap_or_default();
        contract.check_whitelist_token_and_account(&token, &account);
    }
    #[cfg(target_arch = "wasm32")]
    #[no_mangle]
    pub extern "C" fn set_whitelist_mode_enabled() {
        near_sdk::env::setup_panic_hook();
        if near_sdk::env::attached_deposit() != 0 {
            near_sdk::env::panic_str(
                "Method set_whitelist_mode_enabled doesn't accept deposit",
            );
        }
        #[serde(crate = "near_sdk::serde")]
        struct Input {
            enabled: bool,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            use near_sdk::serde as _serde;
            #[automatically_derived]
            impl<'de> near_sdk::serde::Deserialize<'de> for Input {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> near_sdk::serde::__private::Result<Self, __D::Error>
                where
                    __D: near_sdk::serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "enabled" => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"enabled" => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<Input>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = Input;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct Input",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match match _serde::de::SeqAccess::next_element::<
                                bool,
                            >(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct Input with 1 element",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(Input { enabled: __field0 })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<bool> = _serde::__private::None;
                            while let _serde::__private::Some(__key) = match _serde::de::MapAccess::next_key::<
                                __Field,
                            >(&mut __map) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "enabled",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<
                                                bool,
                                            >(&mut __map) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    _ => {
                                        let _ = match _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        };
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("enabled") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            _serde::__private::Ok(Input { enabled: __field0 })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &["enabled"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "Input",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<Input>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        let Input { enabled }: Input = near_sdk::serde_json::from_slice(
                &near_sdk::env::input()
                    .expect("Expected input since method has arguments."),
            )
            .expect("Failed to deserialize input from JSON.");
        let mut contract: FastBridge = near_sdk::env::state_read().unwrap_or_default();
        contract.set_whitelist_mode_enabled(enabled);
        near_sdk::env::state_write(&contract);
    }
    #[cfg(target_arch = "wasm32")]
    #[no_mangle]
    pub extern "C" fn get_whitelist_tokens() {
        near_sdk::env::setup_panic_hook();
        let contract: FastBridge = near_sdk::env::state_read().unwrap_or_default();
        let result = contract.get_whitelist_tokens();
        let result = near_sdk::serde_json::to_vec(&result)
            .expect("Failed to serialize the return value using JSON.");
        near_sdk::env::value_return(&result);
    }
    #[cfg(target_arch = "wasm32")]
    #[no_mangle]
    pub extern "C" fn get_whitelist_accounts() {
        near_sdk::env::setup_panic_hook();
        let contract: FastBridge = near_sdk::env::state_read().unwrap_or_default();
        let result = contract.get_whitelist_accounts();
        let result = near_sdk::serde_json::to_vec(&result)
            .expect("Failed to serialize the return value using JSON.");
        near_sdk::env::value_return(&result);
    }
}
pub const NO_DEPOSIT: u128 = 0;
pub const MIN_DURATION_ALLOWED_TO_FORCE_UNLOCK_NS: u64 = 604800000000000;
pub trait Prover {
    fn verify_log_entry(
        &self,
        log_index: u64,
        log_entry_data: Vec<u8>,
        receipt_index: u64,
        receipt_data: Vec<u8>,
        header_data: Vec<u8>,
        proof: Vec<Vec<u8>>,
        skip_bridge_call: bool,
    ) -> bool;
    fn verify_storage_proof(
        &self,
        header_data: Vec<u8>,
        account_proof: Vec<Vec<u8>>,
        contract_address: Vec<u8>,
        account_state: Vec<u8>,
        storage_key_hash: Vec<u8>,
        storage_proof: Vec<Vec<u8>>,
        value: Vec<u8>,
        min_header_height: Option<u64>,
        max_header_height: Option<u64>,
        skip_bridge_call: bool,
    ) -> PromiseOrValue<bool>;
}
pub mod ext_prover {
    use super::*;
    #[must_use]
    pub struct ProverExt {
        pub(crate) account_id: near_sdk::AccountId,
        pub(crate) deposit: near_sdk::Balance,
        pub(crate) static_gas: near_sdk::Gas,
        pub(crate) gas_weight: near_sdk::GasWeight,
    }
    impl ProverExt {
        pub fn with_attached_deposit(mut self, amount: near_sdk::Balance) -> Self {
            self.deposit = amount;
            self
        }
        pub fn with_static_gas(mut self, static_gas: near_sdk::Gas) -> Self {
            self.static_gas = static_gas;
            self
        }
        pub fn with_unused_gas_weight(mut self, gas_weight: u64) -> Self {
            self.gas_weight = near_sdk::GasWeight(gas_weight);
            self
        }
    }
    /// API for calling this contract's functions in a subsequent execution.
    pub fn ext(account_id: near_sdk::AccountId) -> ProverExt {
        ProverExt {
            account_id,
            deposit: 0,
            static_gas: near_sdk::Gas(0),
            gas_weight: near_sdk::GasWeight::default(),
        }
    }
    impl ProverExt {
        pub fn verify_log_entry(
            self,
            log_index: u64,
            log_entry_data: Vec<u8>,
            receipt_index: u64,
            receipt_data: Vec<u8>,
            header_data: Vec<u8>,
            proof: Vec<Vec<u8>>,
            skip_bridge_call: bool,
        ) -> near_sdk::Promise {
            let __args = {
                struct Input<'nearinput> {
                    log_index: &'nearinput u64,
                    log_entry_data: &'nearinput Vec<u8>,
                    receipt_index: &'nearinput u64,
                    receipt_data: &'nearinput Vec<u8>,
                    header_data: &'nearinput Vec<u8>,
                    proof: &'nearinput Vec<Vec<u8>>,
                    skip_bridge_call: &'nearinput bool,
                }
                impl<'nearinput> borsh::ser::BorshSerialize for Input<'nearinput>
                where
                    &'nearinput u64: borsh::ser::BorshSerialize,
                    &'nearinput Vec<u8>: borsh::ser::BorshSerialize,
                    &'nearinput u64: borsh::ser::BorshSerialize,
                    &'nearinput Vec<u8>: borsh::ser::BorshSerialize,
                    &'nearinput Vec<u8>: borsh::ser::BorshSerialize,
                    &'nearinput Vec<Vec<u8>>: borsh::ser::BorshSerialize,
                    &'nearinput bool: borsh::ser::BorshSerialize,
                {
                    fn serialize<W: borsh::maybestd::io::Write>(
                        &self,
                        writer: &mut W,
                    ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
                        borsh::BorshSerialize::serialize(&self.log_index, writer)?;
                        borsh::BorshSerialize::serialize(&self.log_entry_data, writer)?;
                        borsh::BorshSerialize::serialize(&self.receipt_index, writer)?;
                        borsh::BorshSerialize::serialize(&self.receipt_data, writer)?;
                        borsh::BorshSerialize::serialize(&self.header_data, writer)?;
                        borsh::BorshSerialize::serialize(&self.proof, writer)?;
                        borsh::BorshSerialize::serialize(
                            &self.skip_bridge_call,
                            writer,
                        )?;
                        Ok(())
                    }
                }
                let __args = Input {
                    log_index: &log_index,
                    log_entry_data: &log_entry_data,
                    receipt_index: &receipt_index,
                    receipt_data: &receipt_data,
                    header_data: &header_data,
                    proof: &proof,
                    skip_bridge_call: &skip_bridge_call,
                };
                near_sdk::borsh::BorshSerialize::try_to_vec(&__args)
                    .expect("Failed to serialize the cross contract args using Borsh.")
            };
            near_sdk::Promise::new(self.account_id)
                .function_call_weight(
                    "verify_log_entry".to_string(),
                    __args,
                    self.deposit,
                    self.static_gas,
                    self.gas_weight,
                )
        }
        pub fn verify_storage_proof(
            self,
            header_data: Vec<u8>,
            account_proof: Vec<Vec<u8>>,
            contract_address: Vec<u8>,
            account_state: Vec<u8>,
            storage_key_hash: Vec<u8>,
            storage_proof: Vec<Vec<u8>>,
            value: Vec<u8>,
            min_header_height: Option<u64>,
            max_header_height: Option<u64>,
            skip_bridge_call: bool,
        ) -> near_sdk::Promise {
            let __args = {
                struct Input<'nearinput> {
                    header_data: &'nearinput Vec<u8>,
                    account_proof: &'nearinput Vec<Vec<u8>>,
                    contract_address: &'nearinput Vec<u8>,
                    account_state: &'nearinput Vec<u8>,
                    storage_key_hash: &'nearinput Vec<u8>,
                    storage_proof: &'nearinput Vec<Vec<u8>>,
                    value: &'nearinput Vec<u8>,
                    min_header_height: &'nearinput Option<u64>,
                    max_header_height: &'nearinput Option<u64>,
                    skip_bridge_call: &'nearinput bool,
                }
                impl<'nearinput> borsh::ser::BorshSerialize for Input<'nearinput>
                where
                    &'nearinput Vec<u8>: borsh::ser::BorshSerialize,
                    &'nearinput Vec<Vec<u8>>: borsh::ser::BorshSerialize,
                    &'nearinput Vec<u8>: borsh::ser::BorshSerialize,
                    &'nearinput Vec<u8>: borsh::ser::BorshSerialize,
                    &'nearinput Vec<u8>: borsh::ser::BorshSerialize,
                    &'nearinput Vec<Vec<u8>>: borsh::ser::BorshSerialize,
                    &'nearinput Vec<u8>: borsh::ser::BorshSerialize,
                    &'nearinput Option<u64>: borsh::ser::BorshSerialize,
                    &'nearinput Option<u64>: borsh::ser::BorshSerialize,
                    &'nearinput bool: borsh::ser::BorshSerialize,
                {
                    fn serialize<W: borsh::maybestd::io::Write>(
                        &self,
                        writer: &mut W,
                    ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
                        borsh::BorshSerialize::serialize(&self.header_data, writer)?;
                        borsh::BorshSerialize::serialize(&self.account_proof, writer)?;
                        borsh::BorshSerialize::serialize(
                            &self.contract_address,
                            writer,
                        )?;
                        borsh::BorshSerialize::serialize(&self.account_state, writer)?;
                        borsh::BorshSerialize::serialize(
                            &self.storage_key_hash,
                            writer,
                        )?;
                        borsh::BorshSerialize::serialize(&self.storage_proof, writer)?;
                        borsh::BorshSerialize::serialize(&self.value, writer)?;
                        borsh::BorshSerialize::serialize(
                            &self.min_header_height,
                            writer,
                        )?;
                        borsh::BorshSerialize::serialize(
                            &self.max_header_height,
                            writer,
                        )?;
                        borsh::BorshSerialize::serialize(
                            &self.skip_bridge_call,
                            writer,
                        )?;
                        Ok(())
                    }
                }
                let __args = Input {
                    header_data: &header_data,
                    account_proof: &account_proof,
                    contract_address: &contract_address,
                    account_state: &account_state,
                    storage_key_hash: &storage_key_hash,
                    storage_proof: &storage_proof,
                    value: &value,
                    min_header_height: &min_header_height,
                    max_header_height: &max_header_height,
                    skip_bridge_call: &skip_bridge_call,
                };
                near_sdk::borsh::BorshSerialize::try_to_vec(&__args)
                    .expect("Failed to serialize the cross contract args using Borsh.")
            };
            near_sdk::Promise::new(self.account_id)
                .function_call_weight(
                    "verify_storage_proof".to_string(),
                    __args,
                    self.deposit,
                    self.static_gas,
                    self.gas_weight,
                )
        }
    }
}
pub trait EthClient {
    fn last_block_number(&self) -> u64;
}
pub mod ext_eth_client {
    use super::*;
    #[must_use]
    pub struct EthClientExt {
        pub(crate) account_id: near_sdk::AccountId,
        pub(crate) deposit: near_sdk::Balance,
        pub(crate) static_gas: near_sdk::Gas,
        pub(crate) gas_weight: near_sdk::GasWeight,
    }
    impl EthClientExt {
        pub fn with_attached_deposit(mut self, amount: near_sdk::Balance) -> Self {
            self.deposit = amount;
            self
        }
        pub fn with_static_gas(mut self, static_gas: near_sdk::Gas) -> Self {
            self.static_gas = static_gas;
            self
        }
        pub fn with_unused_gas_weight(mut self, gas_weight: u64) -> Self {
            self.gas_weight = near_sdk::GasWeight(gas_weight);
            self
        }
    }
    /// API for calling this contract's functions in a subsequent execution.
    pub fn ext(account_id: near_sdk::AccountId) -> EthClientExt {
        EthClientExt {
            account_id,
            deposit: 0,
            static_gas: near_sdk::Gas(0),
            gas_weight: near_sdk::GasWeight::default(),
        }
    }
    impl EthClientExt {
        pub fn last_block_number(self) -> near_sdk::Promise {
            let __args = ::alloc::vec::Vec::new();
            near_sdk::Promise::new(self.account_id)
                .function_call_weight(
                    "last_block_number".to_string(),
                    __args,
                    self.deposit,
                    self.static_gas,
                    self.gas_weight,
                )
        }
    }
}
trait NEP141Token {
    fn ft_transfer(
        &mut self,
        receiver_id: AccountId,
        amount: U128,
        memo: Option<String>,
    );
    fn ft_transfer_call(&mut self, receiver_id: AccountId, amount: U128, msg: String);
}
pub mod ext_token {
    use super::*;
    #[must_use]
    pub struct NEP141TokenExt {
        pub(crate) account_id: near_sdk::AccountId,
        pub(crate) deposit: near_sdk::Balance,
        pub(crate) static_gas: near_sdk::Gas,
        pub(crate) gas_weight: near_sdk::GasWeight,
    }
    impl NEP141TokenExt {
        pub fn with_attached_deposit(mut self, amount: near_sdk::Balance) -> Self {
            self.deposit = amount;
            self
        }
        pub fn with_static_gas(mut self, static_gas: near_sdk::Gas) -> Self {
            self.static_gas = static_gas;
            self
        }
        pub fn with_unused_gas_weight(mut self, gas_weight: u64) -> Self {
            self.gas_weight = near_sdk::GasWeight(gas_weight);
            self
        }
    }
    /// API for calling this contract's functions in a subsequent execution.
    pub fn ext(account_id: near_sdk::AccountId) -> NEP141TokenExt {
        NEP141TokenExt {
            account_id,
            deposit: 0,
            static_gas: near_sdk::Gas(0),
            gas_weight: near_sdk::GasWeight::default(),
        }
    }
    impl NEP141TokenExt {
        pub fn ft_transfer(
            self,
            receiver_id: AccountId,
            amount: U128,
            memo: Option<String>,
        ) -> near_sdk::Promise {
            let __args = {
                #[serde(crate = "near_sdk::serde")]
                struct Input<'nearinput> {
                    receiver_id: &'nearinput AccountId,
                    amount: &'nearinput U128,
                    memo: &'nearinput Option<String>,
                }
                #[doc(hidden)]
                #[allow(
                    non_upper_case_globals,
                    unused_attributes,
                    unused_qualifications
                )]
                const _: () = {
                    use near_sdk::serde as _serde;
                    #[automatically_derived]
                    impl<'nearinput> near_sdk::serde::Serialize for Input<'nearinput> {
                        fn serialize<__S>(
                            &self,
                            __serializer: __S,
                        ) -> near_sdk::serde::__private::Result<__S::Ok, __S::Error>
                        where
                            __S: near_sdk::serde::Serializer,
                        {
                            let mut __serde_state = match _serde::Serializer::serialize_struct(
                                __serializer,
                                "Input",
                                false as usize + 1 + 1 + 1,
                            ) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            };
                            match _serde::ser::SerializeStruct::serialize_field(
                                &mut __serde_state,
                                "receiver_id",
                                &self.receiver_id,
                            ) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            };
                            match _serde::ser::SerializeStruct::serialize_field(
                                &mut __serde_state,
                                "amount",
                                &self.amount,
                            ) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            };
                            match _serde::ser::SerializeStruct::serialize_field(
                                &mut __serde_state,
                                "memo",
                                &self.memo,
                            ) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            };
                            _serde::ser::SerializeStruct::end(__serde_state)
                        }
                    }
                };
                let __args = Input {
                    receiver_id: &receiver_id,
                    amount: &amount,
                    memo: &memo,
                };
                near_sdk::serde_json::to_vec(&__args)
                    .expect("Failed to serialize the cross contract args using JSON.")
            };
            near_sdk::Promise::new(self.account_id)
                .function_call_weight(
                    "ft_transfer".to_string(),
                    __args,
                    self.deposit,
                    self.static_gas,
                    self.gas_weight,
                )
        }
        pub fn ft_transfer_call(
            self,
            receiver_id: AccountId,
            amount: U128,
            msg: String,
        ) -> near_sdk::Promise {
            let __args = {
                #[serde(crate = "near_sdk::serde")]
                struct Input<'nearinput> {
                    receiver_id: &'nearinput AccountId,
                    amount: &'nearinput U128,
                    msg: &'nearinput String,
                }
                #[doc(hidden)]
                #[allow(
                    non_upper_case_globals,
                    unused_attributes,
                    unused_qualifications
                )]
                const _: () = {
                    use near_sdk::serde as _serde;
                    #[automatically_derived]
                    impl<'nearinput> near_sdk::serde::Serialize for Input<'nearinput> {
                        fn serialize<__S>(
                            &self,
                            __serializer: __S,
                        ) -> near_sdk::serde::__private::Result<__S::Ok, __S::Error>
                        where
                            __S: near_sdk::serde::Serializer,
                        {
                            let mut __serde_state = match _serde::Serializer::serialize_struct(
                                __serializer,
                                "Input",
                                false as usize + 1 + 1 + 1,
                            ) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            };
                            match _serde::ser::SerializeStruct::serialize_field(
                                &mut __serde_state,
                                "receiver_id",
                                &self.receiver_id,
                            ) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            };
                            match _serde::ser::SerializeStruct::serialize_field(
                                &mut __serde_state,
                                "amount",
                                &self.amount,
                            ) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            };
                            match _serde::ser::SerializeStruct::serialize_field(
                                &mut __serde_state,
                                "msg",
                                &self.msg,
                            ) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            };
                            _serde::ser::SerializeStruct::end(__serde_state)
                        }
                    }
                };
                let __args = Input {
                    receiver_id: &receiver_id,
                    amount: &amount,
                    msg: &msg,
                };
                near_sdk::serde_json::to_vec(&__args)
                    .expect("Failed to serialize the cross contract args using JSON.")
            };
            near_sdk::Promise::new(self.account_id)
                .function_call_weight(
                    "ft_transfer_call".to_string(),
                    __args,
                    self.deposit,
                    self.static_gas,
                    self.gas_weight,
                )
        }
    }
}
trait FastBridgeInterface {
    fn withdraw_callback(
        &mut self,
        token_id: AccountId,
        amount: U128,
        recipient_id: AccountId,
    );
    fn verify_log_entry_callback(
        &mut self,
        verification_success: bool,
        proof: EthTransferEvent,
    ) -> Promise;
    fn unlock_callback(
        &mut self,
        verification_result: bool,
        nonce: U128,
        sender_id: AccountId,
    );
    fn init_transfer_callback(
        &mut self,
        transfer_message: TransferMessage,
        sender_id: AccountId,
        update_balance: Option<UpdateBalance>,
    ) -> PromiseOrValue<U128>;
    fn unlock_and_withdraw_callback(
        &mut self,
        transfer_data: TransferMessage,
        sender_id: AccountId,
        recipient_id: Option<AccountId>,
        aurora_native_token_account_id: Option<AccountId>,
    ) -> Promise;
    fn unlock_and_withdraw_return_transfer_msg(
        &self,
        withdraw_amount: U128,
        transfer_data: TransferMessage,
    ) -> TransferMessage;
}
pub mod ext_self {
    use super::*;
    #[must_use]
    pub struct FastBridgeInterfaceExt {
        pub(crate) account_id: near_sdk::AccountId,
        pub(crate) deposit: near_sdk::Balance,
        pub(crate) static_gas: near_sdk::Gas,
        pub(crate) gas_weight: near_sdk::GasWeight,
    }
    impl FastBridgeInterfaceExt {
        pub fn with_attached_deposit(mut self, amount: near_sdk::Balance) -> Self {
            self.deposit = amount;
            self
        }
        pub fn with_static_gas(mut self, static_gas: near_sdk::Gas) -> Self {
            self.static_gas = static_gas;
            self
        }
        pub fn with_unused_gas_weight(mut self, gas_weight: u64) -> Self {
            self.gas_weight = near_sdk::GasWeight(gas_weight);
            self
        }
    }
    /// API for calling this contract's functions in a subsequent execution.
    pub fn ext(account_id: near_sdk::AccountId) -> FastBridgeInterfaceExt {
        FastBridgeInterfaceExt {
            account_id,
            deposit: 0,
            static_gas: near_sdk::Gas(0),
            gas_weight: near_sdk::GasWeight::default(),
        }
    }
    impl FastBridgeInterfaceExt {
        pub fn withdraw_callback(
            self,
            token_id: AccountId,
            amount: U128,
            recipient_id: AccountId,
        ) -> near_sdk::Promise {
            let __args = {
                #[serde(crate = "near_sdk::serde")]
                struct Input<'nearinput> {
                    token_id: &'nearinput AccountId,
                    amount: &'nearinput U128,
                    recipient_id: &'nearinput AccountId,
                }
                #[doc(hidden)]
                #[allow(
                    non_upper_case_globals,
                    unused_attributes,
                    unused_qualifications
                )]
                const _: () = {
                    use near_sdk::serde as _serde;
                    #[automatically_derived]
                    impl<'nearinput> near_sdk::serde::Serialize for Input<'nearinput> {
                        fn serialize<__S>(
                            &self,
                            __serializer: __S,
                        ) -> near_sdk::serde::__private::Result<__S::Ok, __S::Error>
                        where
                            __S: near_sdk::serde::Serializer,
                        {
                            let mut __serde_state = match _serde::Serializer::serialize_struct(
                                __serializer,
                                "Input",
                                false as usize + 1 + 1 + 1,
                            ) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            };
                            match _serde::ser::SerializeStruct::serialize_field(
                                &mut __serde_state,
                                "token_id",
                                &self.token_id,
                            ) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            };
                            match _serde::ser::SerializeStruct::serialize_field(
                                &mut __serde_state,
                                "amount",
                                &self.amount,
                            ) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            };
                            match _serde::ser::SerializeStruct::serialize_field(
                                &mut __serde_state,
                                "recipient_id",
                                &self.recipient_id,
                            ) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            };
                            _serde::ser::SerializeStruct::end(__serde_state)
                        }
                    }
                };
                let __args = Input {
                    token_id: &token_id,
                    amount: &amount,
                    recipient_id: &recipient_id,
                };
                near_sdk::serde_json::to_vec(&__args)
                    .expect("Failed to serialize the cross contract args using JSON.")
            };
            near_sdk::Promise::new(self.account_id)
                .function_call_weight(
                    "withdraw_callback".to_string(),
                    __args,
                    self.deposit,
                    self.static_gas,
                    self.gas_weight,
                )
        }
        pub fn verify_log_entry_callback(
            self,
            proof: EthTransferEvent,
        ) -> near_sdk::Promise {
            let __args = {
                struct Input<'nearinput> {
                    proof: &'nearinput EthTransferEvent,
                }
                impl<'nearinput> borsh::ser::BorshSerialize for Input<'nearinput>
                where
                    &'nearinput EthTransferEvent: borsh::ser::BorshSerialize,
                {
                    fn serialize<W: borsh::maybestd::io::Write>(
                        &self,
                        writer: &mut W,
                    ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
                        borsh::BorshSerialize::serialize(&self.proof, writer)?;
                        Ok(())
                    }
                }
                let __args = Input { proof: &proof };
                near_sdk::borsh::BorshSerialize::try_to_vec(&__args)
                    .expect("Failed to serialize the cross contract args using Borsh.")
            };
            near_sdk::Promise::new(self.account_id)
                .function_call_weight(
                    "verify_log_entry_callback".to_string(),
                    __args,
                    self.deposit,
                    self.static_gas,
                    self.gas_weight,
                )
        }
        pub fn unlock_callback(
            self,
            nonce: U128,
            sender_id: AccountId,
        ) -> near_sdk::Promise {
            let __args = {
                struct Input<'nearinput> {
                    nonce: &'nearinput U128,
                    sender_id: &'nearinput AccountId,
                }
                impl<'nearinput> borsh::ser::BorshSerialize for Input<'nearinput>
                where
                    &'nearinput U128: borsh::ser::BorshSerialize,
                    &'nearinput AccountId: borsh::ser::BorshSerialize,
                {
                    fn serialize<W: borsh::maybestd::io::Write>(
                        &self,
                        writer: &mut W,
                    ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
                        borsh::BorshSerialize::serialize(&self.nonce, writer)?;
                        borsh::BorshSerialize::serialize(&self.sender_id, writer)?;
                        Ok(())
                    }
                }
                let __args = Input {
                    nonce: &nonce,
                    sender_id: &sender_id,
                };
                near_sdk::borsh::BorshSerialize::try_to_vec(&__args)
                    .expect("Failed to serialize the cross contract args using Borsh.")
            };
            near_sdk::Promise::new(self.account_id)
                .function_call_weight(
                    "unlock_callback".to_string(),
                    __args,
                    self.deposit,
                    self.static_gas,
                    self.gas_weight,
                )
        }
        pub fn init_transfer_callback(
            self,
            transfer_message: TransferMessage,
            sender_id: AccountId,
            update_balance: Option<UpdateBalance>,
        ) -> near_sdk::Promise {
            let __args = {
                struct Input<'nearinput> {
                    transfer_message: &'nearinput TransferMessage,
                    sender_id: &'nearinput AccountId,
                    update_balance: &'nearinput Option<UpdateBalance>,
                }
                impl<'nearinput> borsh::ser::BorshSerialize for Input<'nearinput>
                where
                    &'nearinput TransferMessage: borsh::ser::BorshSerialize,
                    &'nearinput AccountId: borsh::ser::BorshSerialize,
                    &'nearinput Option<UpdateBalance>: borsh::ser::BorshSerialize,
                {
                    fn serialize<W: borsh::maybestd::io::Write>(
                        &self,
                        writer: &mut W,
                    ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
                        borsh::BorshSerialize::serialize(
                            &self.transfer_message,
                            writer,
                        )?;
                        borsh::BorshSerialize::serialize(&self.sender_id, writer)?;
                        borsh::BorshSerialize::serialize(&self.update_balance, writer)?;
                        Ok(())
                    }
                }
                let __args = Input {
                    transfer_message: &transfer_message,
                    sender_id: &sender_id,
                    update_balance: &update_balance,
                };
                near_sdk::borsh::BorshSerialize::try_to_vec(&__args)
                    .expect("Failed to serialize the cross contract args using Borsh.")
            };
            near_sdk::Promise::new(self.account_id)
                .function_call_weight(
                    "init_transfer_callback".to_string(),
                    __args,
                    self.deposit,
                    self.static_gas,
                    self.gas_weight,
                )
        }
        pub fn unlock_and_withdraw_callback(
            self,
            sender_id: AccountId,
            recipient_id: Option<AccountId>,
            aurora_native_token_account_id: Option<AccountId>,
        ) -> near_sdk::Promise {
            let __args = {
                struct Input<'nearinput> {
                    sender_id: &'nearinput AccountId,
                    recipient_id: &'nearinput Option<AccountId>,
                    aurora_native_token_account_id: &'nearinput Option<AccountId>,
                }
                impl<'nearinput> borsh::ser::BorshSerialize for Input<'nearinput>
                where
                    &'nearinput AccountId: borsh::ser::BorshSerialize,
                    &'nearinput Option<AccountId>: borsh::ser::BorshSerialize,
                    &'nearinput Option<AccountId>: borsh::ser::BorshSerialize,
                {
                    fn serialize<W: borsh::maybestd::io::Write>(
                        &self,
                        writer: &mut W,
                    ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
                        borsh::BorshSerialize::serialize(&self.sender_id, writer)?;
                        borsh::BorshSerialize::serialize(&self.recipient_id, writer)?;
                        borsh::BorshSerialize::serialize(
                            &self.aurora_native_token_account_id,
                            writer,
                        )?;
                        Ok(())
                    }
                }
                let __args = Input {
                    sender_id: &sender_id,
                    recipient_id: &recipient_id,
                    aurora_native_token_account_id: &aurora_native_token_account_id,
                };
                near_sdk::borsh::BorshSerialize::try_to_vec(&__args)
                    .expect("Failed to serialize the cross contract args using Borsh.")
            };
            near_sdk::Promise::new(self.account_id)
                .function_call_weight(
                    "unlock_and_withdraw_callback".to_string(),
                    __args,
                    self.deposit,
                    self.static_gas,
                    self.gas_weight,
                )
        }
        pub fn unlock_and_withdraw_return_transfer_msg(
            self,
            transfer_data: TransferMessage,
        ) -> near_sdk::Promise {
            let __args = {
                #[serde(crate = "near_sdk::serde")]
                struct Input<'nearinput> {
                    transfer_data: &'nearinput TransferMessage,
                }
                #[doc(hidden)]
                #[allow(
                    non_upper_case_globals,
                    unused_attributes,
                    unused_qualifications
                )]
                const _: () = {
                    use near_sdk::serde as _serde;
                    #[automatically_derived]
                    impl<'nearinput> near_sdk::serde::Serialize for Input<'nearinput> {
                        fn serialize<__S>(
                            &self,
                            __serializer: __S,
                        ) -> near_sdk::serde::__private::Result<__S::Ok, __S::Error>
                        where
                            __S: near_sdk::serde::Serializer,
                        {
                            let mut __serde_state = match _serde::Serializer::serialize_struct(
                                __serializer,
                                "Input",
                                false as usize + 1,
                            ) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            };
                            match _serde::ser::SerializeStruct::serialize_field(
                                &mut __serde_state,
                                "transfer_data",
                                &self.transfer_data,
                            ) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            };
                            _serde::ser::SerializeStruct::end(__serde_state)
                        }
                    }
                };
                let __args = Input {
                    transfer_data: &transfer_data,
                };
                near_sdk::serde_json::to_vec(&__args)
                    .expect("Failed to serialize the cross contract args using JSON.")
            };
            near_sdk::Promise::new(self.account_id)
                .function_call_weight(
                    "unlock_and_withdraw_return_transfer_msg".to_string(),
                    __args,
                    self.deposit,
                    self.static_gas,
                    self.gas_weight,
                )
        }
    }
}
pub struct UnlockProof {
    header_data: Vec<u8>,
    account_proof: Vec<Vec<u8>>,
    account_data: Vec<u8>,
    storage_proof: Vec<Vec<u8>>,
}
#[automatically_derived]
impl ::core::default::Default for UnlockProof {
    #[inline]
    fn default() -> UnlockProof {
        UnlockProof {
            header_data: ::core::default::Default::default(),
            account_proof: ::core::default::Default::default(),
            account_data: ::core::default::Default::default(),
            storage_proof: ::core::default::Default::default(),
        }
    }
}
impl borsh::de::BorshDeserialize for UnlockProof
where
    Vec<u8>: borsh::BorshDeserialize,
    Vec<Vec<u8>>: borsh::BorshDeserialize,
    Vec<u8>: borsh::BorshDeserialize,
    Vec<Vec<u8>>: borsh::BorshDeserialize,
{
    fn deserialize(
        buf: &mut &[u8],
    ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
        Ok(Self {
            header_data: borsh::BorshDeserialize::deserialize(buf)?,
            account_proof: borsh::BorshDeserialize::deserialize(buf)?,
            account_data: borsh::BorshDeserialize::deserialize(buf)?,
            storage_proof: borsh::BorshDeserialize::deserialize(buf)?,
        })
    }
}
impl borsh::ser::BorshSerialize for UnlockProof
where
    Vec<u8>: borsh::ser::BorshSerialize,
    Vec<Vec<u8>>: borsh::ser::BorshSerialize,
    Vec<u8>: borsh::ser::BorshSerialize,
    Vec<Vec<u8>>: borsh::ser::BorshSerialize,
{
    fn serialize<W: borsh::maybestd::io::Write>(
        &self,
        writer: &mut W,
    ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
        borsh::BorshSerialize::serialize(&self.header_data, writer)?;
        borsh::BorshSerialize::serialize(&self.account_proof, writer)?;
        borsh::BorshSerialize::serialize(&self.account_data, writer)?;
        borsh::BorshSerialize::serialize(&self.storage_proof, writer)?;
        Ok(())
    }
}
#[automatically_derived]
impl ::core::fmt::Debug for UnlockProof {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        ::core::fmt::Formatter::debug_struct_field4_finish(
            f,
            "UnlockProof",
            "header_data",
            &self.header_data,
            "account_proof",
            &self.account_proof,
            "account_data",
            &self.account_data,
            "storage_proof",
            &&self.storage_proof,
        )
    }
}
#[automatically_derived]
impl ::core::clone::Clone for UnlockProof {
    #[inline]
    fn clone(&self) -> UnlockProof {
        UnlockProof {
            header_data: ::core::clone::Clone::clone(&self.header_data),
            account_proof: ::core::clone::Clone::clone(&self.account_proof),
            account_data: ::core::clone::Clone::clone(&self.account_data),
            storage_proof: ::core::clone::Clone::clone(&self.storage_proof),
        }
    }
}
#[doc(hidden)]
#[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
const _: () = {
    #[allow(unused_extern_crates, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl _serde::Serialize for UnlockProof {
        fn serialize<__S>(
            &self,
            __serializer: __S,
        ) -> _serde::__private::Result<__S::Ok, __S::Error>
        where
            __S: _serde::Serializer,
        {
            let mut __serde_state = match _serde::Serializer::serialize_struct(
                __serializer,
                "UnlockProof",
                false as usize + 1 + 1 + 1 + 1,
            ) {
                _serde::__private::Ok(__val) => __val,
                _serde::__private::Err(__err) => {
                    return _serde::__private::Err(__err);
                }
            };
            match _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "header_data",
                &self.header_data,
            ) {
                _serde::__private::Ok(__val) => __val,
                _serde::__private::Err(__err) => {
                    return _serde::__private::Err(__err);
                }
            };
            match _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "account_proof",
                &self.account_proof,
            ) {
                _serde::__private::Ok(__val) => __val,
                _serde::__private::Err(__err) => {
                    return _serde::__private::Err(__err);
                }
            };
            match _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "account_data",
                &self.account_data,
            ) {
                _serde::__private::Ok(__val) => __val,
                _serde::__private::Err(__err) => {
                    return _serde::__private::Err(__err);
                }
            };
            match _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "storage_proof",
                &self.storage_proof,
            ) {
                _serde::__private::Ok(__val) => __val,
                _serde::__private::Err(__err) => {
                    return _serde::__private::Err(__err);
                }
            };
            _serde::ser::SerializeStruct::end(__serde_state)
        }
    }
};
#[doc(hidden)]
#[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
const _: () = {
    #[allow(unused_extern_crates, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl<'de> _serde::Deserialize<'de> for UnlockProof {
        fn deserialize<__D>(
            __deserializer: __D,
        ) -> _serde::__private::Result<Self, __D::Error>
        where
            __D: _serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            enum __Field {
                __field0,
                __field1,
                __field2,
                __field3,
                __ignore,
            }
            #[doc(hidden)]
            struct __FieldVisitor;
            impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                type Value = __Field;
                fn expecting(
                    &self,
                    __formatter: &mut _serde::__private::Formatter,
                ) -> _serde::__private::fmt::Result {
                    _serde::__private::Formatter::write_str(
                        __formatter,
                        "field identifier",
                    )
                }
                fn visit_u64<__E>(
                    self,
                    __value: u64,
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        0u64 => _serde::__private::Ok(__Field::__field0),
                        1u64 => _serde::__private::Ok(__Field::__field1),
                        2u64 => _serde::__private::Ok(__Field::__field2),
                        3u64 => _serde::__private::Ok(__Field::__field3),
                        _ => _serde::__private::Ok(__Field::__ignore),
                    }
                }
                fn visit_str<__E>(
                    self,
                    __value: &str,
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        "header_data" => _serde::__private::Ok(__Field::__field0),
                        "account_proof" => _serde::__private::Ok(__Field::__field1),
                        "account_data" => _serde::__private::Ok(__Field::__field2),
                        "storage_proof" => _serde::__private::Ok(__Field::__field3),
                        _ => _serde::__private::Ok(__Field::__ignore),
                    }
                }
                fn visit_bytes<__E>(
                    self,
                    __value: &[u8],
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        b"header_data" => _serde::__private::Ok(__Field::__field0),
                        b"account_proof" => _serde::__private::Ok(__Field::__field1),
                        b"account_data" => _serde::__private::Ok(__Field::__field2),
                        b"storage_proof" => _serde::__private::Ok(__Field::__field3),
                        _ => _serde::__private::Ok(__Field::__ignore),
                    }
                }
            }
            impl<'de> _serde::Deserialize<'de> for __Field {
                #[inline]
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    _serde::Deserializer::deserialize_identifier(
                        __deserializer,
                        __FieldVisitor,
                    )
                }
            }
            #[doc(hidden)]
            struct __Visitor<'de> {
                marker: _serde::__private::PhantomData<UnlockProof>,
                lifetime: _serde::__private::PhantomData<&'de ()>,
            }
            impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                type Value = UnlockProof;
                fn expecting(
                    &self,
                    __formatter: &mut _serde::__private::Formatter,
                ) -> _serde::__private::fmt::Result {
                    _serde::__private::Formatter::write_str(
                        __formatter,
                        "struct UnlockProof",
                    )
                }
                #[inline]
                fn visit_seq<__A>(
                    self,
                    mut __seq: __A,
                ) -> _serde::__private::Result<Self::Value, __A::Error>
                where
                    __A: _serde::de::SeqAccess<'de>,
                {
                    let __field0 = match match _serde::de::SeqAccess::next_element::<
                        Vec<u8>,
                    >(&mut __seq) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    } {
                        _serde::__private::Some(__value) => __value,
                        _serde::__private::None => {
                            return _serde::__private::Err(
                                _serde::de::Error::invalid_length(
                                    0usize,
                                    &"struct UnlockProof with 4 elements",
                                ),
                            );
                        }
                    };
                    let __field1 = match match _serde::de::SeqAccess::next_element::<
                        Vec<Vec<u8>>,
                    >(&mut __seq) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    } {
                        _serde::__private::Some(__value) => __value,
                        _serde::__private::None => {
                            return _serde::__private::Err(
                                _serde::de::Error::invalid_length(
                                    1usize,
                                    &"struct UnlockProof with 4 elements",
                                ),
                            );
                        }
                    };
                    let __field2 = match match _serde::de::SeqAccess::next_element::<
                        Vec<u8>,
                    >(&mut __seq) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    } {
                        _serde::__private::Some(__value) => __value,
                        _serde::__private::None => {
                            return _serde::__private::Err(
                                _serde::de::Error::invalid_length(
                                    2usize,
                                    &"struct UnlockProof with 4 elements",
                                ),
                            );
                        }
                    };
                    let __field3 = match match _serde::de::SeqAccess::next_element::<
                        Vec<Vec<u8>>,
                    >(&mut __seq) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    } {
                        _serde::__private::Some(__value) => __value,
                        _serde::__private::None => {
                            return _serde::__private::Err(
                                _serde::de::Error::invalid_length(
                                    3usize,
                                    &"struct UnlockProof with 4 elements",
                                ),
                            );
                        }
                    };
                    _serde::__private::Ok(UnlockProof {
                        header_data: __field0,
                        account_proof: __field1,
                        account_data: __field2,
                        storage_proof: __field3,
                    })
                }
                #[inline]
                fn visit_map<__A>(
                    self,
                    mut __map: __A,
                ) -> _serde::__private::Result<Self::Value, __A::Error>
                where
                    __A: _serde::de::MapAccess<'de>,
                {
                    let mut __field0: _serde::__private::Option<Vec<u8>> = _serde::__private::None;
                    let mut __field1: _serde::__private::Option<Vec<Vec<u8>>> = _serde::__private::None;
                    let mut __field2: _serde::__private::Option<Vec<u8>> = _serde::__private::None;
                    let mut __field3: _serde::__private::Option<Vec<Vec<u8>>> = _serde::__private::None;
                    while let _serde::__private::Some(__key) = match _serde::de::MapAccess::next_key::<
                        __Field,
                    >(&mut __map) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    } {
                        match __key {
                            __Field::__field0 => {
                                if _serde::__private::Option::is_some(&__field0) {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                            "header_data",
                                        ),
                                    );
                                }
                                __field0 = _serde::__private::Some(
                                    match _serde::de::MapAccess::next_value::<
                                        Vec<u8>,
                                    >(&mut __map) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    },
                                );
                            }
                            __Field::__field1 => {
                                if _serde::__private::Option::is_some(&__field1) {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                            "account_proof",
                                        ),
                                    );
                                }
                                __field1 = _serde::__private::Some(
                                    match _serde::de::MapAccess::next_value::<
                                        Vec<Vec<u8>>,
                                    >(&mut __map) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    },
                                );
                            }
                            __Field::__field2 => {
                                if _serde::__private::Option::is_some(&__field2) {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                            "account_data",
                                        ),
                                    );
                                }
                                __field2 = _serde::__private::Some(
                                    match _serde::de::MapAccess::next_value::<
                                        Vec<u8>,
                                    >(&mut __map) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    },
                                );
                            }
                            __Field::__field3 => {
                                if _serde::__private::Option::is_some(&__field3) {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                            "storage_proof",
                                        ),
                                    );
                                }
                                __field3 = _serde::__private::Some(
                                    match _serde::de::MapAccess::next_value::<
                                        Vec<Vec<u8>>,
                                    >(&mut __map) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    },
                                );
                            }
                            _ => {
                                let _ = match _serde::de::MapAccess::next_value::<
                                    _serde::de::IgnoredAny,
                                >(&mut __map) {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                };
                            }
                        }
                    }
                    let __field0 = match __field0 {
                        _serde::__private::Some(__field0) => __field0,
                        _serde::__private::None => {
                            match _serde::__private::de::missing_field("header_data") {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            }
                        }
                    };
                    let __field1 = match __field1 {
                        _serde::__private::Some(__field1) => __field1,
                        _serde::__private::None => {
                            match _serde::__private::de::missing_field("account_proof") {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            }
                        }
                    };
                    let __field2 = match __field2 {
                        _serde::__private::Some(__field2) => __field2,
                        _serde::__private::None => {
                            match _serde::__private::de::missing_field("account_data") {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            }
                        }
                    };
                    let __field3 = match __field3 {
                        _serde::__private::Some(__field3) => __field3,
                        _serde::__private::None => {
                            match _serde::__private::de::missing_field("storage_proof") {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            }
                        }
                    };
                    _serde::__private::Ok(UnlockProof {
                        header_data: __field0,
                        account_proof: __field1,
                        account_data: __field2,
                        storage_proof: __field3,
                    })
                }
            }
            #[doc(hidden)]
            const FIELDS: &'static [&'static str] = &[
                "header_data",
                "account_proof",
                "account_data",
                "storage_proof",
            ];
            _serde::Deserializer::deserialize_struct(
                __deserializer,
                "UnlockProof",
                FIELDS,
                __Visitor {
                    marker: _serde::__private::PhantomData::<UnlockProof>,
                    lifetime: _serde::__private::PhantomData,
                },
            )
        }
    }
};
#[automatically_derived]
impl ::core::marker::StructuralPartialEq for UnlockProof {}
#[automatically_derived]
impl ::core::cmp::PartialEq for UnlockProof {
    #[inline]
    fn eq(&self, other: &UnlockProof) -> bool {
        self.header_data == other.header_data
            && self.account_proof == other.account_proof
            && self.account_data == other.account_data
            && self.storage_proof == other.storage_proof
    }
}
#[serde(crate = "near_sdk::serde")]
pub struct UpdateBalance {
    sender_id: AccountId,
    token: AccountId,
    amount: U128,
}
#[doc(hidden)]
#[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
const _: () = {
    use near_sdk::serde as _serde;
    #[automatically_derived]
    impl near_sdk::serde::Serialize for UpdateBalance {
        fn serialize<__S>(
            &self,
            __serializer: __S,
        ) -> near_sdk::serde::__private::Result<__S::Ok, __S::Error>
        where
            __S: near_sdk::serde::Serializer,
        {
            let mut __serde_state = match _serde::Serializer::serialize_struct(
                __serializer,
                "UpdateBalance",
                false as usize + 1 + 1 + 1,
            ) {
                _serde::__private::Ok(__val) => __val,
                _serde::__private::Err(__err) => {
                    return _serde::__private::Err(__err);
                }
            };
            match _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "sender_id",
                &self.sender_id,
            ) {
                _serde::__private::Ok(__val) => __val,
                _serde::__private::Err(__err) => {
                    return _serde::__private::Err(__err);
                }
            };
            match _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "token",
                &self.token,
            ) {
                _serde::__private::Ok(__val) => __val,
                _serde::__private::Err(__err) => {
                    return _serde::__private::Err(__err);
                }
            };
            match _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "amount",
                &self.amount,
            ) {
                _serde::__private::Ok(__val) => __val,
                _serde::__private::Err(__err) => {
                    return _serde::__private::Err(__err);
                }
            };
            _serde::ser::SerializeStruct::end(__serde_state)
        }
    }
};
#[doc(hidden)]
#[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
const _: () = {
    use near_sdk::serde as _serde;
    #[automatically_derived]
    impl<'de> near_sdk::serde::Deserialize<'de> for UpdateBalance {
        fn deserialize<__D>(
            __deserializer: __D,
        ) -> near_sdk::serde::__private::Result<Self, __D::Error>
        where
            __D: near_sdk::serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            enum __Field {
                __field0,
                __field1,
                __field2,
                __ignore,
            }
            #[doc(hidden)]
            struct __FieldVisitor;
            impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                type Value = __Field;
                fn expecting(
                    &self,
                    __formatter: &mut _serde::__private::Formatter,
                ) -> _serde::__private::fmt::Result {
                    _serde::__private::Formatter::write_str(
                        __formatter,
                        "field identifier",
                    )
                }
                fn visit_u64<__E>(
                    self,
                    __value: u64,
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        0u64 => _serde::__private::Ok(__Field::__field0),
                        1u64 => _serde::__private::Ok(__Field::__field1),
                        2u64 => _serde::__private::Ok(__Field::__field2),
                        _ => _serde::__private::Ok(__Field::__ignore),
                    }
                }
                fn visit_str<__E>(
                    self,
                    __value: &str,
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        "sender_id" => _serde::__private::Ok(__Field::__field0),
                        "token" => _serde::__private::Ok(__Field::__field1),
                        "amount" => _serde::__private::Ok(__Field::__field2),
                        _ => _serde::__private::Ok(__Field::__ignore),
                    }
                }
                fn visit_bytes<__E>(
                    self,
                    __value: &[u8],
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        b"sender_id" => _serde::__private::Ok(__Field::__field0),
                        b"token" => _serde::__private::Ok(__Field::__field1),
                        b"amount" => _serde::__private::Ok(__Field::__field2),
                        _ => _serde::__private::Ok(__Field::__ignore),
                    }
                }
            }
            impl<'de> _serde::Deserialize<'de> for __Field {
                #[inline]
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    _serde::Deserializer::deserialize_identifier(
                        __deserializer,
                        __FieldVisitor,
                    )
                }
            }
            #[doc(hidden)]
            struct __Visitor<'de> {
                marker: _serde::__private::PhantomData<UpdateBalance>,
                lifetime: _serde::__private::PhantomData<&'de ()>,
            }
            impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                type Value = UpdateBalance;
                fn expecting(
                    &self,
                    __formatter: &mut _serde::__private::Formatter,
                ) -> _serde::__private::fmt::Result {
                    _serde::__private::Formatter::write_str(
                        __formatter,
                        "struct UpdateBalance",
                    )
                }
                #[inline]
                fn visit_seq<__A>(
                    self,
                    mut __seq: __A,
                ) -> _serde::__private::Result<Self::Value, __A::Error>
                where
                    __A: _serde::de::SeqAccess<'de>,
                {
                    let __field0 = match match _serde::de::SeqAccess::next_element::<
                        AccountId,
                    >(&mut __seq) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    } {
                        _serde::__private::Some(__value) => __value,
                        _serde::__private::None => {
                            return _serde::__private::Err(
                                _serde::de::Error::invalid_length(
                                    0usize,
                                    &"struct UpdateBalance with 3 elements",
                                ),
                            );
                        }
                    };
                    let __field1 = match match _serde::de::SeqAccess::next_element::<
                        AccountId,
                    >(&mut __seq) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    } {
                        _serde::__private::Some(__value) => __value,
                        _serde::__private::None => {
                            return _serde::__private::Err(
                                _serde::de::Error::invalid_length(
                                    1usize,
                                    &"struct UpdateBalance with 3 elements",
                                ),
                            );
                        }
                    };
                    let __field2 = match match _serde::de::SeqAccess::next_element::<
                        U128,
                    >(&mut __seq) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    } {
                        _serde::__private::Some(__value) => __value,
                        _serde::__private::None => {
                            return _serde::__private::Err(
                                _serde::de::Error::invalid_length(
                                    2usize,
                                    &"struct UpdateBalance with 3 elements",
                                ),
                            );
                        }
                    };
                    _serde::__private::Ok(UpdateBalance {
                        sender_id: __field0,
                        token: __field1,
                        amount: __field2,
                    })
                }
                #[inline]
                fn visit_map<__A>(
                    self,
                    mut __map: __A,
                ) -> _serde::__private::Result<Self::Value, __A::Error>
                where
                    __A: _serde::de::MapAccess<'de>,
                {
                    let mut __field0: _serde::__private::Option<AccountId> = _serde::__private::None;
                    let mut __field1: _serde::__private::Option<AccountId> = _serde::__private::None;
                    let mut __field2: _serde::__private::Option<U128> = _serde::__private::None;
                    while let _serde::__private::Some(__key) = match _serde::de::MapAccess::next_key::<
                        __Field,
                    >(&mut __map) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    } {
                        match __key {
                            __Field::__field0 => {
                                if _serde::__private::Option::is_some(&__field0) {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                            "sender_id",
                                        ),
                                    );
                                }
                                __field0 = _serde::__private::Some(
                                    match _serde::de::MapAccess::next_value::<
                                        AccountId,
                                    >(&mut __map) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    },
                                );
                            }
                            __Field::__field1 => {
                                if _serde::__private::Option::is_some(&__field1) {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field("token"),
                                    );
                                }
                                __field1 = _serde::__private::Some(
                                    match _serde::de::MapAccess::next_value::<
                                        AccountId,
                                    >(&mut __map) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    },
                                );
                            }
                            __Field::__field2 => {
                                if _serde::__private::Option::is_some(&__field2) {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field("amount"),
                                    );
                                }
                                __field2 = _serde::__private::Some(
                                    match _serde::de::MapAccess::next_value::<
                                        U128,
                                    >(&mut __map) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    },
                                );
                            }
                            _ => {
                                let _ = match _serde::de::MapAccess::next_value::<
                                    _serde::de::IgnoredAny,
                                >(&mut __map) {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                };
                            }
                        }
                    }
                    let __field0 = match __field0 {
                        _serde::__private::Some(__field0) => __field0,
                        _serde::__private::None => {
                            match _serde::__private::de::missing_field("sender_id") {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            }
                        }
                    };
                    let __field1 = match __field1 {
                        _serde::__private::Some(__field1) => __field1,
                        _serde::__private::None => {
                            match _serde::__private::de::missing_field("token") {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            }
                        }
                    };
                    let __field2 = match __field2 {
                        _serde::__private::Some(__field2) => __field2,
                        _serde::__private::None => {
                            match _serde::__private::de::missing_field("amount") {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            }
                        }
                    };
                    _serde::__private::Ok(UpdateBalance {
                        sender_id: __field0,
                        token: __field1,
                        amount: __field2,
                    })
                }
            }
            #[doc(hidden)]
            const FIELDS: &'static [&'static str] = &["sender_id", "token", "amount"];
            _serde::Deserializer::deserialize_struct(
                __deserializer,
                "UpdateBalance",
                FIELDS,
                __Visitor {
                    marker: _serde::__private::PhantomData::<UpdateBalance>,
                    lifetime: _serde::__private::PhantomData,
                },
            )
        }
    }
};
impl borsh::de::BorshDeserialize for UpdateBalance
where
    AccountId: borsh::BorshDeserialize,
    AccountId: borsh::BorshDeserialize,
    U128: borsh::BorshDeserialize,
{
    fn deserialize(
        buf: &mut &[u8],
    ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
        Ok(Self {
            sender_id: borsh::BorshDeserialize::deserialize(buf)?,
            token: borsh::BorshDeserialize::deserialize(buf)?,
            amount: borsh::BorshDeserialize::deserialize(buf)?,
        })
    }
}
impl borsh::ser::BorshSerialize for UpdateBalance
where
    AccountId: borsh::ser::BorshSerialize,
    AccountId: borsh::ser::BorshSerialize,
    U128: borsh::ser::BorshSerialize,
{
    fn serialize<W: borsh::maybestd::io::Write>(
        &self,
        writer: &mut W,
    ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
        borsh::BorshSerialize::serialize(&self.sender_id, writer)?;
        borsh::BorshSerialize::serialize(&self.token, writer)?;
        borsh::BorshSerialize::serialize(&self.amount, writer)?;
        Ok(())
    }
}
#[automatically_derived]
impl ::core::fmt::Debug for UpdateBalance {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        ::core::fmt::Formatter::debug_struct_field3_finish(
            f,
            "UpdateBalance",
            "sender_id",
            &self.sender_id,
            "token",
            &self.token,
            "amount",
            &&self.amount,
        )
    }
}
#[automatically_derived]
impl ::core::clone::Clone for UpdateBalance {
    #[inline]
    fn clone(&self) -> UpdateBalance {
        UpdateBalance {
            sender_id: ::core::clone::Clone::clone(&self.sender_id),
            token: ::core::clone::Clone::clone(&self.token),
            amount: ::core::clone::Clone::clone(&self.amount),
        }
    }
}
enum StorageKey {
    PendingTransfers,
    TokenBalances,
    TokenBalancePrefix,
    WhitelistTokens,
    WhitelistAccounts,
    PendingTransfersBalances,
}
impl borsh::ser::BorshSerialize for StorageKey {
    fn serialize<W: borsh::maybestd::io::Write>(
        &self,
        writer: &mut W,
    ) -> core::result::Result<(), borsh::maybestd::io::Error> {
        let variant_idx: u8 = match self {
            StorageKey::PendingTransfers => 0u8,
            StorageKey::TokenBalances => 1u8,
            StorageKey::TokenBalancePrefix => 2u8,
            StorageKey::WhitelistTokens => 3u8,
            StorageKey::WhitelistAccounts => 4u8,
            StorageKey::PendingTransfersBalances => 5u8,
        };
        writer.write_all(&variant_idx.to_le_bytes())?;
        match self {
            StorageKey::PendingTransfers => {}
            StorageKey::TokenBalances => {}
            StorageKey::TokenBalancePrefix => {}
            StorageKey::WhitelistTokens => {}
            StorageKey::WhitelistAccounts => {}
            StorageKey::PendingTransfersBalances => {}
        }
        Ok(())
    }
}
impl near_sdk::__private::BorshIntoStorageKey for StorageKey
where
    StorageKey: ::near_sdk::borsh::BorshSerialize,
{}
#[serde(crate = "near_sdk::serde")]
pub struct LockDuration {
    lock_time_min: Duration,
    lock_time_max: Duration,
}
#[doc(hidden)]
#[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
const _: () = {
    use near_sdk::serde as _serde;
    #[automatically_derived]
    impl near_sdk::serde::Serialize for LockDuration {
        fn serialize<__S>(
            &self,
            __serializer: __S,
        ) -> near_sdk::serde::__private::Result<__S::Ok, __S::Error>
        where
            __S: near_sdk::serde::Serializer,
        {
            let mut __serde_state = match _serde::Serializer::serialize_struct(
                __serializer,
                "LockDuration",
                false as usize + 1 + 1,
            ) {
                _serde::__private::Ok(__val) => __val,
                _serde::__private::Err(__err) => {
                    return _serde::__private::Err(__err);
                }
            };
            match _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "lock_time_min",
                &self.lock_time_min,
            ) {
                _serde::__private::Ok(__val) => __val,
                _serde::__private::Err(__err) => {
                    return _serde::__private::Err(__err);
                }
            };
            match _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "lock_time_max",
                &self.lock_time_max,
            ) {
                _serde::__private::Ok(__val) => __val,
                _serde::__private::Err(__err) => {
                    return _serde::__private::Err(__err);
                }
            };
            _serde::ser::SerializeStruct::end(__serde_state)
        }
    }
};
#[doc(hidden)]
#[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
const _: () = {
    use near_sdk::serde as _serde;
    #[automatically_derived]
    impl<'de> near_sdk::serde::Deserialize<'de> for LockDuration {
        fn deserialize<__D>(
            __deserializer: __D,
        ) -> near_sdk::serde::__private::Result<Self, __D::Error>
        where
            __D: near_sdk::serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            enum __Field {
                __field0,
                __field1,
                __ignore,
            }
            #[doc(hidden)]
            struct __FieldVisitor;
            impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                type Value = __Field;
                fn expecting(
                    &self,
                    __formatter: &mut _serde::__private::Formatter,
                ) -> _serde::__private::fmt::Result {
                    _serde::__private::Formatter::write_str(
                        __formatter,
                        "field identifier",
                    )
                }
                fn visit_u64<__E>(
                    self,
                    __value: u64,
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        0u64 => _serde::__private::Ok(__Field::__field0),
                        1u64 => _serde::__private::Ok(__Field::__field1),
                        _ => _serde::__private::Ok(__Field::__ignore),
                    }
                }
                fn visit_str<__E>(
                    self,
                    __value: &str,
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        "lock_time_min" => _serde::__private::Ok(__Field::__field0),
                        "lock_time_max" => _serde::__private::Ok(__Field::__field1),
                        _ => _serde::__private::Ok(__Field::__ignore),
                    }
                }
                fn visit_bytes<__E>(
                    self,
                    __value: &[u8],
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        b"lock_time_min" => _serde::__private::Ok(__Field::__field0),
                        b"lock_time_max" => _serde::__private::Ok(__Field::__field1),
                        _ => _serde::__private::Ok(__Field::__ignore),
                    }
                }
            }
            impl<'de> _serde::Deserialize<'de> for __Field {
                #[inline]
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    _serde::Deserializer::deserialize_identifier(
                        __deserializer,
                        __FieldVisitor,
                    )
                }
            }
            #[doc(hidden)]
            struct __Visitor<'de> {
                marker: _serde::__private::PhantomData<LockDuration>,
                lifetime: _serde::__private::PhantomData<&'de ()>,
            }
            impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                type Value = LockDuration;
                fn expecting(
                    &self,
                    __formatter: &mut _serde::__private::Formatter,
                ) -> _serde::__private::fmt::Result {
                    _serde::__private::Formatter::write_str(
                        __formatter,
                        "struct LockDuration",
                    )
                }
                #[inline]
                fn visit_seq<__A>(
                    self,
                    mut __seq: __A,
                ) -> _serde::__private::Result<Self::Value, __A::Error>
                where
                    __A: _serde::de::SeqAccess<'de>,
                {
                    let __field0 = match match _serde::de::SeqAccess::next_element::<
                        Duration,
                    >(&mut __seq) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    } {
                        _serde::__private::Some(__value) => __value,
                        _serde::__private::None => {
                            return _serde::__private::Err(
                                _serde::de::Error::invalid_length(
                                    0usize,
                                    &"struct LockDuration with 2 elements",
                                ),
                            );
                        }
                    };
                    let __field1 = match match _serde::de::SeqAccess::next_element::<
                        Duration,
                    >(&mut __seq) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    } {
                        _serde::__private::Some(__value) => __value,
                        _serde::__private::None => {
                            return _serde::__private::Err(
                                _serde::de::Error::invalid_length(
                                    1usize,
                                    &"struct LockDuration with 2 elements",
                                ),
                            );
                        }
                    };
                    _serde::__private::Ok(LockDuration {
                        lock_time_min: __field0,
                        lock_time_max: __field1,
                    })
                }
                #[inline]
                fn visit_map<__A>(
                    self,
                    mut __map: __A,
                ) -> _serde::__private::Result<Self::Value, __A::Error>
                where
                    __A: _serde::de::MapAccess<'de>,
                {
                    let mut __field0: _serde::__private::Option<Duration> = _serde::__private::None;
                    let mut __field1: _serde::__private::Option<Duration> = _serde::__private::None;
                    while let _serde::__private::Some(__key) = match _serde::de::MapAccess::next_key::<
                        __Field,
                    >(&mut __map) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    } {
                        match __key {
                            __Field::__field0 => {
                                if _serde::__private::Option::is_some(&__field0) {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                            "lock_time_min",
                                        ),
                                    );
                                }
                                __field0 = _serde::__private::Some(
                                    match _serde::de::MapAccess::next_value::<
                                        Duration,
                                    >(&mut __map) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    },
                                );
                            }
                            __Field::__field1 => {
                                if _serde::__private::Option::is_some(&__field1) {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                            "lock_time_max",
                                        ),
                                    );
                                }
                                __field1 = _serde::__private::Some(
                                    match _serde::de::MapAccess::next_value::<
                                        Duration,
                                    >(&mut __map) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    },
                                );
                            }
                            _ => {
                                let _ = match _serde::de::MapAccess::next_value::<
                                    _serde::de::IgnoredAny,
                                >(&mut __map) {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                };
                            }
                        }
                    }
                    let __field0 = match __field0 {
                        _serde::__private::Some(__field0) => __field0,
                        _serde::__private::None => {
                            match _serde::__private::de::missing_field("lock_time_min") {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            }
                        }
                    };
                    let __field1 = match __field1 {
                        _serde::__private::Some(__field1) => __field1,
                        _serde::__private::None => {
                            match _serde::__private::de::missing_field("lock_time_max") {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            }
                        }
                    };
                    _serde::__private::Ok(LockDuration {
                        lock_time_min: __field0,
                        lock_time_max: __field1,
                    })
                }
            }
            #[doc(hidden)]
            const FIELDS: &'static [&'static str] = &["lock_time_min", "lock_time_max"];
            _serde::Deserializer::deserialize_struct(
                __deserializer,
                "LockDuration",
                FIELDS,
                __Visitor {
                    marker: _serde::__private::PhantomData::<LockDuration>,
                    lifetime: _serde::__private::PhantomData,
                },
            )
        }
    }
};
impl borsh::de::BorshDeserialize for LockDuration
where
    Duration: borsh::BorshDeserialize,
    Duration: borsh::BorshDeserialize,
{
    fn deserialize(
        buf: &mut &[u8],
    ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
        Ok(Self {
            lock_time_min: borsh::BorshDeserialize::deserialize(buf)?,
            lock_time_max: borsh::BorshDeserialize::deserialize(buf)?,
        })
    }
}
impl borsh::ser::BorshSerialize for LockDuration
where
    Duration: borsh::ser::BorshSerialize,
    Duration: borsh::ser::BorshSerialize,
{
    fn serialize<W: borsh::maybestd::io::Write>(
        &self,
        writer: &mut W,
    ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
        borsh::BorshSerialize::serialize(&self.lock_time_min, writer)?;
        borsh::BorshSerialize::serialize(&self.lock_time_max, writer)?;
        Ok(())
    }
}
#[automatically_derived]
impl ::core::fmt::Debug for LockDuration {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        ::core::fmt::Formatter::debug_struct_field2_finish(
            f,
            "LockDuration",
            "lock_time_min",
            &self.lock_time_min,
            "lock_time_max",
            &&self.lock_time_max,
        )
    }
}
#[automatically_derived]
impl ::core::clone::Clone for LockDuration {
    #[inline]
    fn clone(&self) -> LockDuration {
        LockDuration {
            lock_time_min: ::core::clone::Clone::clone(&self.lock_time_min),
            lock_time_max: ::core::clone::Clone::clone(&self.lock_time_max),
        }
    }
}
#[serde(crate = "near_sdk::serde")]
pub enum Role {
    /// May pause and unpause features.
    PauseManager,
    /// May call `unlock` even when it is paused.
    UnrestrictedUnlock,
    /// May call `lp_unlock` even when it is paused.
    UnrestrictedLpUnlock,
    /// May call `withdraw` even when it is paused.
    UnrestrictedWithdraw,
    WhitelistManager,
    ConfigManager,
    UnlockManager,
    DAO,
    CodeStager,
    CodeDeployer,
    DurationManager,
}
struct __AclBoundchecker<T: Copy + Clone> {
    _marker: ::std::marker::PhantomData<T>,
}
impl<T: Copy + Clone> __AclBoundchecker<T> {
    fn new() -> Self {
        Self {
            _marker: Default::default(),
        }
    }
}
impl Role {
    fn check_bounds() {
        let _x = __AclBoundchecker::<Role>::new();
    }
}
impl From<Role> for u8 {
    fn from(value: Role) -> Self {
        match value {
            Role::PauseManager => 0u8,
            Role::UnrestrictedUnlock => 1u8,
            Role::UnrestrictedLpUnlock => 2u8,
            Role::UnrestrictedWithdraw => 3u8,
            Role::WhitelistManager => 4u8,
            Role::ConfigManager => 5u8,
            Role::UnlockManager => 6u8,
            Role::DAO => 7u8,
            Role::CodeStager => 8u8,
            Role::CodeDeployer => 9u8,
            Role::DurationManager => 10u8,
        }
    }
}
impl ::std::convert::TryFrom<u8> for Role {
    type Error = &'static str;
    fn try_from(value: u8) -> Result<Self, Self::Error> {
        match value {
            0u8 => Ok(Role::PauseManager),
            1u8 => Ok(Role::UnrestrictedUnlock),
            2u8 => Ok(Role::UnrestrictedLpUnlock),
            3u8 => Ok(Role::UnrestrictedWithdraw),
            4u8 => Ok(Role::WhitelistManager),
            5u8 => Ok(Role::ConfigManager),
            6u8 => Ok(Role::UnlockManager),
            7u8 => Ok(Role::DAO),
            8u8 => Ok(Role::CodeStager),
            9u8 => Ok(Role::CodeDeployer),
            10u8 => Ok(Role::DurationManager),
            _ => Err("Value does not correspond to a variant"),
        }
    }
}
impl From<Role> for &'static str {
    fn from(value: Role) -> Self {
        match value {
            Role::PauseManager => "PauseManager",
            Role::UnrestrictedUnlock => "UnrestrictedUnlock",
            Role::UnrestrictedLpUnlock => "UnrestrictedLpUnlock",
            Role::UnrestrictedWithdraw => "UnrestrictedWithdraw",
            Role::WhitelistManager => "WhitelistManager",
            Role::ConfigManager => "ConfigManager",
            Role::UnlockManager => "UnlockManager",
            Role::DAO => "DAO",
            Role::CodeStager => "CodeStager",
            Role::CodeDeployer => "CodeDeployer",
            Role::DurationManager => "DurationManager",
        }
    }
}
impl From<Role> for String {
    fn from(value: Role) -> Self {
        match value {
            Role::PauseManager => "PauseManager".to_string(),
            Role::UnrestrictedUnlock => "UnrestrictedUnlock".to_string(),
            Role::UnrestrictedLpUnlock => "UnrestrictedLpUnlock".to_string(),
            Role::UnrestrictedWithdraw => "UnrestrictedWithdraw".to_string(),
            Role::WhitelistManager => "WhitelistManager".to_string(),
            Role::ConfigManager => "ConfigManager".to_string(),
            Role::UnlockManager => "UnlockManager".to_string(),
            Role::DAO => "DAO".to_string(),
            Role::CodeStager => "CodeStager".to_string(),
            Role::CodeDeployer => "CodeDeployer".to_string(),
            Role::DurationManager => "DurationManager".to_string(),
        }
    }
}
impl ::std::convert::TryFrom<&str> for Role {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Role, Self::Error> {
        match value {
            "PauseManager" => Ok(Role::PauseManager),
            "UnrestrictedUnlock" => Ok(Role::UnrestrictedUnlock),
            "UnrestrictedLpUnlock" => Ok(Role::UnrestrictedLpUnlock),
            "UnrestrictedWithdraw" => Ok(Role::UnrestrictedWithdraw),
            "WhitelistManager" => Ok(Role::WhitelistManager),
            "ConfigManager" => Ok(Role::ConfigManager),
            "UnlockManager" => Ok(Role::UnlockManager),
            "DAO" => Ok(Role::DAO),
            "CodeStager" => Ok(Role::CodeStager),
            "CodeDeployer" => Ok(Role::CodeDeployer),
            "DurationManager" => Ok(Role::DurationManager),
            _ => Err("Value does not correspond to a variant"),
        }
    }
}
/// Panics if `n` is too large.
fn safe_leftshift(value: u128, n: u8) -> u128 {
    value
        .checked_shl(n.into())
        .unwrap_or_else(|| ::near_sdk::env::panic_str(
            "Too many enum variants to be represented by bitflags",
        ))
}
impl AccessControlRole for Role {
    fn acl_role_variants() -> Vec<&'static str> {
        <[_]>::into_vec(
            #[rustc_box]
            ::alloc::boxed::Box::new([
                "PauseManager",
                "UnrestrictedUnlock",
                "UnrestrictedLpUnlock",
                "UnrestrictedWithdraw",
                "WhitelistManager",
                "ConfigManager",
                "UnlockManager",
                "DAO",
                "CodeStager",
                "CodeDeployer",
                "DurationManager",
            ]),
        )
    }
    fn acl_super_admin_permission() -> u128 {
        1
    }
    fn acl_permission(self) -> u128 {
        let n = (u8::from(self) + 1)
            .checked_mul(2)
            .unwrap_or_else(|| ::near_sdk::env::panic_str("Too many enum variants")) - 1;
        safe_leftshift(1, n)
    }
    fn acl_admin_permission(self) -> u128 {
        let n = (u8::from(self) + 1)
            .checked_mul(2)
            .unwrap_or_else(|| ::near_sdk::env::panic_str("Too many enum variants"));
        safe_leftshift(1, n)
    }
}
/// Encodes permissions for roles and admins.
struct RoleFlags {
    bits: u128,
}
#[automatically_derived]
impl ::core::marker::Copy for RoleFlags {}
#[automatically_derived]
impl ::core::marker::StructuralPartialEq for RoleFlags {}
#[automatically_derived]
impl ::core::cmp::PartialEq for RoleFlags {
    #[inline]
    fn eq(&self, other: &RoleFlags) -> bool {
        self.bits == other.bits
    }
}
#[automatically_derived]
impl ::core::marker::StructuralEq for RoleFlags {}
#[automatically_derived]
impl ::core::cmp::Eq for RoleFlags {
    #[inline]
    #[doc(hidden)]
    #[no_coverage]
    fn assert_receiver_is_total_eq(&self) -> () {
        let _: ::core::cmp::AssertParamIsEq<u128>;
    }
}
#[automatically_derived]
impl ::core::clone::Clone for RoleFlags {
    #[inline]
    fn clone(&self) -> RoleFlags {
        let _: ::core::clone::AssertParamIsClone<u128>;
        *self
    }
}
#[automatically_derived]
impl ::core::cmp::PartialOrd for RoleFlags {
    #[inline]
    fn partial_cmp(
        &self,
        other: &RoleFlags,
    ) -> ::core::option::Option<::core::cmp::Ordering> {
        ::core::cmp::PartialOrd::partial_cmp(&self.bits, &other.bits)
    }
}
#[automatically_derived]
impl ::core::cmp::Ord for RoleFlags {
    #[inline]
    fn cmp(&self, other: &RoleFlags) -> ::core::cmp::Ordering {
        ::core::cmp::Ord::cmp(&self.bits, &other.bits)
    }
}
#[automatically_derived]
impl ::core::hash::Hash for RoleFlags {
    fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
        ::core::hash::Hash::hash(&self.bits, state)
    }
}
impl borsh::de::BorshDeserialize for RoleFlags
where
    u128: borsh::BorshDeserialize,
{
    fn deserialize(
        buf: &mut &[u8],
    ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
        Ok(Self {
            bits: borsh::BorshDeserialize::deserialize(buf)?,
        })
    }
}
impl borsh::ser::BorshSerialize for RoleFlags
where
    u128: borsh::ser::BorshSerialize,
{
    fn serialize<W: borsh::maybestd::io::Write>(
        &self,
        writer: &mut W,
    ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
        borsh::BorshSerialize::serialize(&self.bits, writer)?;
        Ok(())
    }
}
#[automatically_derived]
impl ::core::default::Default for RoleFlags {
    #[inline]
    fn default() -> RoleFlags {
        RoleFlags {
            bits: ::core::default::Default::default(),
        }
    }
}
impl ::bitflags::_core::fmt::Debug for RoleFlags {
    fn fmt(
        &self,
        f: &mut ::bitflags::_core::fmt::Formatter,
    ) -> ::bitflags::_core::fmt::Result {
        #[allow(non_snake_case)]
        trait __BitFlags {
            #[inline]
            fn __SUPER_ADMIN(&self) -> bool {
                false
            }
            #[inline]
            fn PAUSEMANAGER(&self) -> bool {
                false
            }
            #[inline]
            fn PAUSEMANAGER_ADMIN(&self) -> bool {
                false
            }
            #[inline]
            fn UNRESTRICTEDUNLOCK(&self) -> bool {
                false
            }
            #[inline]
            fn UNRESTRICTEDUNLOCK_ADMIN(&self) -> bool {
                false
            }
            #[inline]
            fn UNRESTRICTEDLPUNLOCK(&self) -> bool {
                false
            }
            #[inline]
            fn UNRESTRICTEDLPUNLOCK_ADMIN(&self) -> bool {
                false
            }
            #[inline]
            fn UNRESTRICTEDWITHDRAW(&self) -> bool {
                false
            }
            #[inline]
            fn UNRESTRICTEDWITHDRAW_ADMIN(&self) -> bool {
                false
            }
            #[inline]
            fn WHITELISTMANAGER(&self) -> bool {
                false
            }
            #[inline]
            fn WHITELISTMANAGER_ADMIN(&self) -> bool {
                false
            }
            #[inline]
            fn CONFIGMANAGER(&self) -> bool {
                false
            }
            #[inline]
            fn CONFIGMANAGER_ADMIN(&self) -> bool {
                false
            }
            #[inline]
            fn UNLOCKMANAGER(&self) -> bool {
                false
            }
            #[inline]
            fn UNLOCKMANAGER_ADMIN(&self) -> bool {
                false
            }
            #[inline]
            fn DAO(&self) -> bool {
                false
            }
            #[inline]
            fn DAO_ADMIN(&self) -> bool {
                false
            }
            #[inline]
            fn CODESTAGER(&self) -> bool {
                false
            }
            #[inline]
            fn CODESTAGER_ADMIN(&self) -> bool {
                false
            }
            #[inline]
            fn CODEDEPLOYER(&self) -> bool {
                false
            }
            #[inline]
            fn CODEDEPLOYER_ADMIN(&self) -> bool {
                false
            }
            #[inline]
            fn DURATIONMANAGER(&self) -> bool {
                false
            }
            #[inline]
            fn DURATIONMANAGER_ADMIN(&self) -> bool {
                false
            }
        }
        #[allow(non_snake_case)]
        impl __BitFlags for RoleFlags {
            #[allow(deprecated)]
            #[inline]
            fn __SUPER_ADMIN(&self) -> bool {
                if Self::__SUPER_ADMIN.bits == 0 && self.bits != 0 {
                    false
                } else {
                    self.bits & Self::__SUPER_ADMIN.bits == Self::__SUPER_ADMIN.bits
                }
            }
            #[allow(deprecated)]
            #[inline]
            fn PAUSEMANAGER(&self) -> bool {
                if Self::PAUSEMANAGER.bits == 0 && self.bits != 0 {
                    false
                } else {
                    self.bits & Self::PAUSEMANAGER.bits == Self::PAUSEMANAGER.bits
                }
            }
            #[allow(deprecated)]
            #[inline]
            fn PAUSEMANAGER_ADMIN(&self) -> bool {
                if Self::PAUSEMANAGER_ADMIN.bits == 0 && self.bits != 0 {
                    false
                } else {
                    self.bits & Self::PAUSEMANAGER_ADMIN.bits
                        == Self::PAUSEMANAGER_ADMIN.bits
                }
            }
            #[allow(deprecated)]
            #[inline]
            fn UNRESTRICTEDUNLOCK(&self) -> bool {
                if Self::UNRESTRICTEDUNLOCK.bits == 0 && self.bits != 0 {
                    false
                } else {
                    self.bits & Self::UNRESTRICTEDUNLOCK.bits
                        == Self::UNRESTRICTEDUNLOCK.bits
                }
            }
            #[allow(deprecated)]
            #[inline]
            fn UNRESTRICTEDUNLOCK_ADMIN(&self) -> bool {
                if Self::UNRESTRICTEDUNLOCK_ADMIN.bits == 0 && self.bits != 0 {
                    false
                } else {
                    self.bits & Self::UNRESTRICTEDUNLOCK_ADMIN.bits
                        == Self::UNRESTRICTEDUNLOCK_ADMIN.bits
                }
            }
            #[allow(deprecated)]
            #[inline]
            fn UNRESTRICTEDLPUNLOCK(&self) -> bool {
                if Self::UNRESTRICTEDLPUNLOCK.bits == 0 && self.bits != 0 {
                    false
                } else {
                    self.bits & Self::UNRESTRICTEDLPUNLOCK.bits
                        == Self::UNRESTRICTEDLPUNLOCK.bits
                }
            }
            #[allow(deprecated)]
            #[inline]
            fn UNRESTRICTEDLPUNLOCK_ADMIN(&self) -> bool {
                if Self::UNRESTRICTEDLPUNLOCK_ADMIN.bits == 0 && self.bits != 0 {
                    false
                } else {
                    self.bits & Self::UNRESTRICTEDLPUNLOCK_ADMIN.bits
                        == Self::UNRESTRICTEDLPUNLOCK_ADMIN.bits
                }
            }
            #[allow(deprecated)]
            #[inline]
            fn UNRESTRICTEDWITHDRAW(&self) -> bool {
                if Self::UNRESTRICTEDWITHDRAW.bits == 0 && self.bits != 0 {
                    false
                } else {
                    self.bits & Self::UNRESTRICTEDWITHDRAW.bits
                        == Self::UNRESTRICTEDWITHDRAW.bits
                }
            }
            #[allow(deprecated)]
            #[inline]
            fn UNRESTRICTEDWITHDRAW_ADMIN(&self) -> bool {
                if Self::UNRESTRICTEDWITHDRAW_ADMIN.bits == 0 && self.bits != 0 {
                    false
                } else {
                    self.bits & Self::UNRESTRICTEDWITHDRAW_ADMIN.bits
                        == Self::UNRESTRICTEDWITHDRAW_ADMIN.bits
                }
            }
            #[allow(deprecated)]
            #[inline]
            fn WHITELISTMANAGER(&self) -> bool {
                if Self::WHITELISTMANAGER.bits == 0 && self.bits != 0 {
                    false
                } else {
                    self.bits & Self::WHITELISTMANAGER.bits
                        == Self::WHITELISTMANAGER.bits
                }
            }
            #[allow(deprecated)]
            #[inline]
            fn WHITELISTMANAGER_ADMIN(&self) -> bool {
                if Self::WHITELISTMANAGER_ADMIN.bits == 0 && self.bits != 0 {
                    false
                } else {
                    self.bits & Self::WHITELISTMANAGER_ADMIN.bits
                        == Self::WHITELISTMANAGER_ADMIN.bits
                }
            }
            #[allow(deprecated)]
            #[inline]
            fn CONFIGMANAGER(&self) -> bool {
                if Self::CONFIGMANAGER.bits == 0 && self.bits != 0 {
                    false
                } else {
                    self.bits & Self::CONFIGMANAGER.bits == Self::CONFIGMANAGER.bits
                }
            }
            #[allow(deprecated)]
            #[inline]
            fn CONFIGMANAGER_ADMIN(&self) -> bool {
                if Self::CONFIGMANAGER_ADMIN.bits == 0 && self.bits != 0 {
                    false
                } else {
                    self.bits & Self::CONFIGMANAGER_ADMIN.bits
                        == Self::CONFIGMANAGER_ADMIN.bits
                }
            }
            #[allow(deprecated)]
            #[inline]
            fn UNLOCKMANAGER(&self) -> bool {
                if Self::UNLOCKMANAGER.bits == 0 && self.bits != 0 {
                    false
                } else {
                    self.bits & Self::UNLOCKMANAGER.bits == Self::UNLOCKMANAGER.bits
                }
            }
            #[allow(deprecated)]
            #[inline]
            fn UNLOCKMANAGER_ADMIN(&self) -> bool {
                if Self::UNLOCKMANAGER_ADMIN.bits == 0 && self.bits != 0 {
                    false
                } else {
                    self.bits & Self::UNLOCKMANAGER_ADMIN.bits
                        == Self::UNLOCKMANAGER_ADMIN.bits
                }
            }
            #[allow(deprecated)]
            #[inline]
            fn DAO(&self) -> bool {
                if Self::DAO.bits == 0 && self.bits != 0 {
                    false
                } else {
                    self.bits & Self::DAO.bits == Self::DAO.bits
                }
            }
            #[allow(deprecated)]
            #[inline]
            fn DAO_ADMIN(&self) -> bool {
                if Self::DAO_ADMIN.bits == 0 && self.bits != 0 {
                    false
                } else {
                    self.bits & Self::DAO_ADMIN.bits == Self::DAO_ADMIN.bits
                }
            }
            #[allow(deprecated)]
            #[inline]
            fn CODESTAGER(&self) -> bool {
                if Self::CODESTAGER.bits == 0 && self.bits != 0 {
                    false
                } else {
                    self.bits & Self::CODESTAGER.bits == Self::CODESTAGER.bits
                }
            }
            #[allow(deprecated)]
            #[inline]
            fn CODESTAGER_ADMIN(&self) -> bool {
                if Self::CODESTAGER_ADMIN.bits == 0 && self.bits != 0 {
                    false
                } else {
                    self.bits & Self::CODESTAGER_ADMIN.bits
                        == Self::CODESTAGER_ADMIN.bits
                }
            }
            #[allow(deprecated)]
            #[inline]
            fn CODEDEPLOYER(&self) -> bool {
                if Self::CODEDEPLOYER.bits == 0 && self.bits != 0 {
                    false
                } else {
                    self.bits & Self::CODEDEPLOYER.bits == Self::CODEDEPLOYER.bits
                }
            }
            #[allow(deprecated)]
            #[inline]
            fn CODEDEPLOYER_ADMIN(&self) -> bool {
                if Self::CODEDEPLOYER_ADMIN.bits == 0 && self.bits != 0 {
                    false
                } else {
                    self.bits & Self::CODEDEPLOYER_ADMIN.bits
                        == Self::CODEDEPLOYER_ADMIN.bits
                }
            }
            #[allow(deprecated)]
            #[inline]
            fn DURATIONMANAGER(&self) -> bool {
                if Self::DURATIONMANAGER.bits == 0 && self.bits != 0 {
                    false
                } else {
                    self.bits & Self::DURATIONMANAGER.bits == Self::DURATIONMANAGER.bits
                }
            }
            #[allow(deprecated)]
            #[inline]
            fn DURATIONMANAGER_ADMIN(&self) -> bool {
                if Self::DURATIONMANAGER_ADMIN.bits == 0 && self.bits != 0 {
                    false
                } else {
                    self.bits & Self::DURATIONMANAGER_ADMIN.bits
                        == Self::DURATIONMANAGER_ADMIN.bits
                }
            }
        }
        let mut first = true;
        if <Self as __BitFlags>::__SUPER_ADMIN(self) {
            if !first {
                f.write_str(" | ")?;
            }
            first = false;
            f.write_str("__SUPER_ADMIN")?;
        }
        if <Self as __BitFlags>::PAUSEMANAGER(self) {
            if !first {
                f.write_str(" | ")?;
            }
            first = false;
            f.write_str("PAUSEMANAGER")?;
        }
        if <Self as __BitFlags>::PAUSEMANAGER_ADMIN(self) {
            if !first {
                f.write_str(" | ")?;
            }
            first = false;
            f.write_str("PAUSEMANAGER_ADMIN")?;
        }
        if <Self as __BitFlags>::UNRESTRICTEDUNLOCK(self) {
            if !first {
                f.write_str(" | ")?;
            }
            first = false;
            f.write_str("UNRESTRICTEDUNLOCK")?;
        }
        if <Self as __BitFlags>::UNRESTRICTEDUNLOCK_ADMIN(self) {
            if !first {
                f.write_str(" | ")?;
            }
            first = false;
            f.write_str("UNRESTRICTEDUNLOCK_ADMIN")?;
        }
        if <Self as __BitFlags>::UNRESTRICTEDLPUNLOCK(self) {
            if !first {
                f.write_str(" | ")?;
            }
            first = false;
            f.write_str("UNRESTRICTEDLPUNLOCK")?;
        }
        if <Self as __BitFlags>::UNRESTRICTEDLPUNLOCK_ADMIN(self) {
            if !first {
                f.write_str(" | ")?;
            }
            first = false;
            f.write_str("UNRESTRICTEDLPUNLOCK_ADMIN")?;
        }
        if <Self as __BitFlags>::UNRESTRICTEDWITHDRAW(self) {
            if !first {
                f.write_str(" | ")?;
            }
            first = false;
            f.write_str("UNRESTRICTEDWITHDRAW")?;
        }
        if <Self as __BitFlags>::UNRESTRICTEDWITHDRAW_ADMIN(self) {
            if !first {
                f.write_str(" | ")?;
            }
            first = false;
            f.write_str("UNRESTRICTEDWITHDRAW_ADMIN")?;
        }
        if <Self as __BitFlags>::WHITELISTMANAGER(self) {
            if !first {
                f.write_str(" | ")?;
            }
            first = false;
            f.write_str("WHITELISTMANAGER")?;
        }
        if <Self as __BitFlags>::WHITELISTMANAGER_ADMIN(self) {
            if !first {
                f.write_str(" | ")?;
            }
            first = false;
            f.write_str("WHITELISTMANAGER_ADMIN")?;
        }
        if <Self as __BitFlags>::CONFIGMANAGER(self) {
            if !first {
                f.write_str(" | ")?;
            }
            first = false;
            f.write_str("CONFIGMANAGER")?;
        }
        if <Self as __BitFlags>::CONFIGMANAGER_ADMIN(self) {
            if !first {
                f.write_str(" | ")?;
            }
            first = false;
            f.write_str("CONFIGMANAGER_ADMIN")?;
        }
        if <Self as __BitFlags>::UNLOCKMANAGER(self) {
            if !first {
                f.write_str(" | ")?;
            }
            first = false;
            f.write_str("UNLOCKMANAGER")?;
        }
        if <Self as __BitFlags>::UNLOCKMANAGER_ADMIN(self) {
            if !first {
                f.write_str(" | ")?;
            }
            first = false;
            f.write_str("UNLOCKMANAGER_ADMIN")?;
        }
        if <Self as __BitFlags>::DAO(self) {
            if !first {
                f.write_str(" | ")?;
            }
            first = false;
            f.write_str("DAO")?;
        }
        if <Self as __BitFlags>::DAO_ADMIN(self) {
            if !first {
                f.write_str(" | ")?;
            }
            first = false;
            f.write_str("DAO_ADMIN")?;
        }
        if <Self as __BitFlags>::CODESTAGER(self) {
            if !first {
                f.write_str(" | ")?;
            }
            first = false;
            f.write_str("CODESTAGER")?;
        }
        if <Self as __BitFlags>::CODESTAGER_ADMIN(self) {
            if !first {
                f.write_str(" | ")?;
            }
            first = false;
            f.write_str("CODESTAGER_ADMIN")?;
        }
        if <Self as __BitFlags>::CODEDEPLOYER(self) {
            if !first {
                f.write_str(" | ")?;
            }
            first = false;
            f.write_str("CODEDEPLOYER")?;
        }
        if <Self as __BitFlags>::CODEDEPLOYER_ADMIN(self) {
            if !first {
                f.write_str(" | ")?;
            }
            first = false;
            f.write_str("CODEDEPLOYER_ADMIN")?;
        }
        if <Self as __BitFlags>::DURATIONMANAGER(self) {
            if !first {
                f.write_str(" | ")?;
            }
            first = false;
            f.write_str("DURATIONMANAGER")?;
        }
        if <Self as __BitFlags>::DURATIONMANAGER_ADMIN(self) {
            if !first {
                f.write_str(" | ")?;
            }
            first = false;
            f.write_str("DURATIONMANAGER_ADMIN")?;
        }
        let extra_bits = self.bits & !Self::all().bits();
        if extra_bits != 0 {
            if !first {
                f.write_str(" | ")?;
            }
            first = false;
            f.write_str("0x")?;
            ::bitflags::_core::fmt::LowerHex::fmt(&extra_bits, f)?;
        }
        if first {
            f.write_str("(empty)")?;
        }
        Ok(())
    }
}
impl ::bitflags::_core::fmt::Binary for RoleFlags {
    fn fmt(
        &self,
        f: &mut ::bitflags::_core::fmt::Formatter,
    ) -> ::bitflags::_core::fmt::Result {
        ::bitflags::_core::fmt::Binary::fmt(&self.bits, f)
    }
}
impl ::bitflags::_core::fmt::Octal for RoleFlags {
    fn fmt(
        &self,
        f: &mut ::bitflags::_core::fmt::Formatter,
    ) -> ::bitflags::_core::fmt::Result {
        ::bitflags::_core::fmt::Octal::fmt(&self.bits, f)
    }
}
impl ::bitflags::_core::fmt::LowerHex for RoleFlags {
    fn fmt(
        &self,
        f: &mut ::bitflags::_core::fmt::Formatter,
    ) -> ::bitflags::_core::fmt::Result {
        ::bitflags::_core::fmt::LowerHex::fmt(&self.bits, f)
    }
}
impl ::bitflags::_core::fmt::UpperHex for RoleFlags {
    fn fmt(
        &self,
        f: &mut ::bitflags::_core::fmt::Formatter,
    ) -> ::bitflags::_core::fmt::Result {
        ::bitflags::_core::fmt::UpperHex::fmt(&self.bits, f)
    }
}
#[allow(dead_code)]
impl RoleFlags {
    pub const __SUPER_ADMIN: Self = Self { bits: 1u128 << 0u8 };
    pub const PAUSEMANAGER: Self = Self { bits: 1u128 << 1u8 };
    pub const PAUSEMANAGER_ADMIN: Self = Self { bits: 1u128 << 2u8 };
    pub const UNRESTRICTEDUNLOCK: Self = Self { bits: 1u128 << 3u8 };
    pub const UNRESTRICTEDUNLOCK_ADMIN: Self = Self { bits: 1u128 << 4u8 };
    pub const UNRESTRICTEDLPUNLOCK: Self = Self { bits: 1u128 << 5u8 };
    pub const UNRESTRICTEDLPUNLOCK_ADMIN: Self = Self { bits: 1u128 << 6u8 };
    pub const UNRESTRICTEDWITHDRAW: Self = Self { bits: 1u128 << 7u8 };
    pub const UNRESTRICTEDWITHDRAW_ADMIN: Self = Self { bits: 1u128 << 8u8 };
    pub const WHITELISTMANAGER: Self = Self { bits: 1u128 << 9u8 };
    pub const WHITELISTMANAGER_ADMIN: Self = Self { bits: 1u128 << 10u8 };
    pub const CONFIGMANAGER: Self = Self { bits: 1u128 << 11u8 };
    pub const CONFIGMANAGER_ADMIN: Self = Self { bits: 1u128 << 12u8 };
    pub const UNLOCKMANAGER: Self = Self { bits: 1u128 << 13u8 };
    pub const UNLOCKMANAGER_ADMIN: Self = Self { bits: 1u128 << 14u8 };
    pub const DAO: Self = Self { bits: 1u128 << 15u8 };
    pub const DAO_ADMIN: Self = Self { bits: 1u128 << 16u8 };
    pub const CODESTAGER: Self = Self { bits: 1u128 << 17u8 };
    pub const CODESTAGER_ADMIN: Self = Self { bits: 1u128 << 18u8 };
    pub const CODEDEPLOYER: Self = Self { bits: 1u128 << 19u8 };
    pub const CODEDEPLOYER_ADMIN: Self = Self { bits: 1u128 << 20u8 };
    pub const DURATIONMANAGER: Self = Self { bits: 1u128 << 21u8 };
    pub const DURATIONMANAGER_ADMIN: Self = Self { bits: 1u128 << 22u8 };
    /// Returns an empty set of flags.
    #[inline]
    pub const fn empty() -> Self {
        Self { bits: 0 }
    }
    /// Returns the set containing all flags.
    #[inline]
    pub const fn all() -> Self {
        #[allow(non_snake_case)]
        trait __BitFlags {
            const __SUPER_ADMIN: u128 = 0;
            const PAUSEMANAGER: u128 = 0;
            const PAUSEMANAGER_ADMIN: u128 = 0;
            const UNRESTRICTEDUNLOCK: u128 = 0;
            const UNRESTRICTEDUNLOCK_ADMIN: u128 = 0;
            const UNRESTRICTEDLPUNLOCK: u128 = 0;
            const UNRESTRICTEDLPUNLOCK_ADMIN: u128 = 0;
            const UNRESTRICTEDWITHDRAW: u128 = 0;
            const UNRESTRICTEDWITHDRAW_ADMIN: u128 = 0;
            const WHITELISTMANAGER: u128 = 0;
            const WHITELISTMANAGER_ADMIN: u128 = 0;
            const CONFIGMANAGER: u128 = 0;
            const CONFIGMANAGER_ADMIN: u128 = 0;
            const UNLOCKMANAGER: u128 = 0;
            const UNLOCKMANAGER_ADMIN: u128 = 0;
            const DAO: u128 = 0;
            const DAO_ADMIN: u128 = 0;
            const CODESTAGER: u128 = 0;
            const CODESTAGER_ADMIN: u128 = 0;
            const CODEDEPLOYER: u128 = 0;
            const CODEDEPLOYER_ADMIN: u128 = 0;
            const DURATIONMANAGER: u128 = 0;
            const DURATIONMANAGER_ADMIN: u128 = 0;
        }
        #[allow(non_snake_case)]
        impl __BitFlags for RoleFlags {
            #[allow(deprecated)]
            const __SUPER_ADMIN: u128 = Self::__SUPER_ADMIN.bits;
            #[allow(deprecated)]
            const PAUSEMANAGER: u128 = Self::PAUSEMANAGER.bits;
            #[allow(deprecated)]
            const PAUSEMANAGER_ADMIN: u128 = Self::PAUSEMANAGER_ADMIN.bits;
            #[allow(deprecated)]
            const UNRESTRICTEDUNLOCK: u128 = Self::UNRESTRICTEDUNLOCK.bits;
            #[allow(deprecated)]
            const UNRESTRICTEDUNLOCK_ADMIN: u128 = Self::UNRESTRICTEDUNLOCK_ADMIN.bits;
            #[allow(deprecated)]
            const UNRESTRICTEDLPUNLOCK: u128 = Self::UNRESTRICTEDLPUNLOCK.bits;
            #[allow(deprecated)]
            const UNRESTRICTEDLPUNLOCK_ADMIN: u128 = Self::UNRESTRICTEDLPUNLOCK_ADMIN
                .bits;
            #[allow(deprecated)]
            const UNRESTRICTEDWITHDRAW: u128 = Self::UNRESTRICTEDWITHDRAW.bits;
            #[allow(deprecated)]
            const UNRESTRICTEDWITHDRAW_ADMIN: u128 = Self::UNRESTRICTEDWITHDRAW_ADMIN
                .bits;
            #[allow(deprecated)]
            const WHITELISTMANAGER: u128 = Self::WHITELISTMANAGER.bits;
            #[allow(deprecated)]
            const WHITELISTMANAGER_ADMIN: u128 = Self::WHITELISTMANAGER_ADMIN.bits;
            #[allow(deprecated)]
            const CONFIGMANAGER: u128 = Self::CONFIGMANAGER.bits;
            #[allow(deprecated)]
            const CONFIGMANAGER_ADMIN: u128 = Self::CONFIGMANAGER_ADMIN.bits;
            #[allow(deprecated)]
            const UNLOCKMANAGER: u128 = Self::UNLOCKMANAGER.bits;
            #[allow(deprecated)]
            const UNLOCKMANAGER_ADMIN: u128 = Self::UNLOCKMANAGER_ADMIN.bits;
            #[allow(deprecated)]
            const DAO: u128 = Self::DAO.bits;
            #[allow(deprecated)]
            const DAO_ADMIN: u128 = Self::DAO_ADMIN.bits;
            #[allow(deprecated)]
            const CODESTAGER: u128 = Self::CODESTAGER.bits;
            #[allow(deprecated)]
            const CODESTAGER_ADMIN: u128 = Self::CODESTAGER_ADMIN.bits;
            #[allow(deprecated)]
            const CODEDEPLOYER: u128 = Self::CODEDEPLOYER.bits;
            #[allow(deprecated)]
            const CODEDEPLOYER_ADMIN: u128 = Self::CODEDEPLOYER_ADMIN.bits;
            #[allow(deprecated)]
            const DURATIONMANAGER: u128 = Self::DURATIONMANAGER.bits;
            #[allow(deprecated)]
            const DURATIONMANAGER_ADMIN: u128 = Self::DURATIONMANAGER_ADMIN.bits;
        }
        Self {
            bits: <Self as __BitFlags>::__SUPER_ADMIN
                | <Self as __BitFlags>::PAUSEMANAGER
                | <Self as __BitFlags>::PAUSEMANAGER_ADMIN
                | <Self as __BitFlags>::UNRESTRICTEDUNLOCK
                | <Self as __BitFlags>::UNRESTRICTEDUNLOCK_ADMIN
                | <Self as __BitFlags>::UNRESTRICTEDLPUNLOCK
                | <Self as __BitFlags>::UNRESTRICTEDLPUNLOCK_ADMIN
                | <Self as __BitFlags>::UNRESTRICTEDWITHDRAW
                | <Self as __BitFlags>::UNRESTRICTEDWITHDRAW_ADMIN
                | <Self as __BitFlags>::WHITELISTMANAGER
                | <Self as __BitFlags>::WHITELISTMANAGER_ADMIN
                | <Self as __BitFlags>::CONFIGMANAGER
                | <Self as __BitFlags>::CONFIGMANAGER_ADMIN
                | <Self as __BitFlags>::UNLOCKMANAGER
                | <Self as __BitFlags>::UNLOCKMANAGER_ADMIN | <Self as __BitFlags>::DAO
                | <Self as __BitFlags>::DAO_ADMIN | <Self as __BitFlags>::CODESTAGER
                | <Self as __BitFlags>::CODESTAGER_ADMIN
                | <Self as __BitFlags>::CODEDEPLOYER
                | <Self as __BitFlags>::CODEDEPLOYER_ADMIN
                | <Self as __BitFlags>::DURATIONMANAGER
                | <Self as __BitFlags>::DURATIONMANAGER_ADMIN,
        }
    }
    /// Returns the raw value of the flags currently stored.
    #[inline]
    pub const fn bits(&self) -> u128 {
        self.bits
    }
    /// Convert from underlying bit representation, unless that
    /// representation contains bits that do not correspond to a flag.
    #[inline]
    pub const fn from_bits(bits: u128) -> ::bitflags::_core::option::Option<Self> {
        if (bits & !Self::all().bits()) == 0 {
            ::bitflags::_core::option::Option::Some(Self { bits })
        } else {
            ::bitflags::_core::option::Option::None
        }
    }
    /// Convert from underlying bit representation, dropping any bits
    /// that do not correspond to flags.
    #[inline]
    pub const fn from_bits_truncate(bits: u128) -> Self {
        Self {
            bits: bits & Self::all().bits,
        }
    }
    /// Convert from underlying bit representation, preserving all
    /// bits (even those not corresponding to a defined flag).
    ///
    /// # Safety
    ///
    /// The caller of the `bitflags!` macro can chose to allow or
    /// disallow extra bits for their bitflags type.
    ///
    /// The caller of `from_bits_unchecked()` has to ensure that
    /// all bits correspond to a defined flag or that extra bits
    /// are valid for this bitflags type.
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u128) -> Self {
        Self { bits }
    }
    /// Returns `true` if no flags are currently stored.
    #[inline]
    pub const fn is_empty(&self) -> bool {
        self.bits() == Self::empty().bits()
    }
    /// Returns `true` if all flags are currently set.
    #[inline]
    pub const fn is_all(&self) -> bool {
        Self::all().bits | self.bits == self.bits
    }
    /// Returns `true` if there are flags common to both `self` and `other`.
    #[inline]
    pub const fn intersects(&self, other: Self) -> bool {
        !(Self {
            bits: self.bits & other.bits,
        })
            .is_empty()
    }
    /// Returns `true` if all of the flags in `other` are contained within `self`.
    #[inline]
    pub const fn contains(&self, other: Self) -> bool {
        (self.bits & other.bits) == other.bits
    }
    /// Inserts the specified flags in-place.
    #[inline]
    pub fn insert(&mut self, other: Self) {
        self.bits |= other.bits;
    }
    /// Removes the specified flags in-place.
    #[inline]
    pub fn remove(&mut self, other: Self) {
        self.bits &= !other.bits;
    }
    /// Toggles the specified flags in-place.
    #[inline]
    pub fn toggle(&mut self, other: Self) {
        self.bits ^= other.bits;
    }
    /// Inserts or removes the specified flags depending on the passed value.
    #[inline]
    pub fn set(&mut self, other: Self, value: bool) {
        if value {
            self.insert(other);
        } else {
            self.remove(other);
        }
    }
    /// Returns the intersection between the flags in `self` and
    /// `other`.
    ///
    /// Specifically, the returned set contains only the flags which are
    /// present in *both* `self` *and* `other`.
    ///
    /// This is equivalent to using the `&` operator (e.g.
    /// [`ops::BitAnd`]), as in `flags & other`.
    ///
    /// [`ops::BitAnd`]: https://doc.rust-lang.org/std/ops/trait.BitAnd.html
    #[inline]
    #[must_use]
    pub const fn intersection(self, other: Self) -> Self {
        Self {
            bits: self.bits & other.bits,
        }
    }
    /// Returns the union of between the flags in `self` and `other`.
    ///
    /// Specifically, the returned set contains all flags which are
    /// present in *either* `self` *or* `other`, including any which are
    /// present in both (see [`Self::symmetric_difference`] if that
    /// is undesirable).
    ///
    /// This is equivalent to using the `|` operator (e.g.
    /// [`ops::BitOr`]), as in `flags | other`.
    ///
    /// [`ops::BitOr`]: https://doc.rust-lang.org/std/ops/trait.BitOr.html
    #[inline]
    #[must_use]
    pub const fn union(self, other: Self) -> Self {
        Self {
            bits: self.bits | other.bits,
        }
    }
    /// Returns the difference between the flags in `self` and `other`.
    ///
    /// Specifically, the returned set contains all flags present in
    /// `self`, except for the ones present in `other`.
    ///
    /// It is also conceptually equivalent to the "bit-clear" operation:
    /// `flags & !other` (and this syntax is also supported).
    ///
    /// This is equivalent to using the `-` operator (e.g.
    /// [`ops::Sub`]), as in `flags - other`.
    ///
    /// [`ops::Sub`]: https://doc.rust-lang.org/std/ops/trait.Sub.html
    #[inline]
    #[must_use]
    pub const fn difference(self, other: Self) -> Self {
        Self {
            bits: self.bits & !other.bits,
        }
    }
    /// Returns the [symmetric difference][sym-diff] between the flags
    /// in `self` and `other`.
    ///
    /// Specifically, the returned set contains the flags present which
    /// are present in `self` or `other`, but that are not present in
    /// both. Equivalently, it contains the flags present in *exactly
    /// one* of the sets `self` and `other`.
    ///
    /// This is equivalent to using the `^` operator (e.g.
    /// [`ops::BitXor`]), as in `flags ^ other`.
    ///
    /// [sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
    /// [`ops::BitXor`]: https://doc.rust-lang.org/std/ops/trait.BitXor.html
    #[inline]
    #[must_use]
    pub const fn symmetric_difference(self, other: Self) -> Self {
        Self {
            bits: self.bits ^ other.bits,
        }
    }
    /// Returns the complement of this set of flags.
    ///
    /// Specifically, the returned set contains all the flags which are
    /// not set in `self`, but which are allowed for this type.
    ///
    /// Alternatively, it can be thought of as the set difference
    /// between [`Self::all()`] and `self` (e.g. `Self::all() - self`)
    ///
    /// This is equivalent to using the `!` operator (e.g.
    /// [`ops::Not`]), as in `!flags`.
    ///
    /// [`Self::all()`]: Self::all
    /// [`ops::Not`]: https://doc.rust-lang.org/std/ops/trait.Not.html
    #[inline]
    #[must_use]
    pub const fn complement(self) -> Self {
        Self::from_bits_truncate(!self.bits)
    }
}
impl ::bitflags::_core::ops::BitOr for RoleFlags {
    type Output = Self;
    /// Returns the union of the two sets of flags.
    #[inline]
    fn bitor(self, other: RoleFlags) -> Self {
        Self {
            bits: self.bits | other.bits,
        }
    }
}
impl ::bitflags::_core::ops::BitOrAssign for RoleFlags {
    /// Adds the set of flags.
    #[inline]
    fn bitor_assign(&mut self, other: Self) {
        self.bits |= other.bits;
    }
}
impl ::bitflags::_core::ops::BitXor for RoleFlags {
    type Output = Self;
    /// Returns the left flags, but with all the right flags toggled.
    #[inline]
    fn bitxor(self, other: Self) -> Self {
        Self {
            bits: self.bits ^ other.bits,
        }
    }
}
impl ::bitflags::_core::ops::BitXorAssign for RoleFlags {
    /// Toggles the set of flags.
    #[inline]
    fn bitxor_assign(&mut self, other: Self) {
        self.bits ^= other.bits;
    }
}
impl ::bitflags::_core::ops::BitAnd for RoleFlags {
    type Output = Self;
    /// Returns the intersection between the two sets of flags.
    #[inline]
    fn bitand(self, other: Self) -> Self {
        Self {
            bits: self.bits & other.bits,
        }
    }
}
impl ::bitflags::_core::ops::BitAndAssign for RoleFlags {
    /// Disables all flags disabled in the set.
    #[inline]
    fn bitand_assign(&mut self, other: Self) {
        self.bits &= other.bits;
    }
}
impl ::bitflags::_core::ops::Sub for RoleFlags {
    type Output = Self;
    /// Returns the set difference of the two sets of flags.
    #[inline]
    fn sub(self, other: Self) -> Self {
        Self {
            bits: self.bits & !other.bits,
        }
    }
}
impl ::bitflags::_core::ops::SubAssign for RoleFlags {
    /// Disables all flags enabled in the set.
    #[inline]
    fn sub_assign(&mut self, other: Self) {
        self.bits &= !other.bits;
    }
}
impl ::bitflags::_core::ops::Not for RoleFlags {
    type Output = Self;
    /// Returns the complement of this set of flags.
    #[inline]
    fn not(self) -> Self {
        Self { bits: !self.bits } & Self::all()
    }
}
impl ::bitflags::_core::iter::Extend<RoleFlags> for RoleFlags {
    fn extend<T: ::bitflags::_core::iter::IntoIterator<Item = Self>>(
        &mut self,
        iterator: T,
    ) {
        for item in iterator {
            self.insert(item)
        }
    }
}
impl ::bitflags::_core::iter::FromIterator<RoleFlags> for RoleFlags {
    fn from_iter<T: ::bitflags::_core::iter::IntoIterator<Item = Self>>(
        iterator: T,
    ) -> Self {
        let mut result = Self::empty();
        result.extend(iterator);
        result
    }
}
#[doc(hidden)]
#[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
const _: () = {
    use near_sdk::serde as _serde;
    #[automatically_derived]
    impl<'de> near_sdk::serde::Deserialize<'de> for Role {
        fn deserialize<__D>(
            __deserializer: __D,
        ) -> near_sdk::serde::__private::Result<Self, __D::Error>
        where
            __D: near_sdk::serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            enum __Field {
                __field0,
                __field1,
                __field2,
                __field3,
                __field4,
                __field5,
                __field6,
                __field7,
                __field8,
                __field9,
                __field10,
            }
            #[doc(hidden)]
            struct __FieldVisitor;
            impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                type Value = __Field;
                fn expecting(
                    &self,
                    __formatter: &mut _serde::__private::Formatter,
                ) -> _serde::__private::fmt::Result {
                    _serde::__private::Formatter::write_str(
                        __formatter,
                        "variant identifier",
                    )
                }
                fn visit_u64<__E>(
                    self,
                    __value: u64,
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        0u64 => _serde::__private::Ok(__Field::__field0),
                        1u64 => _serde::__private::Ok(__Field::__field1),
                        2u64 => _serde::__private::Ok(__Field::__field2),
                        3u64 => _serde::__private::Ok(__Field::__field3),
                        4u64 => _serde::__private::Ok(__Field::__field4),
                        5u64 => _serde::__private::Ok(__Field::__field5),
                        6u64 => _serde::__private::Ok(__Field::__field6),
                        7u64 => _serde::__private::Ok(__Field::__field7),
                        8u64 => _serde::__private::Ok(__Field::__field8),
                        9u64 => _serde::__private::Ok(__Field::__field9),
                        10u64 => _serde::__private::Ok(__Field::__field10),
                        _ => {
                            _serde::__private::Err(
                                _serde::de::Error::invalid_value(
                                    _serde::de::Unexpected::Unsigned(__value),
                                    &"variant index 0 <= i < 11",
                                ),
                            )
                        }
                    }
                }
                fn visit_str<__E>(
                    self,
                    __value: &str,
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        "PauseManager" => _serde::__private::Ok(__Field::__field0),
                        "UnrestrictedUnlock" => _serde::__private::Ok(__Field::__field1),
                        "UnrestrictedLpUnlock" => {
                            _serde::__private::Ok(__Field::__field2)
                        }
                        "UnrestrictedWithdraw" => {
                            _serde::__private::Ok(__Field::__field3)
                        }
                        "WhitelistManager" => _serde::__private::Ok(__Field::__field4),
                        "ConfigManager" => _serde::__private::Ok(__Field::__field5),
                        "UnlockManager" => _serde::__private::Ok(__Field::__field6),
                        "DAO" => _serde::__private::Ok(__Field::__field7),
                        "CodeStager" => _serde::__private::Ok(__Field::__field8),
                        "CodeDeployer" => _serde::__private::Ok(__Field::__field9),
                        "DurationManager" => _serde::__private::Ok(__Field::__field10),
                        _ => {
                            _serde::__private::Err(
                                _serde::de::Error::unknown_variant(__value, VARIANTS),
                            )
                        }
                    }
                }
                fn visit_bytes<__E>(
                    self,
                    __value: &[u8],
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        b"PauseManager" => _serde::__private::Ok(__Field::__field0),
                        b"UnrestrictedUnlock" => _serde::__private::Ok(__Field::__field1),
                        b"UnrestrictedLpUnlock" => {
                            _serde::__private::Ok(__Field::__field2)
                        }
                        b"UnrestrictedWithdraw" => {
                            _serde::__private::Ok(__Field::__field3)
                        }
                        b"WhitelistManager" => _serde::__private::Ok(__Field::__field4),
                        b"ConfigManager" => _serde::__private::Ok(__Field::__field5),
                        b"UnlockManager" => _serde::__private::Ok(__Field::__field6),
                        b"DAO" => _serde::__private::Ok(__Field::__field7),
                        b"CodeStager" => _serde::__private::Ok(__Field::__field8),
                        b"CodeDeployer" => _serde::__private::Ok(__Field::__field9),
                        b"DurationManager" => _serde::__private::Ok(__Field::__field10),
                        _ => {
                            let __value = &_serde::__private::from_utf8_lossy(__value);
                            _serde::__private::Err(
                                _serde::de::Error::unknown_variant(__value, VARIANTS),
                            )
                        }
                    }
                }
            }
            impl<'de> _serde::Deserialize<'de> for __Field {
                #[inline]
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    _serde::Deserializer::deserialize_identifier(
                        __deserializer,
                        __FieldVisitor,
                    )
                }
            }
            #[doc(hidden)]
            struct __Visitor<'de> {
                marker: _serde::__private::PhantomData<Role>,
                lifetime: _serde::__private::PhantomData<&'de ()>,
            }
            impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                type Value = Role;
                fn expecting(
                    &self,
                    __formatter: &mut _serde::__private::Formatter,
                ) -> _serde::__private::fmt::Result {
                    _serde::__private::Formatter::write_str(__formatter, "enum Role")
                }
                fn visit_enum<__A>(
                    self,
                    __data: __A,
                ) -> _serde::__private::Result<Self::Value, __A::Error>
                where
                    __A: _serde::de::EnumAccess<'de>,
                {
                    match match _serde::de::EnumAccess::variant(__data) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    } {
                        (__Field::__field0, __variant) => {
                            match _serde::de::VariantAccess::unit_variant(__variant) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            };
                            _serde::__private::Ok(Role::PauseManager)
                        }
                        (__Field::__field1, __variant) => {
                            match _serde::de::VariantAccess::unit_variant(__variant) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            };
                            _serde::__private::Ok(Role::UnrestrictedUnlock)
                        }
                        (__Field::__field2, __variant) => {
                            match _serde::de::VariantAccess::unit_variant(__variant) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            };
                            _serde::__private::Ok(Role::UnrestrictedLpUnlock)
                        }
                        (__Field::__field3, __variant) => {
                            match _serde::de::VariantAccess::unit_variant(__variant) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            };
                            _serde::__private::Ok(Role::UnrestrictedWithdraw)
                        }
                        (__Field::__field4, __variant) => {
                            match _serde::de::VariantAccess::unit_variant(__variant) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            };
                            _serde::__private::Ok(Role::WhitelistManager)
                        }
                        (__Field::__field5, __variant) => {
                            match _serde::de::VariantAccess::unit_variant(__variant) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            };
                            _serde::__private::Ok(Role::ConfigManager)
                        }
                        (__Field::__field6, __variant) => {
                            match _serde::de::VariantAccess::unit_variant(__variant) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            };
                            _serde::__private::Ok(Role::UnlockManager)
                        }
                        (__Field::__field7, __variant) => {
                            match _serde::de::VariantAccess::unit_variant(__variant) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            };
                            _serde::__private::Ok(Role::DAO)
                        }
                        (__Field::__field8, __variant) => {
                            match _serde::de::VariantAccess::unit_variant(__variant) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            };
                            _serde::__private::Ok(Role::CodeStager)
                        }
                        (__Field::__field9, __variant) => {
                            match _serde::de::VariantAccess::unit_variant(__variant) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            };
                            _serde::__private::Ok(Role::CodeDeployer)
                        }
                        (__Field::__field10, __variant) => {
                            match _serde::de::VariantAccess::unit_variant(__variant) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            };
                            _serde::__private::Ok(Role::DurationManager)
                        }
                    }
                }
            }
            #[doc(hidden)]
            const VARIANTS: &'static [&'static str] = &[
                "PauseManager",
                "UnrestrictedUnlock",
                "UnrestrictedLpUnlock",
                "UnrestrictedWithdraw",
                "WhitelistManager",
                "ConfigManager",
                "UnlockManager",
                "DAO",
                "CodeStager",
                "CodeDeployer",
                "DurationManager",
            ];
            _serde::Deserializer::deserialize_enum(
                __deserializer,
                "Role",
                VARIANTS,
                __Visitor {
                    marker: _serde::__private::PhantomData::<Role>,
                    lifetime: _serde::__private::PhantomData,
                },
            )
        }
    }
};
#[doc(hidden)]
#[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
const _: () = {
    use near_sdk::serde as _serde;
    #[automatically_derived]
    impl near_sdk::serde::Serialize for Role {
        fn serialize<__S>(
            &self,
            __serializer: __S,
        ) -> near_sdk::serde::__private::Result<__S::Ok, __S::Error>
        where
            __S: near_sdk::serde::Serializer,
        {
            match *self {
                Role::PauseManager => {
                    _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "Role",
                        0u32,
                        "PauseManager",
                    )
                }
                Role::UnrestrictedUnlock => {
                    _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "Role",
                        1u32,
                        "UnrestrictedUnlock",
                    )
                }
                Role::UnrestrictedLpUnlock => {
                    _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "Role",
                        2u32,
                        "UnrestrictedLpUnlock",
                    )
                }
                Role::UnrestrictedWithdraw => {
                    _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "Role",
                        3u32,
                        "UnrestrictedWithdraw",
                    )
                }
                Role::WhitelistManager => {
                    _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "Role",
                        4u32,
                        "WhitelistManager",
                    )
                }
                Role::ConfigManager => {
                    _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "Role",
                        5u32,
                        "ConfigManager",
                    )
                }
                Role::UnlockManager => {
                    _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "Role",
                        6u32,
                        "UnlockManager",
                    )
                }
                Role::DAO => {
                    _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "Role",
                        7u32,
                        "DAO",
                    )
                }
                Role::CodeStager => {
                    _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "Role",
                        8u32,
                        "CodeStager",
                    )
                }
                Role::CodeDeployer => {
                    _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "Role",
                        9u32,
                        "CodeDeployer",
                    )
                }
                Role::DurationManager => {
                    _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "Role",
                        10u32,
                        "DurationManager",
                    )
                }
            }
        }
    }
};
#[automatically_derived]
impl ::core::marker::Copy for Role {}
#[automatically_derived]
impl ::core::clone::Clone for Role {
    #[inline]
    fn clone(&self) -> Role {
        *self
    }
}
#[pausable(manager_roles(Role::PauseManager, Role::DAO))]
#[upgradable(
    access_control_roles(
        code_stagers(Role::CodeStager, Role::DAO),
        code_deployers(Role::CodeDeployer, Role::DAO),
        duration_initializers(Role::DurationManager, Role::DAO),
        duration_update_stagers(Role::DurationManager, Role::DAO),
        duration_update_appliers(Role::DurationManager, Role::DAO),
    )
)]
pub struct FastBridge {
    pending_transfers: UnorderedMap<String, (AccountId, TransferMessage)>,
    token_balances: LookupMap<AccountId, LookupMap<AccountId, u128>>,
    nonce: u128,
    prover_account: AccountId,
    eth_client_account: AccountId,
    eth_bridge_contract: EthAddress,
    lock_duration: LockDuration,
    eth_block_time: Duration,
    /// Mapping whitelisted tokens to their mode
    whitelist_tokens: UnorderedMap<AccountId, WhitelistMode>,
    /// Mapping whitelisted accounts to their whitelisted tokens by using combined key {token}:{account}
    whitelist_accounts: UnorderedSet<String>,
    /// The mode of the whitelist check
    is_whitelist_mode_enabled: bool,
    pending_transfers_balances: UnorderedMap<AccountId, u128>,
}
impl borsh::de::BorshDeserialize for FastBridge
where
    UnorderedMap<String, (AccountId, TransferMessage)>: borsh::BorshDeserialize,
    LookupMap<AccountId, LookupMap<AccountId, u128>>: borsh::BorshDeserialize,
    u128: borsh::BorshDeserialize,
    AccountId: borsh::BorshDeserialize,
    AccountId: borsh::BorshDeserialize,
    EthAddress: borsh::BorshDeserialize,
    LockDuration: borsh::BorshDeserialize,
    Duration: borsh::BorshDeserialize,
    UnorderedMap<AccountId, WhitelistMode>: borsh::BorshDeserialize,
    UnorderedSet<String>: borsh::BorshDeserialize,
    bool: borsh::BorshDeserialize,
    UnorderedMap<AccountId, u128>: borsh::BorshDeserialize,
{
    fn deserialize(
        buf: &mut &[u8],
    ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
        Ok(Self {
            pending_transfers: borsh::BorshDeserialize::deserialize(buf)?,
            token_balances: borsh::BorshDeserialize::deserialize(buf)?,
            nonce: borsh::BorshDeserialize::deserialize(buf)?,
            prover_account: borsh::BorshDeserialize::deserialize(buf)?,
            eth_client_account: borsh::BorshDeserialize::deserialize(buf)?,
            eth_bridge_contract: borsh::BorshDeserialize::deserialize(buf)?,
            lock_duration: borsh::BorshDeserialize::deserialize(buf)?,
            eth_block_time: borsh::BorshDeserialize::deserialize(buf)?,
            whitelist_tokens: borsh::BorshDeserialize::deserialize(buf)?,
            whitelist_accounts: borsh::BorshDeserialize::deserialize(buf)?,
            is_whitelist_mode_enabled: borsh::BorshDeserialize::deserialize(buf)?,
            pending_transfers_balances: borsh::BorshDeserialize::deserialize(buf)?,
        })
    }
}
impl borsh::ser::BorshSerialize for FastBridge
where
    UnorderedMap<String, (AccountId, TransferMessage)>: borsh::ser::BorshSerialize,
    LookupMap<AccountId, LookupMap<AccountId, u128>>: borsh::ser::BorshSerialize,
    u128: borsh::ser::BorshSerialize,
    AccountId: borsh::ser::BorshSerialize,
    AccountId: borsh::ser::BorshSerialize,
    EthAddress: borsh::ser::BorshSerialize,
    LockDuration: borsh::ser::BorshSerialize,
    Duration: borsh::ser::BorshSerialize,
    UnorderedMap<AccountId, WhitelistMode>: borsh::ser::BorshSerialize,
    UnorderedSet<String>: borsh::ser::BorshSerialize,
    bool: borsh::ser::BorshSerialize,
    UnorderedMap<AccountId, u128>: borsh::ser::BorshSerialize,
{
    fn serialize<W: borsh::maybestd::io::Write>(
        &self,
        writer: &mut W,
    ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
        borsh::BorshSerialize::serialize(&self.pending_transfers, writer)?;
        borsh::BorshSerialize::serialize(&self.token_balances, writer)?;
        borsh::BorshSerialize::serialize(&self.nonce, writer)?;
        borsh::BorshSerialize::serialize(&self.prover_account, writer)?;
        borsh::BorshSerialize::serialize(&self.eth_client_account, writer)?;
        borsh::BorshSerialize::serialize(&self.eth_bridge_contract, writer)?;
        borsh::BorshSerialize::serialize(&self.lock_duration, writer)?;
        borsh::BorshSerialize::serialize(&self.eth_block_time, writer)?;
        borsh::BorshSerialize::serialize(&self.whitelist_tokens, writer)?;
        borsh::BorshSerialize::serialize(&self.whitelist_accounts, writer)?;
        borsh::BorshSerialize::serialize(&self.is_whitelist_mode_enabled, writer)?;
        borsh::BorshSerialize::serialize(&self.pending_transfers_balances, writer)?;
        Ok(())
    }
}
impl Default for FastBridge {
    fn default() -> Self {
        near_sdk::env::panic_str("The contract is not initialized");
    }
}
impl FastBridgeExt {
    pub fn pa_storage_key(self) -> near_sdk::Promise {
        let __args = ::alloc::vec::Vec::new();
        near_sdk::Promise::new(self.account_id)
            .function_call_weight(
                "pa_storage_key".to_string(),
                __args,
                self.deposit,
                self.static_gas,
                self.gas_weight,
            )
    }
    pub fn pa_is_paused(self, key: String) -> near_sdk::Promise {
        let __args = {
            #[serde(crate = "near_sdk::serde")]
            struct Input<'nearinput> {
                key: &'nearinput String,
            }
            #[doc(hidden)]
            #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
            const _: () = {
                use near_sdk::serde as _serde;
                #[automatically_derived]
                impl<'nearinput> near_sdk::serde::Serialize for Input<'nearinput> {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> near_sdk::serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: near_sdk::serde::Serializer,
                    {
                        let mut __serde_state = match _serde::Serializer::serialize_struct(
                            __serializer,
                            "Input",
                            false as usize + 1,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "key",
                            &self.key,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            let __args = Input { key: &key };
            near_sdk::serde_json::to_vec(&__args)
                .expect("Failed to serialize the cross contract args using JSON.")
        };
        near_sdk::Promise::new(self.account_id)
            .function_call_weight(
                "pa_is_paused".to_string(),
                __args,
                self.deposit,
                self.static_gas,
                self.gas_weight,
            )
    }
    pub fn pa_all_paused(self) -> near_sdk::Promise {
        let __args = ::alloc::vec::Vec::new();
        near_sdk::Promise::new(self.account_id)
            .function_call_weight(
                "pa_all_paused".to_string(),
                __args,
                self.deposit,
                self.static_gas,
                self.gas_weight,
            )
    }
    pub fn pa_pause_feature(self, key: String) -> near_sdk::Promise {
        let __args = {
            #[serde(crate = "near_sdk::serde")]
            struct Input<'nearinput> {
                key: &'nearinput String,
            }
            #[doc(hidden)]
            #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
            const _: () = {
                use near_sdk::serde as _serde;
                #[automatically_derived]
                impl<'nearinput> near_sdk::serde::Serialize for Input<'nearinput> {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> near_sdk::serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: near_sdk::serde::Serializer,
                    {
                        let mut __serde_state = match _serde::Serializer::serialize_struct(
                            __serializer,
                            "Input",
                            false as usize + 1,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "key",
                            &self.key,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            let __args = Input { key: &key };
            near_sdk::serde_json::to_vec(&__args)
                .expect("Failed to serialize the cross contract args using JSON.")
        };
        near_sdk::Promise::new(self.account_id)
            .function_call_weight(
                "pa_pause_feature".to_string(),
                __args,
                self.deposit,
                self.static_gas,
                self.gas_weight,
            )
    }
    pub fn pa_unpause_feature(self, key: String) -> near_sdk::Promise {
        let __args = {
            #[serde(crate = "near_sdk::serde")]
            struct Input<'nearinput> {
                key: &'nearinput String,
            }
            #[doc(hidden)]
            #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
            const _: () = {
                use near_sdk::serde as _serde;
                #[automatically_derived]
                impl<'nearinput> near_sdk::serde::Serialize for Input<'nearinput> {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> near_sdk::serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: near_sdk::serde::Serializer,
                    {
                        let mut __serde_state = match _serde::Serializer::serialize_struct(
                            __serializer,
                            "Input",
                            false as usize + 1,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "key",
                            &self.key,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            let __args = Input { key: &key };
            near_sdk::serde_json::to_vec(&__args)
                .expect("Failed to serialize the cross contract args using JSON.")
        };
        near_sdk::Promise::new(self.account_id)
            .function_call_weight(
                "pa_unpause_feature".to_string(),
                __args,
                self.deposit,
                self.static_gas,
                self.gas_weight,
            )
    }
}
impl Pausable for FastBridge {
    fn pa_storage_key(&self) -> &'static [u8] {
        ("__PAUSE__").as_bytes()
    }
    fn pa_is_paused(&self, key: String) -> bool {
        self.pa_all_paused()
            .map(|keys| keys.contains(&key) || keys.contains("ALL"))
            .unwrap_or(false)
    }
    fn pa_all_paused(&self) -> Option<std::collections::HashSet<String>> {
        ::near_sdk::env::storage_read(self.pa_storage_key().as_ref())
            .map(|value| {
                std::collections::HashSet::try_from_slice(value.as_ref())
                    .unwrap_or_else(|_| ::near_sdk::env::panic_str(
                        "Pausable: Invalid format for paused keys",
                    ))
            })
    }
    fn pa_pause_feature(&mut self, key: String) -> bool {
        let __acl_any_roles: Vec<&str> = <[_]>::into_vec(
            #[rustc_box]
            ::alloc::boxed::Box::new([Role::PauseManager.into(), Role::DAO.into()]),
        );
        let __acl_any_roles_ser: Vec<String> = __acl_any_roles
            .iter()
            .map(|&role| role.into())
            .collect();
        let __acl_any_account_id = ::near_sdk::env::predecessor_account_id();
        if !self.acl_has_any_role(__acl_any_roles_ser, __acl_any_account_id) {
            let message = {
                let res = ::alloc::fmt::format(
                    format_args!(
                        "Insufficient permissions for method {0} restricted by access control. Requires one of these roles: {1:?}",
                        "pa_pause_feature",
                        __acl_any_roles,
                    ),
                );
                res
            };
            near_sdk::env::panic_str(&message);
        }
        let mut paused_keys = self.pa_all_paused().unwrap_or_default();
        let newly_paused = paused_keys.insert(key.clone());
        if !newly_paused {
            return false;
        }
        ::near_sdk::env::storage_write(
            self.pa_storage_key().as_ref(),
            paused_keys
                .try_to_vec()
                .unwrap_or_else(|_| ::near_sdk::env::panic_str(
                    "Pausable: Unexpected error serializing keys",
                ))
                .as_ref(),
        );
        let event = near_plugins::pausable::Pause {
            by: ::near_sdk::env::predecessor_account_id(),
            key,
        };
        near_plugins::events::AsEvent::emit(&event);
        true
    }
    fn pa_unpause_feature(&mut self, key: String) -> bool {
        let __acl_any_roles: Vec<&str> = <[_]>::into_vec(
            #[rustc_box]
            ::alloc::boxed::Box::new([Role::PauseManager.into(), Role::DAO.into()]),
        );
        let __acl_any_roles_ser: Vec<String> = __acl_any_roles
            .iter()
            .map(|&role| role.into())
            .collect();
        let __acl_any_account_id = ::near_sdk::env::predecessor_account_id();
        if !self.acl_has_any_role(__acl_any_roles_ser, __acl_any_account_id) {
            let message = {
                let res = ::alloc::fmt::format(
                    format_args!(
                        "Insufficient permissions for method {0} restricted by access control. Requires one of these roles: {1:?}",
                        "pa_unpause_feature",
                        __acl_any_roles,
                    ),
                );
                res
            };
            near_sdk::env::panic_str(&message);
        }
        let mut paused_keys = self.pa_all_paused().unwrap_or_default();
        let was_paused = paused_keys.remove(&key);
        if !was_paused {
            return false;
        }
        if paused_keys.is_empty() {
            ::near_sdk::env::storage_remove(self.pa_storage_key().as_ref());
        } else {
            ::near_sdk::env::storage_write(
                self.pa_storage_key().as_ref(),
                paused_keys
                    .try_to_vec()
                    .unwrap_or_else(|_| ::near_sdk::env::panic_str(
                        "Pausable: Unexpected error serializing keys",
                    ))
                    .as_ref(),
            );
        }
        let event = near_plugins::pausable::Unpause {
            by: ::near_sdk::env::predecessor_account_id(),
            key,
        };
        near_plugins::events::AsEvent::emit(&event);
        true
    }
}
#[cfg(target_arch = "wasm32")]
#[no_mangle]
pub extern "C" fn pa_storage_key() {
    near_sdk::env::setup_panic_hook();
    let contract: FastBridge = near_sdk::env::state_read().unwrap_or_default();
    let result = contract.pa_storage_key();
    let result = near_sdk::serde_json::to_vec(&result)
        .expect("Failed to serialize the return value using JSON.");
    near_sdk::env::value_return(&result);
}
#[cfg(target_arch = "wasm32")]
#[no_mangle]
pub extern "C" fn pa_is_paused() {
    near_sdk::env::setup_panic_hook();
    #[serde(crate = "near_sdk::serde")]
    struct Input {
        key: String,
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        use near_sdk::serde as _serde;
        #[automatically_derived]
        impl<'de> near_sdk::serde::Deserialize<'de> for Input {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> near_sdk::serde::__private::Result<Self, __D::Error>
            where
                __D: near_sdk::serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "key" => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"key" => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<Input>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = Input;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct Input",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct Input with 1 element",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(Input { key: __field0 })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = match _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("key"),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<
                                            String,
                                        >(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                _ => {
                                    let _ = match _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("key") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        _serde::__private::Ok(Input { key: __field0 })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &["key"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "Input",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<Input>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    let Input { key }: Input = near_sdk::serde_json::from_slice(
            &near_sdk::env::input().expect("Expected input since method has arguments."),
        )
        .expect("Failed to deserialize input from JSON.");
    let contract: FastBridge = near_sdk::env::state_read().unwrap_or_default();
    let result = contract.pa_is_paused(key);
    let result = near_sdk::serde_json::to_vec(&result)
        .expect("Failed to serialize the return value using JSON.");
    near_sdk::env::value_return(&result);
}
#[cfg(target_arch = "wasm32")]
#[no_mangle]
pub extern "C" fn pa_all_paused() {
    near_sdk::env::setup_panic_hook();
    let contract: FastBridge = near_sdk::env::state_read().unwrap_or_default();
    let result = contract.pa_all_paused();
    let result = near_sdk::serde_json::to_vec(&result)
        .expect("Failed to serialize the return value using JSON.");
    near_sdk::env::value_return(&result);
}
#[cfg(target_arch = "wasm32")]
#[no_mangle]
pub extern "C" fn pa_pause_feature() {
    near_sdk::env::setup_panic_hook();
    if near_sdk::env::attached_deposit() != 0 {
        near_sdk::env::panic_str("Method pa_pause_feature doesn't accept deposit");
    }
    #[serde(crate = "near_sdk::serde")]
    struct Input {
        key: String,
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        use near_sdk::serde as _serde;
        #[automatically_derived]
        impl<'de> near_sdk::serde::Deserialize<'de> for Input {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> near_sdk::serde::__private::Result<Self, __D::Error>
            where
                __D: near_sdk::serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "key" => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"key" => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<Input>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = Input;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct Input",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct Input with 1 element",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(Input { key: __field0 })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = match _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("key"),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<
                                            String,
                                        >(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                _ => {
                                    let _ = match _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("key") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        _serde::__private::Ok(Input { key: __field0 })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &["key"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "Input",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<Input>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    let Input { key }: Input = near_sdk::serde_json::from_slice(
            &near_sdk::env::input().expect("Expected input since method has arguments."),
        )
        .expect("Failed to deserialize input from JSON.");
    let mut contract: FastBridge = near_sdk::env::state_read().unwrap_or_default();
    let result = contract.pa_pause_feature(key);
    let result = near_sdk::serde_json::to_vec(&result)
        .expect("Failed to serialize the return value using JSON.");
    near_sdk::env::value_return(&result);
    near_sdk::env::state_write(&contract);
}
#[cfg(target_arch = "wasm32")]
#[no_mangle]
pub extern "C" fn pa_unpause_feature() {
    near_sdk::env::setup_panic_hook();
    if near_sdk::env::attached_deposit() != 0 {
        near_sdk::env::panic_str("Method pa_unpause_feature doesn't accept deposit");
    }
    #[serde(crate = "near_sdk::serde")]
    struct Input {
        key: String,
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        use near_sdk::serde as _serde;
        #[automatically_derived]
        impl<'de> near_sdk::serde::Deserialize<'de> for Input {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> near_sdk::serde::__private::Result<Self, __D::Error>
            where
                __D: near_sdk::serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "key" => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"key" => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<Input>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = Input;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct Input",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct Input with 1 element",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(Input { key: __field0 })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = match _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("key"),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<
                                            String,
                                        >(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                _ => {
                                    let _ = match _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("key") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        _serde::__private::Ok(Input { key: __field0 })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &["key"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "Input",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<Input>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    let Input { key }: Input = near_sdk::serde_json::from_slice(
            &near_sdk::env::input().expect("Expected input since method has arguments."),
        )
        .expect("Failed to deserialize input from JSON.");
    let mut contract: FastBridge = near_sdk::env::state_read().unwrap_or_default();
    let result = contract.pa_unpause_feature(key);
    let result = near_sdk::serde_json::to_vec(&result)
        .expect("Failed to serialize the return value using JSON.");
    near_sdk::env::value_return(&result);
    near_sdk::env::state_write(&contract);
}
/// Used to make storage prefixes unique. Not to be used directly,
/// instead it should be prepended to the storage prefix specified by
/// the user.
enum __UpgradableStorageKey {
    Code,
    StagingTimestamp,
    StagingDuration,
    NewStagingDuration,
    NewStagingDurationTimestamp,
}
impl borsh::ser::BorshSerialize for __UpgradableStorageKey {
    fn serialize<W: borsh::maybestd::io::Write>(
        &self,
        writer: &mut W,
    ) -> core::result::Result<(), borsh::maybestd::io::Error> {
        let variant_idx: u8 = match self {
            __UpgradableStorageKey::Code => 0u8,
            __UpgradableStorageKey::StagingTimestamp => 1u8,
            __UpgradableStorageKey::StagingDuration => 2u8,
            __UpgradableStorageKey::NewStagingDuration => 3u8,
            __UpgradableStorageKey::NewStagingDurationTimestamp => 4u8,
        };
        writer.write_all(&variant_idx.to_le_bytes())?;
        match self {
            __UpgradableStorageKey::Code => {}
            __UpgradableStorageKey::StagingTimestamp => {}
            __UpgradableStorageKey::StagingDuration => {}
            __UpgradableStorageKey::NewStagingDuration => {}
            __UpgradableStorageKey::NewStagingDurationTimestamp => {}
        }
        Ok(())
    }
}
impl FastBridge {
    fn up_get_timestamp(
        &self,
        key: __UpgradableStorageKey,
    ) -> Option<::near_sdk::Timestamp> {
        near_sdk::env::storage_read(self.up_storage_key(key).as_ref())
            .map(|timestamp_bytes| {
                ::near_sdk::Timestamp::try_from_slice(&timestamp_bytes)
                    .unwrap_or_else(|_| near_sdk::env::panic_str(
                        "Upgradable: Invalid u64 timestamp format",
                    ))
            })
    }
    fn up_get_duration(
        &self,
        key: __UpgradableStorageKey,
    ) -> Option<::near_sdk::Duration> {
        near_sdk::env::storage_read(self.up_storage_key(key).as_ref())
            .map(|duration_bytes| {
                ::near_sdk::Duration::try_from_slice(&duration_bytes)
                    .unwrap_or_else(|_| near_sdk::env::panic_str(
                        "Upgradable: Invalid u64 Duration format",
                    ))
            })
    }
    fn up_set_timestamp(
        &self,
        key: __UpgradableStorageKey,
        value: ::near_sdk::Timestamp,
    ) {
        self.up_storage_write(key, &value.try_to_vec().unwrap());
    }
    fn up_set_duration(&self, key: __UpgradableStorageKey, value: ::near_sdk::Duration) {
        self.up_storage_write(key, &value.try_to_vec().unwrap());
    }
    fn up_storage_key(&self, key: __UpgradableStorageKey) -> Vec<u8> {
        let key_vec = key
            .try_to_vec()
            .unwrap_or_else(|_| ::near_sdk::env::panic_str(
                "Storage key should be serializable",
            ));
        [("__up__").as_bytes(), key_vec.as_slice()].concat()
    }
    fn up_storage_write(&self, key: __UpgradableStorageKey, value: &[u8]) {
        near_sdk::env::storage_write(self.up_storage_key(key).as_ref(), &value);
    }
    fn up_set_staging_duration_unchecked(&self, staging_duration: near_sdk::Duration) {
        self.up_storage_write(
            __UpgradableStorageKey::StagingDuration,
            &staging_duration.try_to_vec().unwrap(),
        );
    }
}
impl FastBridgeExt {
    pub fn up_storage_prefix(self) -> near_sdk::Promise {
        let __args = ::alloc::vec::Vec::new();
        near_sdk::Promise::new(self.account_id)
            .function_call_weight(
                "up_storage_prefix".to_string(),
                __args,
                self.deposit,
                self.static_gas,
                self.gas_weight,
            )
    }
    pub fn up_get_delay_status(self) -> near_sdk::Promise {
        let __args = ::alloc::vec::Vec::new();
        near_sdk::Promise::new(self.account_id)
            .function_call_weight(
                "up_get_delay_status".to_string(),
                __args,
                self.deposit,
                self.static_gas,
                self.gas_weight,
            )
    }
    pub fn up_stage_code(self, code: Vec<u8>) -> near_sdk::Promise {
        let __args = {
            struct Input<'nearinput> {
                code: &'nearinput Vec<u8>,
            }
            impl<'nearinput> borsh::ser::BorshSerialize for Input<'nearinput>
            where
                &'nearinput Vec<u8>: borsh::ser::BorshSerialize,
            {
                fn serialize<W: borsh::maybestd::io::Write>(
                    &self,
                    writer: &mut W,
                ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
                    borsh::BorshSerialize::serialize(&self.code, writer)?;
                    Ok(())
                }
            }
            let __args = Input { code: &code };
            near_sdk::borsh::BorshSerialize::try_to_vec(&__args)
                .expect("Failed to serialize the cross contract args using Borsh.")
        };
        near_sdk::Promise::new(self.account_id)
            .function_call_weight(
                "up_stage_code".to_string(),
                __args,
                self.deposit,
                self.static_gas,
                self.gas_weight,
            )
    }
    pub fn up_staged_code(self) -> near_sdk::Promise {
        let __args = ::alloc::vec::Vec::new();
        near_sdk::Promise::new(self.account_id)
            .function_call_weight(
                "up_staged_code".to_string(),
                __args,
                self.deposit,
                self.static_gas,
                self.gas_weight,
            )
    }
    pub fn up_staged_code_hash(self) -> near_sdk::Promise {
        let __args = ::alloc::vec::Vec::new();
        near_sdk::Promise::new(self.account_id)
            .function_call_weight(
                "up_staged_code_hash".to_string(),
                __args,
                self.deposit,
                self.static_gas,
                self.gas_weight,
            )
    }
    pub fn up_deploy_code(
        self,
        function_call_args: Option<near_plugins::upgradable::FunctionCallArgs>,
    ) -> near_sdk::Promise {
        let __args = {
            #[serde(crate = "near_sdk::serde")]
            struct Input<'nearinput> {
                function_call_args: &'nearinput Option<
                    near_plugins::upgradable::FunctionCallArgs,
                >,
            }
            #[doc(hidden)]
            #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
            const _: () = {
                use near_sdk::serde as _serde;
                #[automatically_derived]
                impl<'nearinput> near_sdk::serde::Serialize for Input<'nearinput> {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> near_sdk::serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: near_sdk::serde::Serializer,
                    {
                        let mut __serde_state = match _serde::Serializer::serialize_struct(
                            __serializer,
                            "Input",
                            false as usize + 1,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "function_call_args",
                            &self.function_call_args,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            let __args = Input {
                function_call_args: &function_call_args,
            };
            near_sdk::serde_json::to_vec(&__args)
                .expect("Failed to serialize the cross contract args using JSON.")
        };
        near_sdk::Promise::new(self.account_id)
            .function_call_weight(
                "up_deploy_code".to_string(),
                __args,
                self.deposit,
                self.static_gas,
                self.gas_weight,
            )
    }
    pub fn up_init_staging_duration(
        self,
        staging_duration: near_sdk::Duration,
    ) -> near_sdk::Promise {
        let __args = {
            #[serde(crate = "near_sdk::serde")]
            struct Input<'nearinput> {
                staging_duration: &'nearinput near_sdk::Duration,
            }
            #[doc(hidden)]
            #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
            const _: () = {
                use near_sdk::serde as _serde;
                #[automatically_derived]
                impl<'nearinput> near_sdk::serde::Serialize for Input<'nearinput> {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> near_sdk::serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: near_sdk::serde::Serializer,
                    {
                        let mut __serde_state = match _serde::Serializer::serialize_struct(
                            __serializer,
                            "Input",
                            false as usize + 1,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "staging_duration",
                            &self.staging_duration,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            let __args = Input {
                staging_duration: &staging_duration,
            };
            near_sdk::serde_json::to_vec(&__args)
                .expect("Failed to serialize the cross contract args using JSON.")
        };
        near_sdk::Promise::new(self.account_id)
            .function_call_weight(
                "up_init_staging_duration".to_string(),
                __args,
                self.deposit,
                self.static_gas,
                self.gas_weight,
            )
    }
    pub fn up_stage_update_staging_duration(
        self,
        staging_duration: near_sdk::Duration,
    ) -> near_sdk::Promise {
        let __args = {
            #[serde(crate = "near_sdk::serde")]
            struct Input<'nearinput> {
                staging_duration: &'nearinput near_sdk::Duration,
            }
            #[doc(hidden)]
            #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
            const _: () = {
                use near_sdk::serde as _serde;
                #[automatically_derived]
                impl<'nearinput> near_sdk::serde::Serialize for Input<'nearinput> {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> near_sdk::serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: near_sdk::serde::Serializer,
                    {
                        let mut __serde_state = match _serde::Serializer::serialize_struct(
                            __serializer,
                            "Input",
                            false as usize + 1,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "staging_duration",
                            &self.staging_duration,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            let __args = Input {
                staging_duration: &staging_duration,
            };
            near_sdk::serde_json::to_vec(&__args)
                .expect("Failed to serialize the cross contract args using JSON.")
        };
        near_sdk::Promise::new(self.account_id)
            .function_call_weight(
                "up_stage_update_staging_duration".to_string(),
                __args,
                self.deposit,
                self.static_gas,
                self.gas_weight,
            )
    }
    pub fn up_apply_update_staging_duration(self) -> near_sdk::Promise {
        let __args = ::alloc::vec::Vec::new();
        near_sdk::Promise::new(self.account_id)
            .function_call_weight(
                "up_apply_update_staging_duration".to_string(),
                __args,
                self.deposit,
                self.static_gas,
                self.gas_weight,
            )
    }
}
impl Upgradable for FastBridge {
    fn up_storage_prefix(&self) -> &'static [u8] {
        ("__up__").as_bytes()
    }
    fn up_get_delay_status(&self) -> near_plugins::UpgradableDurationStatus {
        near_plugins::UpgradableDurationStatus {
            staging_duration: self
                .up_get_duration(__UpgradableStorageKey::StagingDuration),
            staging_timestamp: self
                .up_get_timestamp(__UpgradableStorageKey::StagingTimestamp),
            new_staging_duration: self
                .up_get_duration(__UpgradableStorageKey::NewStagingDuration),
            new_staging_duration_timestamp: self
                .up_get_timestamp(__UpgradableStorageKey::NewStagingDurationTimestamp),
        }
    }
    fn up_stage_code(&mut self, code: Vec<u8>) {
        let __acl_any_roles: Vec<&str> = <[_]>::into_vec(
            #[rustc_box]
            ::alloc::boxed::Box::new([Role::CodeStager.into(), Role::DAO.into()]),
        );
        let __acl_any_roles_ser: Vec<String> = __acl_any_roles
            .iter()
            .map(|&role| role.into())
            .collect();
        let __acl_any_account_id = ::near_sdk::env::predecessor_account_id();
        if !self.acl_has_any_role(__acl_any_roles_ser, __acl_any_account_id) {
            let message = {
                let res = ::alloc::fmt::format(
                    format_args!(
                        "Insufficient permissions for method {0} restricted by access control. Requires one of these roles: {1:?}",
                        "up_stage_code",
                        __acl_any_roles,
                    ),
                );
                res
            };
            near_sdk::env::panic_str(&message);
        }
        if code.is_empty() {
            near_sdk::env::storage_remove(
                self.up_storage_key(__UpgradableStorageKey::Code).as_ref(),
            );
            near_sdk::env::storage_remove(
                self.up_storage_key(__UpgradableStorageKey::StagingTimestamp).as_ref(),
            );
        } else {
            let timestamp = near_sdk::env::block_timestamp()
                + self
                    .up_get_duration(__UpgradableStorageKey::StagingDuration)
                    .unwrap_or(0);
            self.up_storage_write(__UpgradableStorageKey::Code, &code);
            self.up_set_timestamp(__UpgradableStorageKey::StagingTimestamp, timestamp);
        }
    }
    fn up_staged_code(&self) -> Option<Vec<u8>> {
        near_sdk::env::storage_read(
            self.up_storage_key(__UpgradableStorageKey::Code).as_ref(),
        )
    }
    fn up_staged_code_hash(&self) -> Option<::near_sdk::CryptoHash> {
        self.up_staged_code()
            .map(|code| {
                std::convert::TryInto::try_into(near_sdk::env::sha256(code.as_ref()))
                    .unwrap()
            })
    }
    fn up_deploy_code(
        &mut self,
        function_call_args: Option<near_plugins::upgradable::FunctionCallArgs>,
    ) -> near_sdk::Promise {
        let __acl_any_roles: Vec<&str> = <[_]>::into_vec(
            #[rustc_box]
            ::alloc::boxed::Box::new([Role::CodeDeployer.into(), Role::DAO.into()]),
        );
        let __acl_any_roles_ser: Vec<String> = __acl_any_roles
            .iter()
            .map(|&role| role.into())
            .collect();
        let __acl_any_account_id = ::near_sdk::env::predecessor_account_id();
        if !self.acl_has_any_role(__acl_any_roles_ser, __acl_any_account_id) {
            let message = {
                let res = ::alloc::fmt::format(
                    format_args!(
                        "Insufficient permissions for method {0} restricted by access control. Requires one of these roles: {1:?}",
                        "up_deploy_code",
                        __acl_any_roles,
                    ),
                );
                res
            };
            near_sdk::env::panic_str(&message);
        }
        let staging_timestamp = self
            .up_get_timestamp(__UpgradableStorageKey::StagingTimestamp)
            .unwrap_or_else(|| ::near_sdk::env::panic_str(
                "Upgradable: staging timestamp isn't set",
            ));
        if near_sdk::env::block_timestamp() < staging_timestamp {
            near_sdk::env::panic_str(
                {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "Upgradable: Deploy code too early: staging ends on {0}",
                            staging_timestamp,
                        ),
                    );
                    res
                }
                    .as_str(),
            );
        }
        let code = self
            .up_staged_code()
            .unwrap_or_else(|| ::near_sdk::env::panic_str("Upgradable: No staged code"));
        let promise = near_sdk::Promise::new(near_sdk::env::current_account_id())
            .deploy_contract(code);
        match function_call_args {
            None => promise,
            Some(args) => {
                promise
                    .function_call(
                        args.function_name,
                        args.arguments,
                        args.amount,
                        args.gas,
                    )
            }
        }
    }
    fn up_init_staging_duration(&mut self, staging_duration: near_sdk::Duration) {
        let __acl_any_roles: Vec<&str> = <[_]>::into_vec(
            #[rustc_box]
            ::alloc::boxed::Box::new([Role::DurationManager.into(), Role::DAO.into()]),
        );
        let __acl_any_roles_ser: Vec<String> = __acl_any_roles
            .iter()
            .map(|&role| role.into())
            .collect();
        let __acl_any_account_id = ::near_sdk::env::predecessor_account_id();
        if !self.acl_has_any_role(__acl_any_roles_ser, __acl_any_account_id) {
            let message = {
                let res = ::alloc::fmt::format(
                    format_args!(
                        "Insufficient permissions for method {0} restricted by access control. Requires one of these roles: {1:?}",
                        "up_init_staging_duration",
                        __acl_any_roles,
                    ),
                );
                res
            };
            near_sdk::env::panic_str(&message);
        }
        if true {
            let msg: &str = &"Upgradable: staging duration was already initialized";
            if !self.up_get_duration(__UpgradableStorageKey::StagingDuration).is_none() {
                {
                    ::core::panicking::panic_display(&msg);
                }
            }
        } else if !self
            .up_get_duration(__UpgradableStorageKey::StagingDuration)
            .is_none()
        {
            ::near_sdk::env::panic_str(
                &"Upgradable: staging duration was already initialized",
            )
        }
        self.up_set_staging_duration_unchecked(staging_duration);
    }
    fn up_stage_update_staging_duration(
        &mut self,
        staging_duration: near_sdk::Duration,
    ) {
        let __acl_any_roles: Vec<&str> = <[_]>::into_vec(
            #[rustc_box]
            ::alloc::boxed::Box::new([Role::DurationManager.into(), Role::DAO.into()]),
        );
        let __acl_any_roles_ser: Vec<String> = __acl_any_roles
            .iter()
            .map(|&role| role.into())
            .collect();
        let __acl_any_account_id = ::near_sdk::env::predecessor_account_id();
        if !self.acl_has_any_role(__acl_any_roles_ser, __acl_any_account_id) {
            let message = {
                let res = ::alloc::fmt::format(
                    format_args!(
                        "Insufficient permissions for method {0} restricted by access control. Requires one of these roles: {1:?}",
                        "up_stage_update_staging_duration",
                        __acl_any_roles,
                    ),
                );
                res
            };
            near_sdk::env::panic_str(&message);
        }
        let current_staging_duration = self
            .up_get_duration(__UpgradableStorageKey::StagingDuration)
            .unwrap_or_else(|| ::near_sdk::env::panic_str(
                "Upgradable: staging duration isn't initialized",
            ));
        self.up_set_duration(
            __UpgradableStorageKey::NewStagingDuration,
            staging_duration,
        );
        let staging_duration_timestamp = near_sdk::env::block_timestamp()
            + current_staging_duration;
        self.up_set_timestamp(
            __UpgradableStorageKey::NewStagingDurationTimestamp,
            staging_duration_timestamp,
        );
    }
    fn up_apply_update_staging_duration(&mut self) {
        let __acl_any_roles: Vec<&str> = <[_]>::into_vec(
            #[rustc_box]
            ::alloc::boxed::Box::new([Role::DurationManager.into(), Role::DAO.into()]),
        );
        let __acl_any_roles_ser: Vec<String> = __acl_any_roles
            .iter()
            .map(|&role| role.into())
            .collect();
        let __acl_any_account_id = ::near_sdk::env::predecessor_account_id();
        if !self.acl_has_any_role(__acl_any_roles_ser, __acl_any_account_id) {
            let message = {
                let res = ::alloc::fmt::format(
                    format_args!(
                        "Insufficient permissions for method {0} restricted by access control. Requires one of these roles: {1:?}",
                        "up_apply_update_staging_duration",
                        __acl_any_roles,
                    ),
                );
                res
            };
            near_sdk::env::panic_str(&message);
        }
        let staging_timestamp = self
            .up_get_timestamp(__UpgradableStorageKey::NewStagingDurationTimestamp)
            .unwrap_or_else(|| ::near_sdk::env::panic_str(
                "Upgradable: No staged update",
            ));
        if near_sdk::env::block_timestamp() < staging_timestamp {
            near_sdk::env::panic_str(
                {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "Upgradable: Update duration too early: staging ends on {0}",
                            staging_timestamp,
                        ),
                    );
                    res
                }
                    .as_str(),
            );
        }
        let new_duration = self
            .up_get_duration(__UpgradableStorageKey::NewStagingDuration)
            .unwrap_or_else(|| ::near_sdk::env::panic_str(
                "Upgradable: No staged duration update",
            ));
        self.up_set_duration(__UpgradableStorageKey::StagingDuration, new_duration);
    }
}
#[cfg(target_arch = "wasm32")]
#[no_mangle]
pub extern "C" fn up_storage_prefix() {
    near_sdk::env::setup_panic_hook();
    let contract: FastBridge = near_sdk::env::state_read().unwrap_or_default();
    let result = contract.up_storage_prefix();
    let result = near_sdk::serde_json::to_vec(&result)
        .expect("Failed to serialize the return value using JSON.");
    near_sdk::env::value_return(&result);
}
#[cfg(target_arch = "wasm32")]
#[no_mangle]
pub extern "C" fn up_get_delay_status() {
    near_sdk::env::setup_panic_hook();
    let contract: FastBridge = near_sdk::env::state_read().unwrap_or_default();
    let result = contract.up_get_delay_status();
    let result = near_sdk::serde_json::to_vec(&result)
        .expect("Failed to serialize the return value using JSON.");
    near_sdk::env::value_return(&result);
}
#[cfg(target_arch = "wasm32")]
#[no_mangle]
pub extern "C" fn up_stage_code() {
    near_sdk::env::setup_panic_hook();
    if near_sdk::env::attached_deposit() != 0 {
        near_sdk::env::panic_str("Method up_stage_code doesn't accept deposit");
    }
    struct Input {
        code: Vec<u8>,
    }
    impl borsh::de::BorshDeserialize for Input
    where
        Vec<u8>: borsh::BorshDeserialize,
    {
        fn deserialize(
            buf: &mut &[u8],
        ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
            Ok(Self {
                code: borsh::BorshDeserialize::deserialize(buf)?,
            })
        }
    }
    let Input { code }: Input = near_sdk::borsh::BorshDeserialize::try_from_slice(
            &near_sdk::env::input().expect("Expected input since method has arguments."),
        )
        .expect("Failed to deserialize input from Borsh.");
    let mut contract: FastBridge = near_sdk::env::state_read().unwrap_or_default();
    contract.up_stage_code(code);
    near_sdk::env::state_write(&contract);
}
#[cfg(target_arch = "wasm32")]
#[no_mangle]
pub extern "C" fn up_staged_code() {
    near_sdk::env::setup_panic_hook();
    let contract: FastBridge = near_sdk::env::state_read().unwrap_or_default();
    let result = contract.up_staged_code();
    let result = near_sdk::borsh::BorshSerialize::try_to_vec(&result)
        .expect("Failed to serialize the return value using Borsh.");
    near_sdk::env::value_return(&result);
}
#[cfg(target_arch = "wasm32")]
#[no_mangle]
pub extern "C" fn up_staged_code_hash() {
    near_sdk::env::setup_panic_hook();
    let contract: FastBridge = near_sdk::env::state_read().unwrap_or_default();
    let result = contract.up_staged_code_hash();
    let result = near_sdk::serde_json::to_vec(&result)
        .expect("Failed to serialize the return value using JSON.");
    near_sdk::env::value_return(&result);
}
#[cfg(target_arch = "wasm32")]
#[no_mangle]
pub extern "C" fn up_deploy_code() {
    near_sdk::env::setup_panic_hook();
    if near_sdk::env::attached_deposit() != 0 {
        near_sdk::env::panic_str("Method up_deploy_code doesn't accept deposit");
    }
    #[serde(crate = "near_sdk::serde")]
    struct Input {
        function_call_args: Option<near_plugins::upgradable::FunctionCallArgs>,
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        use near_sdk::serde as _serde;
        #[automatically_derived]
        impl<'de> near_sdk::serde::Deserialize<'de> for Input {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> near_sdk::serde::__private::Result<Self, __D::Error>
            where
                __D: near_sdk::serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "function_call_args" => {
                                _serde::__private::Ok(__Field::__field0)
                            }
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"function_call_args" => {
                                _serde::__private::Ok(__Field::__field0)
                            }
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<Input>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = Input;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct Input",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match match _serde::de::SeqAccess::next_element::<
                            Option<near_plugins::upgradable::FunctionCallArgs>,
                        >(&mut __seq) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct Input with 1 element",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(Input {
                            function_call_args: __field0,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<
                            Option<near_plugins::upgradable::FunctionCallArgs>,
                        > = _serde::__private::None;
                        while let _serde::__private::Some(__key) = match _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "function_call_args",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<
                                            Option<near_plugins::upgradable::FunctionCallArgs>,
                                        >(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                _ => {
                                    let _ = match _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field(
                                    "function_call_args",
                                ) {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        _serde::__private::Ok(Input {
                            function_call_args: __field0,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &["function_call_args"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "Input",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<Input>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    let Input { function_call_args }: Input = near_sdk::serde_json::from_slice(
            &near_sdk::env::input().expect("Expected input since method has arguments."),
        )
        .expect("Failed to deserialize input from JSON.");
    let mut contract: FastBridge = near_sdk::env::state_read().unwrap_or_default();
    let result = contract.up_deploy_code(function_call_args);
    let result = near_sdk::serde_json::to_vec(&result)
        .expect("Failed to serialize the return value using JSON.");
    near_sdk::env::value_return(&result);
    near_sdk::env::state_write(&contract);
}
#[cfg(target_arch = "wasm32")]
#[no_mangle]
pub extern "C" fn up_init_staging_duration() {
    near_sdk::env::setup_panic_hook();
    if near_sdk::env::attached_deposit() != 0 {
        near_sdk::env::panic_str(
            "Method up_init_staging_duration doesn't accept deposit",
        );
    }
    #[serde(crate = "near_sdk::serde")]
    struct Input {
        staging_duration: near_sdk::Duration,
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        use near_sdk::serde as _serde;
        #[automatically_derived]
        impl<'de> near_sdk::serde::Deserialize<'de> for Input {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> near_sdk::serde::__private::Result<Self, __D::Error>
            where
                __D: near_sdk::serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "staging_duration" => {
                                _serde::__private::Ok(__Field::__field0)
                            }
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"staging_duration" => {
                                _serde::__private::Ok(__Field::__field0)
                            }
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<Input>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = Input;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct Input",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match match _serde::de::SeqAccess::next_element::<
                            near_sdk::Duration,
                        >(&mut __seq) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct Input with 1 element",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(Input {
                            staging_duration: __field0,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<
                            near_sdk::Duration,
                        > = _serde::__private::None;
                        while let _serde::__private::Some(__key) = match _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "staging_duration",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<
                                            near_sdk::Duration,
                                        >(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                _ => {
                                    let _ = match _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field(
                                    "staging_duration",
                                ) {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        _serde::__private::Ok(Input {
                            staging_duration: __field0,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &["staging_duration"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "Input",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<Input>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    let Input { staging_duration }: Input = near_sdk::serde_json::from_slice(
            &near_sdk::env::input().expect("Expected input since method has arguments."),
        )
        .expect("Failed to deserialize input from JSON.");
    let mut contract: FastBridge = near_sdk::env::state_read().unwrap_or_default();
    contract.up_init_staging_duration(staging_duration);
    near_sdk::env::state_write(&contract);
}
#[cfg(target_arch = "wasm32")]
#[no_mangle]
pub extern "C" fn up_stage_update_staging_duration() {
    near_sdk::env::setup_panic_hook();
    if near_sdk::env::attached_deposit() != 0 {
        near_sdk::env::panic_str(
            "Method up_stage_update_staging_duration doesn't accept deposit",
        );
    }
    #[serde(crate = "near_sdk::serde")]
    struct Input {
        staging_duration: near_sdk::Duration,
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        use near_sdk::serde as _serde;
        #[automatically_derived]
        impl<'de> near_sdk::serde::Deserialize<'de> for Input {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> near_sdk::serde::__private::Result<Self, __D::Error>
            where
                __D: near_sdk::serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "staging_duration" => {
                                _serde::__private::Ok(__Field::__field0)
                            }
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"staging_duration" => {
                                _serde::__private::Ok(__Field::__field0)
                            }
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<Input>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = Input;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct Input",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match match _serde::de::SeqAccess::next_element::<
                            near_sdk::Duration,
                        >(&mut __seq) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct Input with 1 element",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(Input {
                            staging_duration: __field0,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<
                            near_sdk::Duration,
                        > = _serde::__private::None;
                        while let _serde::__private::Some(__key) = match _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "staging_duration",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<
                                            near_sdk::Duration,
                                        >(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                _ => {
                                    let _ = match _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field(
                                    "staging_duration",
                                ) {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        _serde::__private::Ok(Input {
                            staging_duration: __field0,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &["staging_duration"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "Input",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<Input>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    let Input { staging_duration }: Input = near_sdk::serde_json::from_slice(
            &near_sdk::env::input().expect("Expected input since method has arguments."),
        )
        .expect("Failed to deserialize input from JSON.");
    let mut contract: FastBridge = near_sdk::env::state_read().unwrap_or_default();
    contract.up_stage_update_staging_duration(staging_duration);
    near_sdk::env::state_write(&contract);
}
#[cfg(target_arch = "wasm32")]
#[no_mangle]
pub extern "C" fn up_apply_update_staging_duration() {
    near_sdk::env::setup_panic_hook();
    if near_sdk::env::attached_deposit() != 0 {
        near_sdk::env::panic_str(
            "Method up_apply_update_staging_duration doesn't accept deposit",
        );
    }
    let mut contract: FastBridge = near_sdk::env::state_read().unwrap_or_default();
    contract.up_apply_update_staging_duration();
    near_sdk::env::state_write(&contract);
}
#[must_use]
pub struct FastBridgeExt {
    pub(crate) account_id: near_sdk::AccountId,
    pub(crate) deposit: near_sdk::Balance,
    pub(crate) static_gas: near_sdk::Gas,
    pub(crate) gas_weight: near_sdk::GasWeight,
}
impl FastBridgeExt {
    pub fn with_attached_deposit(mut self, amount: near_sdk::Balance) -> Self {
        self.deposit = amount;
        self
    }
    pub fn with_static_gas(mut self, static_gas: near_sdk::Gas) -> Self {
        self.static_gas = static_gas;
        self
    }
    pub fn with_unused_gas_weight(mut self, gas_weight: u64) -> Self {
        self.gas_weight = near_sdk::GasWeight(gas_weight);
        self
    }
}
impl FastBridge {
    /// API for calling this contract's functions in a subsequent execution.
    pub fn ext(account_id: near_sdk::AccountId) -> FastBridgeExt {
        FastBridgeExt {
            account_id,
            deposit: 0,
            static_gas: near_sdk::Gas(0),
            gas_weight: near_sdk::GasWeight::default(),
        }
    }
}
struct __Acl {
    /// Stores permissions per account.
    permissions: ::near_sdk::store::UnorderedMap<::near_sdk::AccountId, RoleFlags>,
    /// Stores the set of accounts that bear a permission.
    bearers: ::near_sdk::store::UnorderedMap<
        RoleFlags,
        ::near_sdk::store::UnorderedSet<::near_sdk::AccountId>,
    >,
}
impl borsh::de::BorshDeserialize for __Acl
where
    ::near_sdk::store::UnorderedMap<
        ::near_sdk::AccountId,
        RoleFlags,
    >: borsh::BorshDeserialize,
    ::near_sdk::store::UnorderedMap<
        RoleFlags,
        ::near_sdk::store::UnorderedSet<::near_sdk::AccountId>,
    >: borsh::BorshDeserialize,
{
    fn deserialize(
        buf: &mut &[u8],
    ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
        Ok(Self {
            permissions: borsh::BorshDeserialize::deserialize(buf)?,
            bearers: borsh::BorshDeserialize::deserialize(buf)?,
        })
    }
}
impl borsh::ser::BorshSerialize for __Acl
where
    ::near_sdk::store::UnorderedMap<
        ::near_sdk::AccountId,
        RoleFlags,
    >: borsh::ser::BorshSerialize,
    ::near_sdk::store::UnorderedMap<
        RoleFlags,
        ::near_sdk::store::UnorderedSet<::near_sdk::AccountId>,
    >: borsh::ser::BorshSerialize,
{
    fn serialize<W: borsh::maybestd::io::Write>(
        &self,
        writer: &mut W,
    ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
        borsh::BorshSerialize::serialize(&self.permissions, writer)?;
        borsh::BorshSerialize::serialize(&self.bearers, writer)?;
        Ok(())
    }
}
impl Default for __Acl {
    fn default() -> Self {
        let base_prefix = <FastBridge as AccessControllable>::acl_storage_prefix();
        Self {
            permissions: ::near_sdk::store::UnorderedMap::new(
                __acl_storage_prefix(base_prefix, __AclStorageKey::Permissions),
            ),
            bearers: ::near_sdk::store::UnorderedMap::new(
                __acl_storage_prefix(base_prefix, __AclStorageKey::Bearers),
            ),
        }
    }
}
/// Used to make storage prefixes unique. Not to be used directly,
/// instead it should be prepended to the storage prefix specified by
/// the user.
enum __AclStorageKey {
    Permissions,
    Bearers,
    BearersSet { permission: RoleFlags },
    AclStorage,
}
impl borsh::ser::BorshSerialize for __AclStorageKey
where
    RoleFlags: borsh::ser::BorshSerialize,
{
    fn serialize<W: borsh::maybestd::io::Write>(
        &self,
        writer: &mut W,
    ) -> core::result::Result<(), borsh::maybestd::io::Error> {
        let variant_idx: u8 = match self {
            __AclStorageKey::Permissions => 0u8,
            __AclStorageKey::Bearers => 1u8,
            __AclStorageKey::BearersSet { .. } => 2u8,
            __AclStorageKey::AclStorage => 3u8,
        };
        writer.write_all(&variant_idx.to_le_bytes())?;
        match self {
            __AclStorageKey::Permissions => {}
            __AclStorageKey::Bearers => {}
            __AclStorageKey::BearersSet { permission } => {
                borsh::BorshSerialize::serialize(permission, writer)?;
            }
            __AclStorageKey::AclStorage => {}
        }
        Ok(())
    }
}
/// Generates a prefix by concatenating the input parameters.
fn __acl_storage_prefix(base: &[u8], specifier: __AclStorageKey) -> Vec<u8> {
    let specifier = specifier
        .try_to_vec()
        .unwrap_or_else(|_| ::near_sdk::env::panic_str(
            "Storage key should be serializable",
        ));
    [base, specifier.as_slice()].concat()
}
impl FastBridge {
    fn acl_get_storage(&self) -> Option<__Acl> {
        let base_prefix = <FastBridge as AccessControllable>::acl_storage_prefix();
        near_sdk::env::storage_read(
                &__acl_storage_prefix(base_prefix, __AclStorageKey::AclStorage),
            )
            .map(|acl_storage_bytes| {
                __Acl::try_from_slice(&acl_storage_bytes)
                    .unwrap_or_else(|_| near_sdk::env::panic_str(
                        "ACL: invalid acl storage format",
                    ))
            })
    }
    fn acl_get_or_init(&mut self) -> __Acl {
        self.acl_get_storage().unwrap_or_else(|| self.acl_init_storage_unchecked())
    }
    fn acl_init_storage_unchecked(&mut self) -> __Acl {
        let base_prefix = <FastBridge as AccessControllable>::acl_storage_prefix();
        let acl_storage: __Acl = Default::default();
        near_sdk::env::storage_write(
            &__acl_storage_prefix(base_prefix, __AclStorageKey::AclStorage),
            &acl_storage.try_to_vec().unwrap(),
        );
        acl_storage
    }
}
impl __Acl {
    fn new_bearers_set(
        permission: RoleFlags,
    ) -> ::near_sdk::store::UnorderedSet<::near_sdk::AccountId> {
        let base_prefix = <FastBridge as AccessControllable>::acl_storage_prefix();
        let specifier = __AclStorageKey::BearersSet {
            permission,
        };
        ::near_sdk::store::UnorderedSet::new(
            __acl_storage_prefix(base_prefix, specifier),
        )
    }
    fn get_or_insert_permissions(
        &mut self,
        account_id: ::near_sdk::AccountId,
    ) -> &mut RoleFlags {
        self.permissions.entry(account_id).or_insert_with(|| RoleFlags::empty())
    }
    fn init_super_admin(&mut self, account_id: &::near_sdk::AccountId) -> bool {
        let permission = <RoleFlags>::from_bits(<Role>::acl_super_admin_permission())
            .unwrap_or_else(|| ::near_sdk::env::panic_str(
                "Value does not correspond to a permission",
            ));
        let super_admins = self.get_bearers(permission, 0, 1);
        if super_admins.len() > 0 {
            return false;
        }
        let res = self.add_super_admin_unchecked(account_id);
        if true {
            let msg: &str = &"Failed to init super-admin.";
            if !res {
                {
                    ::core::panicking::panic_display(&msg);
                }
            }
        } else if !res {
            ::near_sdk::env::panic_str(&"Failed to init super-admin.")
        }
        res
    }
    fn add_super_admin(&mut self, account_id: &::near_sdk::AccountId) -> Option<bool> {
        if !self.is_super_admin(&::near_sdk::env::predecessor_account_id()) {
            return None;
        }
        Some(self.add_super_admin_unchecked(account_id))
    }
    /// Makes `account_id` a super-admin __without__ checking any permissions.
    /// It returns whether `account_id` is a new super-admin.
    ///
    /// Note that there may be zero or more super-admins.
    fn add_super_admin_unchecked(&mut self, account_id: &::near_sdk::AccountId) -> bool {
        let flag = <RoleFlags>::from_bits(<Role>::acl_super_admin_permission())
            .unwrap_or_else(|| ::near_sdk::env::panic_str(
                "Value does not correspond to a permission",
            ));
        let mut permissions = self.get_or_insert_permissions(account_id.clone());
        let is_new_super_admin = !permissions.contains(flag);
        if is_new_super_admin {
            permissions.insert(flag);
            self.add_bearer(flag, account_id);
            let event = near_plugins::access_controllable::events::SuperAdminAdded {
                account: account_id.clone(),
                by: ::near_sdk::env::predecessor_account_id(),
            };
            near_plugins::events::AsEvent::emit(&event);
        }
        is_new_super_admin
    }
    fn is_super_admin(&self, account_id: &::near_sdk::AccountId) -> bool {
        let permissions = {
            match self.permissions.get(account_id) {
                Some(permissions) => permissions,
                None => return false,
            }
        };
        let super_admin = <RoleFlags>::from_bits(<Role>::acl_super_admin_permission())
            .unwrap_or_else(|| ::near_sdk::env::panic_str(
                "Value does not correspond to a permission",
            ));
        permissions.contains(super_admin)
    }
    fn revoke_super_admin(
        &mut self,
        account_id: &::near_sdk::AccountId,
    ) -> Option<bool> {
        if !self.is_super_admin(&::near_sdk::env::predecessor_account_id()) {
            return None;
        }
        Some(self.revoke_super_admin_unchecked(account_id))
    }
    fn transfer_super_admin(
        &mut self,
        account_id: &::near_sdk::AccountId,
    ) -> Option<bool> {
        let current_super_admin = ::near_sdk::env::predecessor_account_id();
        if !self.is_super_admin(&current_super_admin) {
            return None;
        }
        if account_id == &current_super_admin {
            return Some(true);
        }
        let is_new_super_admin = self.add_super_admin_unchecked(account_id);
        self.revoke_super_admin_unchecked(&current_super_admin);
        Some(is_new_super_admin)
    }
    /// Revokes super-admin permissions from `account_id` without checking any
    /// permissions. It returns whether `account_id` was a super-admin.
    fn revoke_super_admin_unchecked(
        &mut self,
        account_id: &::near_sdk::AccountId,
    ) -> bool {
        let flag = <RoleFlags>::from_bits(<Role>::acl_super_admin_permission())
            .unwrap_or_else(|| ::near_sdk::env::panic_str(
                "Value does not correspond to a permission",
            ));
        let mut permissions = match self.permissions.get_mut(account_id) {
            Some(permissions) => permissions,
            None => return false,
        };
        let was_super_admin = permissions.contains(flag);
        if was_super_admin {
            permissions.remove(flag);
            self.remove_bearer(flag, account_id);
            let event = near_plugins::access_controllable::events::SuperAdminRevoked {
                account: account_id.clone(),
                by: ::near_sdk::env::predecessor_account_id(),
            };
            near_plugins::events::AsEvent::emit(&event);
        }
        was_super_admin
    }
    fn add_admin(
        &mut self,
        role: Role,
        account_id: &::near_sdk::AccountId,
    ) -> Option<bool> {
        if !self.is_admin(role, &::near_sdk::env::predecessor_account_id()) {
            return None;
        }
        Some(self.add_admin_unchecked(role, account_id))
    }
    /// Makes `account_id` an admin for role, __without__ checking any
    /// permissions. Returns whether `account_id` is a new admin for `role`.
    ///
    /// Note that any role may have multiple (or zero) admins.
    fn add_admin_unchecked(
        &mut self,
        role: Role,
        account_id: &::near_sdk::AccountId,
    ) -> bool {
        let flag = <RoleFlags>::from_bits(role.acl_admin_permission())
            .unwrap_or_else(|| ::near_sdk::env::panic_str(
                "Value does not correspond to a permission",
            ));
        let mut permissions = self.get_or_insert_permissions(account_id.clone());
        let is_new_admin = !permissions.contains(flag);
        if is_new_admin {
            permissions.insert(flag);
            self.add_bearer(flag, account_id);
            let event = near_plugins::access_controllable::events::AdminAdded {
                role: role.into(),
                account: account_id.clone(),
                by: ::near_sdk::env::predecessor_account_id(),
            };
            near_plugins::events::AsEvent::emit(&event);
        }
        is_new_admin
    }
    fn is_admin(&self, role: Role, account_id: &::near_sdk::AccountId) -> bool {
        let permissions = {
            match self.permissions.get(account_id) {
                Some(permissions) => permissions,
                None => return false,
            }
        };
        let super_admin = <RoleFlags>::from_bits(<Role>::acl_super_admin_permission())
            .unwrap_or_else(|| ::near_sdk::env::panic_str(
                "Value does not correspond to a permission",
            ));
        let role_admin = <RoleFlags>::from_bits(role.acl_admin_permission())
            .unwrap_or_else(|| ::near_sdk::env::panic_str(
                "Value does not correspond to a permission",
            ));
        permissions.contains(super_admin) || permissions.contains(role_admin)
    }
    fn revoke_admin(
        &mut self,
        role: Role,
        account_id: &::near_sdk::AccountId,
    ) -> Option<bool> {
        if !self.is_admin(role, &::near_sdk::env::predecessor_account_id()) {
            return None;
        }
        Some(self.revoke_admin_unchecked(role, account_id))
    }
    fn renounce_admin(&mut self, role: Role) -> bool {
        self.revoke_admin_unchecked(role, &::near_sdk::env::predecessor_account_id())
    }
    /// Revokes admin permissions from `account_id` __without__ checking any
    /// permissions. Returns whether `account_id` was an admin for `role`.
    fn revoke_admin_unchecked(
        &mut self,
        role: Role,
        account_id: &::near_sdk::AccountId,
    ) -> bool {
        let flag = <RoleFlags>::from_bits(role.acl_admin_permission())
            .unwrap_or_else(|| ::near_sdk::env::panic_str(
                "Value does not correspond to a permission",
            ));
        let mut permissions = match self.permissions.get_mut(account_id) {
            Some(permissions) => permissions,
            None => return false,
        };
        let was_admin = permissions.contains(flag);
        if was_admin {
            permissions.remove(flag);
            self.remove_bearer(flag, account_id);
            let event = near_plugins::access_controllable::events::AdminRevoked {
                role: role.into(),
                account: account_id.clone(),
                by: ::near_sdk::env::predecessor_account_id(),
            };
            near_plugins::events::AsEvent::emit(&event);
        }
        was_admin
    }
    fn grant_role(
        &mut self,
        role: Role,
        account_id: &::near_sdk::AccountId,
    ) -> Option<bool> {
        if !self.is_admin(role, &::near_sdk::env::predecessor_account_id()) {
            return None;
        }
        Some(self.grant_role_unchecked(role, account_id))
    }
    /// Grants `role` to `account_id` __without__ checking any permissions.
    /// Returns whether `role` was newly granted to `account_id`.
    fn grant_role_unchecked(
        &mut self,
        role: Role,
        account_id: &::near_sdk::AccountId,
    ) -> bool {
        let flag = <RoleFlags>::from_bits(role.acl_permission())
            .unwrap_or_else(|| ::near_sdk::env::panic_str(
                "Value does not correspond to a permission",
            ));
        let mut permissions = self.get_or_insert_permissions(account_id.clone());
        let is_new_grantee = !permissions.contains(flag);
        if is_new_grantee {
            permissions.insert(flag);
            self.add_bearer(flag, account_id);
            let event = near_plugins::access_controllable::events::RoleGranted {
                role: role.into(),
                by: ::near_sdk::env::predecessor_account_id(),
                to: account_id.clone(),
            };
            near_plugins::events::AsEvent::emit(&event);
        }
        is_new_grantee
    }
    fn revoke_role(
        &mut self,
        role: Role,
        account_id: &::near_sdk::AccountId,
    ) -> Option<bool> {
        if !self.is_admin(role, &::near_sdk::env::predecessor_account_id()) {
            return None;
        }
        Some(self.revoke_role_unchecked(role, account_id))
    }
    fn renounce_role(&mut self, role: Role) -> bool {
        self.revoke_role_unchecked(role, &::near_sdk::env::predecessor_account_id())
    }
    fn revoke_role_unchecked(
        &mut self,
        role: Role,
        account_id: &::near_sdk::AccountId,
    ) -> bool {
        let flag = <RoleFlags>::from_bits(role.acl_permission())
            .unwrap_or_else(|| ::near_sdk::env::panic_str(
                "Value does not correspond to a permission",
            ));
        let mut permissions = match self.permissions.get_mut(account_id) {
            Some(permissions) => permissions,
            None => return false,
        };
        let was_grantee = permissions.contains(flag);
        if was_grantee {
            permissions.remove(flag);
            self.remove_bearer(flag, account_id);
            let event = near_plugins::access_controllable::events::RoleRevoked {
                role: role.into(),
                from: account_id.clone(),
                by: ::near_sdk::env::predecessor_account_id(),
            };
            near_plugins::events::AsEvent::emit(&event);
        }
        was_grantee
    }
    fn has_role(&self, role: Role, account_id: &::near_sdk::AccountId) -> bool {
        match self.permissions.get(account_id) {
            Some(permissions) => {
                let flag = <RoleFlags>::from_bits(role.acl_permission())
                    .unwrap_or_else(|| ::near_sdk::env::panic_str(
                        "Value does not correspond to a permission",
                    ));
                permissions.contains(flag)
            }
            None => false,
        }
    }
    fn has_any_role(
        &self,
        roles: Vec<Role>,
        account_id: &::near_sdk::AccountId,
    ) -> bool {
        let target = roles
            .iter()
            .map(|role| {
                <RoleFlags>::from_bits(role.acl_permission())
                    .unwrap_or_else(|| ::near_sdk::env::panic_str(
                        "Value does not correspond to a permission",
                    ))
            })
            .fold(<RoleFlags>::empty(), |acc, x| acc | x);
        self.has_any_permission(target, account_id)
    }
    fn has_any_permission(
        &self,
        target: RoleFlags,
        account_id: &::near_sdk::AccountId,
    ) -> bool {
        let permissions = match self.permissions.get(account_id) {
            Some(&permissions) => permissions,
            None => return false,
        };
        target.intersects(permissions)
    }
    /// Adds `account_id` to the set of `permission` bearers.
    ///
    /// # Panics
    ///
    /// Panics if `permission` has more than one active bit. The type of
    /// permission defines only flags which have one active bit. Still,
    /// developers might call this function with a `permission` that has
    /// multiple active bits. In that case, the panic prevents polluting
    /// state.
    fn add_bearer(&mut self, permission: RoleFlags, account_id: &::near_sdk::AccountId) {
        if true {
            let msg: &str = &"Adding a bearer is allowed only for permissions with exactly one active bit";
            if !permission.bits().is_power_of_two() {
                {
                    ::core::panicking::panic_display(&msg);
                }
            }
        } else if !permission.bits().is_power_of_two() {
            ::near_sdk::env::panic_str(
                &"Adding a bearer is allowed only for permissions with exactly one active bit",
            )
        }
        let mut set = self
            .bearers
            .entry(permission)
            .or_insert_with(|| { Self::new_bearers_set(permission) });
        set.insert(account_id.clone());
    }
    /// Enables paginated retrieval of bearers. Returns up to `limit`
    /// bearers of `permission`, skipping the first `skip` items.
    ///
    /// # Panics
    ///
    /// Panics if `skip` or `limit` are outside the range of `usize`.
    fn get_bearers(
        &self,
        permission: RoleFlags,
        skip: u64,
        limit: u64,
    ) -> Vec<::near_sdk::AccountId> {
        let skip: usize = ::std::convert::TryFrom::try_from(skip)
            .unwrap_or_else(|_| ::near_sdk::env::panic_str(
                "skip should be in the range of usize",
            ));
        let limit: usize = ::std::convert::TryFrom::try_from(limit)
            .unwrap_or_else(|_| ::near_sdk::env::panic_str(
                "limit should be in the range of usize",
            ));
        let set = match self.bearers.get(&permission) {
            Some(set) => set,
            None => return ::alloc::vec::Vec::new(),
        };
        set.iter().skip(skip).take(limit).cloned().collect()
    }
    /// Returns _all_ bearers of `permission`. In this implementation of
    /// `AccessControllable` there is no upper bound on the number of bearers per
    /// permission, so gas limits should be considered when calling this function.
    fn get_all_bearers(&self, permission: RoleFlags) -> Vec<::near_sdk::AccountId> {
        let set = match self.bearers.get(&permission) {
            Some(set) => set,
            None => return ::alloc::vec::Vec::new(),
        };
        set.iter().cloned().collect()
    }
    /// Removes `account_id` from the set of `permission` bearers.
    fn remove_bearer(
        &mut self,
        permission: RoleFlags,
        account_id: &::near_sdk::AccountId,
    ) {
        let mut set = match self.bearers.get_mut(&permission) {
            Some(set) => set,
            None => return,
        };
        set.remove(account_id);
    }
    /// Provides the implementation of `AccessControllable::acl_get_permissioned_accounts`.
    ///
    /// Uniqueness of account ids in returned vectors is guaranteed by the ids being
    /// retrieved from bearer sets.
    fn get_permissioned_accounts(
        &self,
    ) -> near_plugins::access_controllable::PermissionedAccounts {
        let permission = <RoleFlags>::from_bits(<Role>::acl_super_admin_permission())
            .unwrap_or_else(|| ::near_sdk::env::panic_str(
                "Value does not correspond to a permission",
            ));
        let super_admins = self.get_all_bearers(permission);
        let roles = <Role>::acl_role_variants();
        let mut map = ::std::collections::HashMap::new();
        for role in roles {
            let role: Role = ::std::convert::TryFrom::try_from(role)
                .unwrap_or_else(|_| ::near_sdk::env::panic_str(
                    "Value does not correspond to a role",
                ));
            let admin_permission = <RoleFlags>::from_bits(role.acl_admin_permission())
                .unwrap_or_else(|| ::near_sdk::env::panic_str(
                    "Value does not correspond to a permission",
                ));
            let admins = self.get_all_bearers(admin_permission);
            let grantee_permission = <RoleFlags>::from_bits(role.acl_permission())
                .unwrap_or_else(|| ::near_sdk::env::panic_str(
                    "Value does not correspond to a permission",
                ));
            let grantees = self.get_all_bearers(grantee_permission);
            map.insert(
                role.into(),
                near_plugins::access_controllable::PermissionedAccountsPerRole {
                    admins,
                    grantees,
                },
            );
        }
        near_plugins::access_controllable::PermissionedAccounts {
            super_admins,
            roles: map,
        }
    }
}
fn get_default_permissioned_accounts() -> near_plugins::access_controllable::PermissionedAccounts {
    let roles = <Role>::acl_role_variants();
    let mut map = ::std::collections::HashMap::new();
    for role in roles {
        let role: Role = ::std::convert::TryFrom::try_from(role)
            .unwrap_or_else(|_| ::near_sdk::env::panic_str(
                "Value does not correspond to a role",
            ));
        map.insert(
            role.into(),
            near_plugins::access_controllable::PermissionedAccountsPerRole {
                admins: Default::default(),
                grantees: Default::default(),
            },
        );
    }
    near_plugins::access_controllable::PermissionedAccounts {
        super_admins: Default::default(),
        roles: map,
    }
}
impl FastBridgeExt {
    pub fn acl_storage_prefix(self) -> near_sdk::Promise {
        let __args = ::alloc::vec::Vec::new();
        near_sdk::Promise::new(self.account_id)
            .function_call_weight(
                "acl_storage_prefix".to_string(),
                __args,
                self.deposit,
                self.static_gas,
                self.gas_weight,
            )
    }
    pub fn acl_init_super_admin(
        self,
        account_id: ::near_sdk::AccountId,
    ) -> near_sdk::Promise {
        let __args = {
            #[serde(crate = "near_sdk::serde")]
            struct Input<'nearinput> {
                account_id: &'nearinput ::near_sdk::AccountId,
            }
            #[doc(hidden)]
            #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
            const _: () = {
                use near_sdk::serde as _serde;
                #[automatically_derived]
                impl<'nearinput> near_sdk::serde::Serialize for Input<'nearinput> {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> near_sdk::serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: near_sdk::serde::Serializer,
                    {
                        let mut __serde_state = match _serde::Serializer::serialize_struct(
                            __serializer,
                            "Input",
                            false as usize + 1,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "account_id",
                            &self.account_id,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            let __args = Input { account_id: &account_id };
            near_sdk::serde_json::to_vec(&__args)
                .expect("Failed to serialize the cross contract args using JSON.")
        };
        near_sdk::Promise::new(self.account_id)
            .function_call_weight(
                "acl_init_super_admin".to_string(),
                __args,
                self.deposit,
                self.static_gas,
                self.gas_weight,
            )
    }
    pub fn acl_add_super_admin(
        self,
        account_id: ::near_sdk::AccountId,
    ) -> near_sdk::Promise {
        let __args = {
            #[serde(crate = "near_sdk::serde")]
            struct Input<'nearinput> {
                account_id: &'nearinput ::near_sdk::AccountId,
            }
            #[doc(hidden)]
            #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
            const _: () = {
                use near_sdk::serde as _serde;
                #[automatically_derived]
                impl<'nearinput> near_sdk::serde::Serialize for Input<'nearinput> {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> near_sdk::serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: near_sdk::serde::Serializer,
                    {
                        let mut __serde_state = match _serde::Serializer::serialize_struct(
                            __serializer,
                            "Input",
                            false as usize + 1,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "account_id",
                            &self.account_id,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            let __args = Input { account_id: &account_id };
            near_sdk::serde_json::to_vec(&__args)
                .expect("Failed to serialize the cross contract args using JSON.")
        };
        near_sdk::Promise::new(self.account_id)
            .function_call_weight(
                "acl_add_super_admin".to_string(),
                __args,
                self.deposit,
                self.static_gas,
                self.gas_weight,
            )
    }
    pub fn acl_role_variants(self) -> near_sdk::Promise {
        let __args = ::alloc::vec::Vec::new();
        near_sdk::Promise::new(self.account_id)
            .function_call_weight(
                "acl_role_variants".to_string(),
                __args,
                self.deposit,
                self.static_gas,
                self.gas_weight,
            )
    }
    pub fn acl_is_super_admin(
        self,
        account_id: ::near_sdk::AccountId,
    ) -> near_sdk::Promise {
        let __args = {
            #[serde(crate = "near_sdk::serde")]
            struct Input<'nearinput> {
                account_id: &'nearinput ::near_sdk::AccountId,
            }
            #[doc(hidden)]
            #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
            const _: () = {
                use near_sdk::serde as _serde;
                #[automatically_derived]
                impl<'nearinput> near_sdk::serde::Serialize for Input<'nearinput> {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> near_sdk::serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: near_sdk::serde::Serializer,
                    {
                        let mut __serde_state = match _serde::Serializer::serialize_struct(
                            __serializer,
                            "Input",
                            false as usize + 1,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "account_id",
                            &self.account_id,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            let __args = Input { account_id: &account_id };
            near_sdk::serde_json::to_vec(&__args)
                .expect("Failed to serialize the cross contract args using JSON.")
        };
        near_sdk::Promise::new(self.account_id)
            .function_call_weight(
                "acl_is_super_admin".to_string(),
                __args,
                self.deposit,
                self.static_gas,
                self.gas_weight,
            )
    }
    pub fn acl_revoke_super_admin(
        self,
        account_id: ::near_sdk::AccountId,
    ) -> near_sdk::Promise {
        let __args = {
            #[serde(crate = "near_sdk::serde")]
            struct Input<'nearinput> {
                account_id: &'nearinput ::near_sdk::AccountId,
            }
            #[doc(hidden)]
            #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
            const _: () = {
                use near_sdk::serde as _serde;
                #[automatically_derived]
                impl<'nearinput> near_sdk::serde::Serialize for Input<'nearinput> {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> near_sdk::serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: near_sdk::serde::Serializer,
                    {
                        let mut __serde_state = match _serde::Serializer::serialize_struct(
                            __serializer,
                            "Input",
                            false as usize + 1,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "account_id",
                            &self.account_id,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            let __args = Input { account_id: &account_id };
            near_sdk::serde_json::to_vec(&__args)
                .expect("Failed to serialize the cross contract args using JSON.")
        };
        near_sdk::Promise::new(self.account_id)
            .function_call_weight(
                "acl_revoke_super_admin".to_string(),
                __args,
                self.deposit,
                self.static_gas,
                self.gas_weight,
            )
    }
    pub fn acl_transfer_super_admin(
        self,
        account_id: ::near_sdk::AccountId,
    ) -> near_sdk::Promise {
        let __args = {
            #[serde(crate = "near_sdk::serde")]
            struct Input<'nearinput> {
                account_id: &'nearinput ::near_sdk::AccountId,
            }
            #[doc(hidden)]
            #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
            const _: () = {
                use near_sdk::serde as _serde;
                #[automatically_derived]
                impl<'nearinput> near_sdk::serde::Serialize for Input<'nearinput> {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> near_sdk::serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: near_sdk::serde::Serializer,
                    {
                        let mut __serde_state = match _serde::Serializer::serialize_struct(
                            __serializer,
                            "Input",
                            false as usize + 1,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "account_id",
                            &self.account_id,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            let __args = Input { account_id: &account_id };
            near_sdk::serde_json::to_vec(&__args)
                .expect("Failed to serialize the cross contract args using JSON.")
        };
        near_sdk::Promise::new(self.account_id)
            .function_call_weight(
                "acl_transfer_super_admin".to_string(),
                __args,
                self.deposit,
                self.static_gas,
                self.gas_weight,
            )
    }
    pub fn acl_add_admin(
        self,
        role: String,
        account_id: ::near_sdk::AccountId,
    ) -> near_sdk::Promise {
        let __args = {
            #[serde(crate = "near_sdk::serde")]
            struct Input<'nearinput> {
                role: &'nearinput String,
                account_id: &'nearinput ::near_sdk::AccountId,
            }
            #[doc(hidden)]
            #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
            const _: () = {
                use near_sdk::serde as _serde;
                #[automatically_derived]
                impl<'nearinput> near_sdk::serde::Serialize for Input<'nearinput> {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> near_sdk::serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: near_sdk::serde::Serializer,
                    {
                        let mut __serde_state = match _serde::Serializer::serialize_struct(
                            __serializer,
                            "Input",
                            false as usize + 1 + 1,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "role",
                            &self.role,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "account_id",
                            &self.account_id,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            let __args = Input {
                role: &role,
                account_id: &account_id,
            };
            near_sdk::serde_json::to_vec(&__args)
                .expect("Failed to serialize the cross contract args using JSON.")
        };
        near_sdk::Promise::new(self.account_id)
            .function_call_weight(
                "acl_add_admin".to_string(),
                __args,
                self.deposit,
                self.static_gas,
                self.gas_weight,
            )
    }
    pub fn acl_is_admin(
        self,
        role: String,
        account_id: ::near_sdk::AccountId,
    ) -> near_sdk::Promise {
        let __args = {
            #[serde(crate = "near_sdk::serde")]
            struct Input<'nearinput> {
                role: &'nearinput String,
                account_id: &'nearinput ::near_sdk::AccountId,
            }
            #[doc(hidden)]
            #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
            const _: () = {
                use near_sdk::serde as _serde;
                #[automatically_derived]
                impl<'nearinput> near_sdk::serde::Serialize for Input<'nearinput> {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> near_sdk::serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: near_sdk::serde::Serializer,
                    {
                        let mut __serde_state = match _serde::Serializer::serialize_struct(
                            __serializer,
                            "Input",
                            false as usize + 1 + 1,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "role",
                            &self.role,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "account_id",
                            &self.account_id,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            let __args = Input {
                role: &role,
                account_id: &account_id,
            };
            near_sdk::serde_json::to_vec(&__args)
                .expect("Failed to serialize the cross contract args using JSON.")
        };
        near_sdk::Promise::new(self.account_id)
            .function_call_weight(
                "acl_is_admin".to_string(),
                __args,
                self.deposit,
                self.static_gas,
                self.gas_weight,
            )
    }
    pub fn acl_revoke_admin(
        self,
        role: String,
        account_id: ::near_sdk::AccountId,
    ) -> near_sdk::Promise {
        let __args = {
            #[serde(crate = "near_sdk::serde")]
            struct Input<'nearinput> {
                role: &'nearinput String,
                account_id: &'nearinput ::near_sdk::AccountId,
            }
            #[doc(hidden)]
            #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
            const _: () = {
                use near_sdk::serde as _serde;
                #[automatically_derived]
                impl<'nearinput> near_sdk::serde::Serialize for Input<'nearinput> {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> near_sdk::serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: near_sdk::serde::Serializer,
                    {
                        let mut __serde_state = match _serde::Serializer::serialize_struct(
                            __serializer,
                            "Input",
                            false as usize + 1 + 1,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "role",
                            &self.role,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "account_id",
                            &self.account_id,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            let __args = Input {
                role: &role,
                account_id: &account_id,
            };
            near_sdk::serde_json::to_vec(&__args)
                .expect("Failed to serialize the cross contract args using JSON.")
        };
        near_sdk::Promise::new(self.account_id)
            .function_call_weight(
                "acl_revoke_admin".to_string(),
                __args,
                self.deposit,
                self.static_gas,
                self.gas_weight,
            )
    }
    pub fn acl_renounce_admin(self, role: String) -> near_sdk::Promise {
        let __args = {
            #[serde(crate = "near_sdk::serde")]
            struct Input<'nearinput> {
                role: &'nearinput String,
            }
            #[doc(hidden)]
            #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
            const _: () = {
                use near_sdk::serde as _serde;
                #[automatically_derived]
                impl<'nearinput> near_sdk::serde::Serialize for Input<'nearinput> {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> near_sdk::serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: near_sdk::serde::Serializer,
                    {
                        let mut __serde_state = match _serde::Serializer::serialize_struct(
                            __serializer,
                            "Input",
                            false as usize + 1,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "role",
                            &self.role,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            let __args = Input { role: &role };
            near_sdk::serde_json::to_vec(&__args)
                .expect("Failed to serialize the cross contract args using JSON.")
        };
        near_sdk::Promise::new(self.account_id)
            .function_call_weight(
                "acl_renounce_admin".to_string(),
                __args,
                self.deposit,
                self.static_gas,
                self.gas_weight,
            )
    }
    pub fn acl_revoke_role(
        self,
        role: String,
        account_id: ::near_sdk::AccountId,
    ) -> near_sdk::Promise {
        let __args = {
            #[serde(crate = "near_sdk::serde")]
            struct Input<'nearinput> {
                role: &'nearinput String,
                account_id: &'nearinput ::near_sdk::AccountId,
            }
            #[doc(hidden)]
            #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
            const _: () = {
                use near_sdk::serde as _serde;
                #[automatically_derived]
                impl<'nearinput> near_sdk::serde::Serialize for Input<'nearinput> {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> near_sdk::serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: near_sdk::serde::Serializer,
                    {
                        let mut __serde_state = match _serde::Serializer::serialize_struct(
                            __serializer,
                            "Input",
                            false as usize + 1 + 1,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "role",
                            &self.role,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "account_id",
                            &self.account_id,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            let __args = Input {
                role: &role,
                account_id: &account_id,
            };
            near_sdk::serde_json::to_vec(&__args)
                .expect("Failed to serialize the cross contract args using JSON.")
        };
        near_sdk::Promise::new(self.account_id)
            .function_call_weight(
                "acl_revoke_role".to_string(),
                __args,
                self.deposit,
                self.static_gas,
                self.gas_weight,
            )
    }
    pub fn acl_renounce_role(self, role: String) -> near_sdk::Promise {
        let __args = {
            #[serde(crate = "near_sdk::serde")]
            struct Input<'nearinput> {
                role: &'nearinput String,
            }
            #[doc(hidden)]
            #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
            const _: () = {
                use near_sdk::serde as _serde;
                #[automatically_derived]
                impl<'nearinput> near_sdk::serde::Serialize for Input<'nearinput> {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> near_sdk::serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: near_sdk::serde::Serializer,
                    {
                        let mut __serde_state = match _serde::Serializer::serialize_struct(
                            __serializer,
                            "Input",
                            false as usize + 1,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "role",
                            &self.role,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            let __args = Input { role: &role };
            near_sdk::serde_json::to_vec(&__args)
                .expect("Failed to serialize the cross contract args using JSON.")
        };
        near_sdk::Promise::new(self.account_id)
            .function_call_weight(
                "acl_renounce_role".to_string(),
                __args,
                self.deposit,
                self.static_gas,
                self.gas_weight,
            )
    }
    pub fn acl_grant_role(
        self,
        role: String,
        account_id: ::near_sdk::AccountId,
    ) -> near_sdk::Promise {
        let __args = {
            #[serde(crate = "near_sdk::serde")]
            struct Input<'nearinput> {
                role: &'nearinput String,
                account_id: &'nearinput ::near_sdk::AccountId,
            }
            #[doc(hidden)]
            #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
            const _: () = {
                use near_sdk::serde as _serde;
                #[automatically_derived]
                impl<'nearinput> near_sdk::serde::Serialize for Input<'nearinput> {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> near_sdk::serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: near_sdk::serde::Serializer,
                    {
                        let mut __serde_state = match _serde::Serializer::serialize_struct(
                            __serializer,
                            "Input",
                            false as usize + 1 + 1,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "role",
                            &self.role,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "account_id",
                            &self.account_id,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            let __args = Input {
                role: &role,
                account_id: &account_id,
            };
            near_sdk::serde_json::to_vec(&__args)
                .expect("Failed to serialize the cross contract args using JSON.")
        };
        near_sdk::Promise::new(self.account_id)
            .function_call_weight(
                "acl_grant_role".to_string(),
                __args,
                self.deposit,
                self.static_gas,
                self.gas_weight,
            )
    }
    pub fn acl_has_role(
        self,
        role: String,
        account_id: ::near_sdk::AccountId,
    ) -> near_sdk::Promise {
        let __args = {
            #[serde(crate = "near_sdk::serde")]
            struct Input<'nearinput> {
                role: &'nearinput String,
                account_id: &'nearinput ::near_sdk::AccountId,
            }
            #[doc(hidden)]
            #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
            const _: () = {
                use near_sdk::serde as _serde;
                #[automatically_derived]
                impl<'nearinput> near_sdk::serde::Serialize for Input<'nearinput> {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> near_sdk::serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: near_sdk::serde::Serializer,
                    {
                        let mut __serde_state = match _serde::Serializer::serialize_struct(
                            __serializer,
                            "Input",
                            false as usize + 1 + 1,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "role",
                            &self.role,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "account_id",
                            &self.account_id,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            let __args = Input {
                role: &role,
                account_id: &account_id,
            };
            near_sdk::serde_json::to_vec(&__args)
                .expect("Failed to serialize the cross contract args using JSON.")
        };
        near_sdk::Promise::new(self.account_id)
            .function_call_weight(
                "acl_has_role".to_string(),
                __args,
                self.deposit,
                self.static_gas,
                self.gas_weight,
            )
    }
    pub fn acl_has_any_role(
        self,
        roles: Vec<String>,
        account_id: ::near_sdk::AccountId,
    ) -> near_sdk::Promise {
        let __args = {
            #[serde(crate = "near_sdk::serde")]
            struct Input<'nearinput> {
                roles: &'nearinput Vec<String>,
                account_id: &'nearinput ::near_sdk::AccountId,
            }
            #[doc(hidden)]
            #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
            const _: () = {
                use near_sdk::serde as _serde;
                #[automatically_derived]
                impl<'nearinput> near_sdk::serde::Serialize for Input<'nearinput> {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> near_sdk::serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: near_sdk::serde::Serializer,
                    {
                        let mut __serde_state = match _serde::Serializer::serialize_struct(
                            __serializer,
                            "Input",
                            false as usize + 1 + 1,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "roles",
                            &self.roles,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "account_id",
                            &self.account_id,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            let __args = Input {
                roles: &roles,
                account_id: &account_id,
            };
            near_sdk::serde_json::to_vec(&__args)
                .expect("Failed to serialize the cross contract args using JSON.")
        };
        near_sdk::Promise::new(self.account_id)
            .function_call_weight(
                "acl_has_any_role".to_string(),
                __args,
                self.deposit,
                self.static_gas,
                self.gas_weight,
            )
    }
    pub fn acl_get_super_admins(self, skip: u64, limit: u64) -> near_sdk::Promise {
        let __args = {
            #[serde(crate = "near_sdk::serde")]
            struct Input<'nearinput> {
                skip: &'nearinput u64,
                limit: &'nearinput u64,
            }
            #[doc(hidden)]
            #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
            const _: () = {
                use near_sdk::serde as _serde;
                #[automatically_derived]
                impl<'nearinput> near_sdk::serde::Serialize for Input<'nearinput> {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> near_sdk::serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: near_sdk::serde::Serializer,
                    {
                        let mut __serde_state = match _serde::Serializer::serialize_struct(
                            __serializer,
                            "Input",
                            false as usize + 1 + 1,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "skip",
                            &self.skip,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "limit",
                            &self.limit,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            let __args = Input {
                skip: &skip,
                limit: &limit,
            };
            near_sdk::serde_json::to_vec(&__args)
                .expect("Failed to serialize the cross contract args using JSON.")
        };
        near_sdk::Promise::new(self.account_id)
            .function_call_weight(
                "acl_get_super_admins".to_string(),
                __args,
                self.deposit,
                self.static_gas,
                self.gas_weight,
            )
    }
    pub fn acl_get_admins(
        self,
        role: String,
        skip: u64,
        limit: u64,
    ) -> near_sdk::Promise {
        let __args = {
            #[serde(crate = "near_sdk::serde")]
            struct Input<'nearinput> {
                role: &'nearinput String,
                skip: &'nearinput u64,
                limit: &'nearinput u64,
            }
            #[doc(hidden)]
            #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
            const _: () = {
                use near_sdk::serde as _serde;
                #[automatically_derived]
                impl<'nearinput> near_sdk::serde::Serialize for Input<'nearinput> {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> near_sdk::serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: near_sdk::serde::Serializer,
                    {
                        let mut __serde_state = match _serde::Serializer::serialize_struct(
                            __serializer,
                            "Input",
                            false as usize + 1 + 1 + 1,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "role",
                            &self.role,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "skip",
                            &self.skip,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "limit",
                            &self.limit,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            let __args = Input {
                role: &role,
                skip: &skip,
                limit: &limit,
            };
            near_sdk::serde_json::to_vec(&__args)
                .expect("Failed to serialize the cross contract args using JSON.")
        };
        near_sdk::Promise::new(self.account_id)
            .function_call_weight(
                "acl_get_admins".to_string(),
                __args,
                self.deposit,
                self.static_gas,
                self.gas_weight,
            )
    }
    pub fn acl_get_grantees(
        self,
        role: String,
        skip: u64,
        limit: u64,
    ) -> near_sdk::Promise {
        let __args = {
            #[serde(crate = "near_sdk::serde")]
            struct Input<'nearinput> {
                role: &'nearinput String,
                skip: &'nearinput u64,
                limit: &'nearinput u64,
            }
            #[doc(hidden)]
            #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
            const _: () = {
                use near_sdk::serde as _serde;
                #[automatically_derived]
                impl<'nearinput> near_sdk::serde::Serialize for Input<'nearinput> {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> near_sdk::serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: near_sdk::serde::Serializer,
                    {
                        let mut __serde_state = match _serde::Serializer::serialize_struct(
                            __serializer,
                            "Input",
                            false as usize + 1 + 1 + 1,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "role",
                            &self.role,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "skip",
                            &self.skip,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "limit",
                            &self.limit,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            let __args = Input {
                role: &role,
                skip: &skip,
                limit: &limit,
            };
            near_sdk::serde_json::to_vec(&__args)
                .expect("Failed to serialize the cross contract args using JSON.")
        };
        near_sdk::Promise::new(self.account_id)
            .function_call_weight(
                "acl_get_grantees".to_string(),
                __args,
                self.deposit,
                self.static_gas,
                self.gas_weight,
            )
    }
    pub fn acl_get_permissioned_accounts(self) -> near_sdk::Promise {
        let __args = ::alloc::vec::Vec::new();
        near_sdk::Promise::new(self.account_id)
            .function_call_weight(
                "acl_get_permissioned_accounts".to_string(),
                __args,
                self.deposit,
                self.static_gas,
                self.gas_weight,
            )
    }
}
impl AccessControllable for FastBridge {
    fn acl_storage_prefix() -> &'static [u8] {
        ("__acl").as_bytes()
    }
    fn acl_init_super_admin(&mut self, account_id: ::near_sdk::AccountId) -> bool {
        self.acl_get_or_init().init_super_admin(&account_id)
    }
    fn acl_add_super_admin(
        &mut self,
        account_id: ::near_sdk::AccountId,
    ) -> Option<bool> {
        self.acl_get_or_init().add_super_admin(&account_id)
    }
    fn acl_role_variants(&self) -> Vec<&'static str> {
        <Role>::acl_role_variants()
    }
    fn acl_is_super_admin(&self, account_id: ::near_sdk::AccountId) -> bool {
        match self.acl_get_storage() {
            Some(val) => val,
            None => {
                return false;
            }
        }
            .is_super_admin(&account_id)
    }
    fn acl_revoke_super_admin(
        &mut self,
        account_id: ::near_sdk::AccountId,
    ) -> Option<bool> {
        self.acl_get_or_init().revoke_super_admin(&account_id)
    }
    fn acl_transfer_super_admin(
        &mut self,
        account_id: ::near_sdk::AccountId,
    ) -> Option<bool> {
        self.acl_get_or_init().transfer_super_admin(&account_id)
    }
    fn acl_add_admin(
        &mut self,
        role: String,
        account_id: ::near_sdk::AccountId,
    ) -> Option<bool> {
        let role: Role = ::std::convert::TryFrom::try_from(role.as_str())
            .unwrap_or_else(|_| ::near_sdk::env::panic_str(
                "Value does not correspond to a role",
            ));
        self.acl_get_or_init().add_admin(role, &account_id)
    }
    fn acl_is_admin(&self, role: String, account_id: ::near_sdk::AccountId) -> bool {
        let role: Role = ::std::convert::TryFrom::try_from(role.as_str())
            .unwrap_or_else(|_| ::near_sdk::env::panic_str(
                "Value does not correspond to a role",
            ));
        match self.acl_get_storage() {
            Some(val) => val,
            None => {
                return false;
            }
        }
            .is_admin(role, &account_id)
    }
    fn acl_revoke_admin(
        &mut self,
        role: String,
        account_id: ::near_sdk::AccountId,
    ) -> Option<bool> {
        let role: Role = ::std::convert::TryFrom::try_from(role.as_str())
            .unwrap_or_else(|_| ::near_sdk::env::panic_str(
                "Value does not correspond to a role",
            ));
        self.acl_get_or_init().revoke_admin(role, &account_id)
    }
    fn acl_renounce_admin(&mut self, role: String) -> bool {
        let role: Role = ::std::convert::TryFrom::try_from(role.as_str())
            .unwrap_or_else(|_| ::near_sdk::env::panic_str(
                "Value does not correspond to a role",
            ));
        self.acl_get_or_init().renounce_admin(role)
    }
    fn acl_revoke_role(
        &mut self,
        role: String,
        account_id: ::near_sdk::AccountId,
    ) -> Option<bool> {
        let role: Role = ::std::convert::TryFrom::try_from(role.as_str())
            .unwrap_or_else(|_| ::near_sdk::env::panic_str(
                "Value does not correspond to a role",
            ));
        self.acl_get_or_init().revoke_role(role, &account_id)
    }
    fn acl_renounce_role(&mut self, role: String) -> bool {
        let role: Role = ::std::convert::TryFrom::try_from(role.as_str())
            .unwrap_or_else(|_| ::near_sdk::env::panic_str(
                "Value does not correspond to a role",
            ));
        self.acl_get_or_init().renounce_role(role)
    }
    fn acl_grant_role(
        &mut self,
        role: String,
        account_id: ::near_sdk::AccountId,
    ) -> Option<bool> {
        let role: Role = ::std::convert::TryFrom::try_from(role.as_str())
            .unwrap_or_else(|_| ::near_sdk::env::panic_str(
                "Value does not correspond to a role",
            ));
        self.acl_get_or_init().grant_role(role, &account_id)
    }
    fn acl_has_role(&self, role: String, account_id: ::near_sdk::AccountId) -> bool {
        let role: Role = ::std::convert::TryFrom::try_from(role.as_str())
            .unwrap_or_else(|_| ::near_sdk::env::panic_str(
                "Value does not correspond to a role",
            ));
        match self.acl_get_storage() {
            Some(val) => val,
            None => {
                return false;
            }
        }
            .has_role(role, &account_id)
    }
    fn acl_has_any_role(
        &self,
        roles: Vec<String>,
        account_id: ::near_sdk::AccountId,
    ) -> bool {
        let roles: Vec<Role> = roles
            .iter()
            .map(|role| {
                ::std::convert::TryFrom::try_from(role.as_str())
                    .unwrap_or_else(|_| ::near_sdk::env::panic_str(
                        "Value does not correspond to a role",
                    ))
            })
            .collect();
        match self.acl_get_storage() {
            Some(val) => val,
            None => {
                return false;
            }
        }
            .has_any_role(roles, &account_id)
    }
    fn acl_get_super_admins(&self, skip: u64, limit: u64) -> Vec<::near_sdk::AccountId> {
        let permission = <RoleFlags>::from_bits(<Role>::acl_super_admin_permission())
            .unwrap_or_else(|| ::near_sdk::env::panic_str(
                "Value does not correspond to a permission",
            ));
        match self.acl_get_storage() {
            Some(val) => val,
            None => {
                return ::alloc::vec::Vec::new();
            }
        }
            .get_bearers(permission, skip, limit)
    }
    fn acl_get_admins(
        &self,
        role: String,
        skip: u64,
        limit: u64,
    ) -> Vec<::near_sdk::AccountId> {
        let role: Role = ::std::convert::TryFrom::try_from(role.as_str())
            .unwrap_or_else(|_| ::near_sdk::env::panic_str(
                "Value does not correspond to a role",
            ));
        let permission = <RoleFlags>::from_bits(role.acl_admin_permission())
            .unwrap_or_else(|| ::near_sdk::env::panic_str(
                "Value does not correspond to a permission",
            ));
        match self.acl_get_storage() {
            Some(val) => val,
            None => {
                return ::alloc::vec::Vec::new();
            }
        }
            .get_bearers(permission, skip, limit)
    }
    fn acl_get_grantees(
        &self,
        role: String,
        skip: u64,
        limit: u64,
    ) -> Vec<::near_sdk::AccountId> {
        let role: Role = ::std::convert::TryFrom::try_from(role.as_str())
            .unwrap_or_else(|_| ::near_sdk::env::panic_str(
                "Value does not correspond to a role",
            ));
        let permission = <RoleFlags>::from_bits(role.acl_permission())
            .unwrap_or_else(|| ::near_sdk::env::panic_str(
                "Value does not correspond to a permission",
            ));
        match self.acl_get_storage() {
            Some(val) => val,
            None => {
                return ::alloc::vec::Vec::new();
            }
        }
            .get_bearers(permission, skip, limit)
    }
    fn acl_get_permissioned_accounts(
        &self,
    ) -> near_plugins::access_controllable::PermissionedAccounts {
        match self.acl_get_storage() {
            Some(val) => val,
            None => {
                return get_default_permissioned_accounts();
            }
        }
            .get_permissioned_accounts()
    }
}
#[cfg(target_arch = "wasm32")]
#[no_mangle]
pub extern "C" fn acl_storage_prefix() {
    near_sdk::env::setup_panic_hook();
    if near_sdk::env::attached_deposit() != 0 {
        near_sdk::env::panic_str("Method acl_storage_prefix doesn't accept deposit");
    }
    let result = FastBridge::acl_storage_prefix();
    let result = near_sdk::serde_json::to_vec(&result)
        .expect("Failed to serialize the return value using JSON.");
    near_sdk::env::value_return(&result);
}
#[cfg(target_arch = "wasm32")]
#[no_mangle]
pub extern "C" fn acl_init_super_admin() {
    near_sdk::env::setup_panic_hook();
    if near_sdk::env::current_account_id() != near_sdk::env::predecessor_account_id() {
        near_sdk::env::panic_str("Method acl_init_super_admin is private");
    }
    if near_sdk::env::attached_deposit() != 0 {
        near_sdk::env::panic_str("Method acl_init_super_admin doesn't accept deposit");
    }
    #[serde(crate = "near_sdk::serde")]
    struct Input {
        account_id: ::near_sdk::AccountId,
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        use near_sdk::serde as _serde;
        #[automatically_derived]
        impl<'de> near_sdk::serde::Deserialize<'de> for Input {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> near_sdk::serde::__private::Result<Self, __D::Error>
            where
                __D: near_sdk::serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "account_id" => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"account_id" => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<Input>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = Input;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct Input",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match match _serde::de::SeqAccess::next_element::<
                            ::near_sdk::AccountId,
                        >(&mut __seq) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct Input with 1 element",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(Input { account_id: __field0 })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<
                            ::near_sdk::AccountId,
                        > = _serde::__private::None;
                        while let _serde::__private::Some(__key) = match _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "account_id",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<
                                            ::near_sdk::AccountId,
                                        >(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                _ => {
                                    let _ = match _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("account_id") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        _serde::__private::Ok(Input { account_id: __field0 })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &["account_id"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "Input",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<Input>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    let Input { account_id }: Input = near_sdk::serde_json::from_slice(
            &near_sdk::env::input().expect("Expected input since method has arguments."),
        )
        .expect("Failed to deserialize input from JSON.");
    let mut contract: FastBridge = near_sdk::env::state_read().unwrap_or_default();
    let result = contract.acl_init_super_admin(account_id);
    let result = near_sdk::serde_json::to_vec(&result)
        .expect("Failed to serialize the return value using JSON.");
    near_sdk::env::value_return(&result);
    near_sdk::env::state_write(&contract);
}
#[cfg(target_arch = "wasm32")]
#[no_mangle]
pub extern "C" fn acl_add_super_admin() {
    near_sdk::env::setup_panic_hook();
    if near_sdk::env::attached_deposit() != 0 {
        near_sdk::env::panic_str("Method acl_add_super_admin doesn't accept deposit");
    }
    #[serde(crate = "near_sdk::serde")]
    struct Input {
        account_id: ::near_sdk::AccountId,
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        use near_sdk::serde as _serde;
        #[automatically_derived]
        impl<'de> near_sdk::serde::Deserialize<'de> for Input {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> near_sdk::serde::__private::Result<Self, __D::Error>
            where
                __D: near_sdk::serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "account_id" => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"account_id" => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<Input>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = Input;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct Input",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match match _serde::de::SeqAccess::next_element::<
                            ::near_sdk::AccountId,
                        >(&mut __seq) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct Input with 1 element",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(Input { account_id: __field0 })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<
                            ::near_sdk::AccountId,
                        > = _serde::__private::None;
                        while let _serde::__private::Some(__key) = match _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "account_id",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<
                                            ::near_sdk::AccountId,
                                        >(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                _ => {
                                    let _ = match _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("account_id") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        _serde::__private::Ok(Input { account_id: __field0 })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &["account_id"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "Input",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<Input>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    let Input { account_id }: Input = near_sdk::serde_json::from_slice(
            &near_sdk::env::input().expect("Expected input since method has arguments."),
        )
        .expect("Failed to deserialize input from JSON.");
    let mut contract: FastBridge = near_sdk::env::state_read().unwrap_or_default();
    let result = contract.acl_add_super_admin(account_id);
    let result = near_sdk::serde_json::to_vec(&result)
        .expect("Failed to serialize the return value using JSON.");
    near_sdk::env::value_return(&result);
    near_sdk::env::state_write(&contract);
}
#[cfg(target_arch = "wasm32")]
#[no_mangle]
pub extern "C" fn acl_role_variants() {
    near_sdk::env::setup_panic_hook();
    let contract: FastBridge = near_sdk::env::state_read().unwrap_or_default();
    let result = contract.acl_role_variants();
    let result = near_sdk::serde_json::to_vec(&result)
        .expect("Failed to serialize the return value using JSON.");
    near_sdk::env::value_return(&result);
}
#[cfg(target_arch = "wasm32")]
#[no_mangle]
pub extern "C" fn acl_is_super_admin() {
    near_sdk::env::setup_panic_hook();
    #[serde(crate = "near_sdk::serde")]
    struct Input {
        account_id: ::near_sdk::AccountId,
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        use near_sdk::serde as _serde;
        #[automatically_derived]
        impl<'de> near_sdk::serde::Deserialize<'de> for Input {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> near_sdk::serde::__private::Result<Self, __D::Error>
            where
                __D: near_sdk::serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "account_id" => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"account_id" => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<Input>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = Input;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct Input",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match match _serde::de::SeqAccess::next_element::<
                            ::near_sdk::AccountId,
                        >(&mut __seq) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct Input with 1 element",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(Input { account_id: __field0 })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<
                            ::near_sdk::AccountId,
                        > = _serde::__private::None;
                        while let _serde::__private::Some(__key) = match _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "account_id",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<
                                            ::near_sdk::AccountId,
                                        >(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                _ => {
                                    let _ = match _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("account_id") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        _serde::__private::Ok(Input { account_id: __field0 })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &["account_id"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "Input",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<Input>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    let Input { account_id }: Input = near_sdk::serde_json::from_slice(
            &near_sdk::env::input().expect("Expected input since method has arguments."),
        )
        .expect("Failed to deserialize input from JSON.");
    let contract: FastBridge = near_sdk::env::state_read().unwrap_or_default();
    let result = contract.acl_is_super_admin(account_id);
    let result = near_sdk::serde_json::to_vec(&result)
        .expect("Failed to serialize the return value using JSON.");
    near_sdk::env::value_return(&result);
}
#[cfg(target_arch = "wasm32")]
#[no_mangle]
pub extern "C" fn acl_revoke_super_admin() {
    near_sdk::env::setup_panic_hook();
    if near_sdk::env::attached_deposit() != 0 {
        near_sdk::env::panic_str("Method acl_revoke_super_admin doesn't accept deposit");
    }
    #[serde(crate = "near_sdk::serde")]
    struct Input {
        account_id: ::near_sdk::AccountId,
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        use near_sdk::serde as _serde;
        #[automatically_derived]
        impl<'de> near_sdk::serde::Deserialize<'de> for Input {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> near_sdk::serde::__private::Result<Self, __D::Error>
            where
                __D: near_sdk::serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "account_id" => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"account_id" => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<Input>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = Input;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct Input",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match match _serde::de::SeqAccess::next_element::<
                            ::near_sdk::AccountId,
                        >(&mut __seq) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct Input with 1 element",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(Input { account_id: __field0 })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<
                            ::near_sdk::AccountId,
                        > = _serde::__private::None;
                        while let _serde::__private::Some(__key) = match _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "account_id",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<
                                            ::near_sdk::AccountId,
                                        >(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                _ => {
                                    let _ = match _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("account_id") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        _serde::__private::Ok(Input { account_id: __field0 })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &["account_id"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "Input",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<Input>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    let Input { account_id }: Input = near_sdk::serde_json::from_slice(
            &near_sdk::env::input().expect("Expected input since method has arguments."),
        )
        .expect("Failed to deserialize input from JSON.");
    let mut contract: FastBridge = near_sdk::env::state_read().unwrap_or_default();
    let result = contract.acl_revoke_super_admin(account_id);
    let result = near_sdk::serde_json::to_vec(&result)
        .expect("Failed to serialize the return value using JSON.");
    near_sdk::env::value_return(&result);
    near_sdk::env::state_write(&contract);
}
#[cfg(target_arch = "wasm32")]
#[no_mangle]
pub extern "C" fn acl_transfer_super_admin() {
    near_sdk::env::setup_panic_hook();
    if near_sdk::env::attached_deposit() != 0 {
        near_sdk::env::panic_str(
            "Method acl_transfer_super_admin doesn't accept deposit",
        );
    }
    #[serde(crate = "near_sdk::serde")]
    struct Input {
        account_id: ::near_sdk::AccountId,
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        use near_sdk::serde as _serde;
        #[automatically_derived]
        impl<'de> near_sdk::serde::Deserialize<'de> for Input {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> near_sdk::serde::__private::Result<Self, __D::Error>
            where
                __D: near_sdk::serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "account_id" => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"account_id" => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<Input>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = Input;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct Input",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match match _serde::de::SeqAccess::next_element::<
                            ::near_sdk::AccountId,
                        >(&mut __seq) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct Input with 1 element",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(Input { account_id: __field0 })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<
                            ::near_sdk::AccountId,
                        > = _serde::__private::None;
                        while let _serde::__private::Some(__key) = match _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "account_id",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<
                                            ::near_sdk::AccountId,
                                        >(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                _ => {
                                    let _ = match _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("account_id") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        _serde::__private::Ok(Input { account_id: __field0 })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &["account_id"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "Input",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<Input>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    let Input { account_id }: Input = near_sdk::serde_json::from_slice(
            &near_sdk::env::input().expect("Expected input since method has arguments."),
        )
        .expect("Failed to deserialize input from JSON.");
    let mut contract: FastBridge = near_sdk::env::state_read().unwrap_or_default();
    let result = contract.acl_transfer_super_admin(account_id);
    let result = near_sdk::serde_json::to_vec(&result)
        .expect("Failed to serialize the return value using JSON.");
    near_sdk::env::value_return(&result);
    near_sdk::env::state_write(&contract);
}
#[cfg(target_arch = "wasm32")]
#[no_mangle]
pub extern "C" fn acl_add_admin() {
    near_sdk::env::setup_panic_hook();
    if near_sdk::env::attached_deposit() != 0 {
        near_sdk::env::panic_str("Method acl_add_admin doesn't accept deposit");
    }
    #[serde(crate = "near_sdk::serde")]
    struct Input {
        role: String,
        account_id: ::near_sdk::AccountId,
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        use near_sdk::serde as _serde;
        #[automatically_derived]
        impl<'de> near_sdk::serde::Deserialize<'de> for Input {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> near_sdk::serde::__private::Result<Self, __D::Error>
            where
                __D: near_sdk::serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "role" => _serde::__private::Ok(__Field::__field0),
                            "account_id" => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"role" => _serde::__private::Ok(__Field::__field0),
                            b"account_id" => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<Input>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = Input;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct Input",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct Input with 2 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match match _serde::de::SeqAccess::next_element::<
                            ::near_sdk::AccountId,
                        >(&mut __seq) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct Input with 2 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(Input {
                            role: __field0,
                            account_id: __field1,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<
                            ::near_sdk::AccountId,
                        > = _serde::__private::None;
                        while let _serde::__private::Some(__key) = match _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("role"),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<
                                            String,
                                        >(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "account_id",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<
                                            ::near_sdk::AccountId,
                                        >(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                _ => {
                                    let _ = match _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("role") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("account_id") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        _serde::__private::Ok(Input {
                            role: __field0,
                            account_id: __field1,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &["role", "account_id"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "Input",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<Input>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    let Input { role, account_id }: Input = near_sdk::serde_json::from_slice(
            &near_sdk::env::input().expect("Expected input since method has arguments."),
        )
        .expect("Failed to deserialize input from JSON.");
    let mut contract: FastBridge = near_sdk::env::state_read().unwrap_or_default();
    let result = contract.acl_add_admin(role, account_id);
    let result = near_sdk::serde_json::to_vec(&result)
        .expect("Failed to serialize the return value using JSON.");
    near_sdk::env::value_return(&result);
    near_sdk::env::state_write(&contract);
}
#[cfg(target_arch = "wasm32")]
#[no_mangle]
pub extern "C" fn acl_is_admin() {
    near_sdk::env::setup_panic_hook();
    #[serde(crate = "near_sdk::serde")]
    struct Input {
        role: String,
        account_id: ::near_sdk::AccountId,
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        use near_sdk::serde as _serde;
        #[automatically_derived]
        impl<'de> near_sdk::serde::Deserialize<'de> for Input {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> near_sdk::serde::__private::Result<Self, __D::Error>
            where
                __D: near_sdk::serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "role" => _serde::__private::Ok(__Field::__field0),
                            "account_id" => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"role" => _serde::__private::Ok(__Field::__field0),
                            b"account_id" => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<Input>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = Input;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct Input",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct Input with 2 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match match _serde::de::SeqAccess::next_element::<
                            ::near_sdk::AccountId,
                        >(&mut __seq) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct Input with 2 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(Input {
                            role: __field0,
                            account_id: __field1,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<
                            ::near_sdk::AccountId,
                        > = _serde::__private::None;
                        while let _serde::__private::Some(__key) = match _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("role"),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<
                                            String,
                                        >(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "account_id",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<
                                            ::near_sdk::AccountId,
                                        >(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                _ => {
                                    let _ = match _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("role") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("account_id") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        _serde::__private::Ok(Input {
                            role: __field0,
                            account_id: __field1,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &["role", "account_id"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "Input",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<Input>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    let Input { role, account_id }: Input = near_sdk::serde_json::from_slice(
            &near_sdk::env::input().expect("Expected input since method has arguments."),
        )
        .expect("Failed to deserialize input from JSON.");
    let contract: FastBridge = near_sdk::env::state_read().unwrap_or_default();
    let result = contract.acl_is_admin(role, account_id);
    let result = near_sdk::serde_json::to_vec(&result)
        .expect("Failed to serialize the return value using JSON.");
    near_sdk::env::value_return(&result);
}
#[cfg(target_arch = "wasm32")]
#[no_mangle]
pub extern "C" fn acl_revoke_admin() {
    near_sdk::env::setup_panic_hook();
    if near_sdk::env::attached_deposit() != 0 {
        near_sdk::env::panic_str("Method acl_revoke_admin doesn't accept deposit");
    }
    #[serde(crate = "near_sdk::serde")]
    struct Input {
        role: String,
        account_id: ::near_sdk::AccountId,
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        use near_sdk::serde as _serde;
        #[automatically_derived]
        impl<'de> near_sdk::serde::Deserialize<'de> for Input {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> near_sdk::serde::__private::Result<Self, __D::Error>
            where
                __D: near_sdk::serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "role" => _serde::__private::Ok(__Field::__field0),
                            "account_id" => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"role" => _serde::__private::Ok(__Field::__field0),
                            b"account_id" => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<Input>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = Input;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct Input",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct Input with 2 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match match _serde::de::SeqAccess::next_element::<
                            ::near_sdk::AccountId,
                        >(&mut __seq) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct Input with 2 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(Input {
                            role: __field0,
                            account_id: __field1,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<
                            ::near_sdk::AccountId,
                        > = _serde::__private::None;
                        while let _serde::__private::Some(__key) = match _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("role"),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<
                                            String,
                                        >(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "account_id",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<
                                            ::near_sdk::AccountId,
                                        >(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                _ => {
                                    let _ = match _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("role") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("account_id") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        _serde::__private::Ok(Input {
                            role: __field0,
                            account_id: __field1,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &["role", "account_id"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "Input",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<Input>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    let Input { role, account_id }: Input = near_sdk::serde_json::from_slice(
            &near_sdk::env::input().expect("Expected input since method has arguments."),
        )
        .expect("Failed to deserialize input from JSON.");
    let mut contract: FastBridge = near_sdk::env::state_read().unwrap_or_default();
    let result = contract.acl_revoke_admin(role, account_id);
    let result = near_sdk::serde_json::to_vec(&result)
        .expect("Failed to serialize the return value using JSON.");
    near_sdk::env::value_return(&result);
    near_sdk::env::state_write(&contract);
}
#[cfg(target_arch = "wasm32")]
#[no_mangle]
pub extern "C" fn acl_renounce_admin() {
    near_sdk::env::setup_panic_hook();
    if near_sdk::env::attached_deposit() != 0 {
        near_sdk::env::panic_str("Method acl_renounce_admin doesn't accept deposit");
    }
    #[serde(crate = "near_sdk::serde")]
    struct Input {
        role: String,
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        use near_sdk::serde as _serde;
        #[automatically_derived]
        impl<'de> near_sdk::serde::Deserialize<'de> for Input {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> near_sdk::serde::__private::Result<Self, __D::Error>
            where
                __D: near_sdk::serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "role" => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"role" => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<Input>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = Input;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct Input",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct Input with 1 element",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(Input { role: __field0 })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = match _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("role"),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<
                                            String,
                                        >(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                _ => {
                                    let _ = match _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("role") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        _serde::__private::Ok(Input { role: __field0 })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &["role"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "Input",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<Input>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    let Input { role }: Input = near_sdk::serde_json::from_slice(
            &near_sdk::env::input().expect("Expected input since method has arguments."),
        )
        .expect("Failed to deserialize input from JSON.");
    let mut contract: FastBridge = near_sdk::env::state_read().unwrap_or_default();
    let result = contract.acl_renounce_admin(role);
    let result = near_sdk::serde_json::to_vec(&result)
        .expect("Failed to serialize the return value using JSON.");
    near_sdk::env::value_return(&result);
    near_sdk::env::state_write(&contract);
}
#[cfg(target_arch = "wasm32")]
#[no_mangle]
pub extern "C" fn acl_revoke_role() {
    near_sdk::env::setup_panic_hook();
    if near_sdk::env::attached_deposit() != 0 {
        near_sdk::env::panic_str("Method acl_revoke_role doesn't accept deposit");
    }
    #[serde(crate = "near_sdk::serde")]
    struct Input {
        role: String,
        account_id: ::near_sdk::AccountId,
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        use near_sdk::serde as _serde;
        #[automatically_derived]
        impl<'de> near_sdk::serde::Deserialize<'de> for Input {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> near_sdk::serde::__private::Result<Self, __D::Error>
            where
                __D: near_sdk::serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "role" => _serde::__private::Ok(__Field::__field0),
                            "account_id" => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"role" => _serde::__private::Ok(__Field::__field0),
                            b"account_id" => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<Input>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = Input;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct Input",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct Input with 2 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match match _serde::de::SeqAccess::next_element::<
                            ::near_sdk::AccountId,
                        >(&mut __seq) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct Input with 2 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(Input {
                            role: __field0,
                            account_id: __field1,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<
                            ::near_sdk::AccountId,
                        > = _serde::__private::None;
                        while let _serde::__private::Some(__key) = match _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("role"),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<
                                            String,
                                        >(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "account_id",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<
                                            ::near_sdk::AccountId,
                                        >(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                _ => {
                                    let _ = match _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("role") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("account_id") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        _serde::__private::Ok(Input {
                            role: __field0,
                            account_id: __field1,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &["role", "account_id"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "Input",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<Input>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    let Input { role, account_id }: Input = near_sdk::serde_json::from_slice(
            &near_sdk::env::input().expect("Expected input since method has arguments."),
        )
        .expect("Failed to deserialize input from JSON.");
    let mut contract: FastBridge = near_sdk::env::state_read().unwrap_or_default();
    let result = contract.acl_revoke_role(role, account_id);
    let result = near_sdk::serde_json::to_vec(&result)
        .expect("Failed to serialize the return value using JSON.");
    near_sdk::env::value_return(&result);
    near_sdk::env::state_write(&contract);
}
#[cfg(target_arch = "wasm32")]
#[no_mangle]
pub extern "C" fn acl_renounce_role() {
    near_sdk::env::setup_panic_hook();
    if near_sdk::env::attached_deposit() != 0 {
        near_sdk::env::panic_str("Method acl_renounce_role doesn't accept deposit");
    }
    #[serde(crate = "near_sdk::serde")]
    struct Input {
        role: String,
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        use near_sdk::serde as _serde;
        #[automatically_derived]
        impl<'de> near_sdk::serde::Deserialize<'de> for Input {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> near_sdk::serde::__private::Result<Self, __D::Error>
            where
                __D: near_sdk::serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "role" => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"role" => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<Input>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = Input;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct Input",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct Input with 1 element",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(Input { role: __field0 })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = match _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("role"),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<
                                            String,
                                        >(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                _ => {
                                    let _ = match _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("role") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        _serde::__private::Ok(Input { role: __field0 })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &["role"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "Input",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<Input>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    let Input { role }: Input = near_sdk::serde_json::from_slice(
            &near_sdk::env::input().expect("Expected input since method has arguments."),
        )
        .expect("Failed to deserialize input from JSON.");
    let mut contract: FastBridge = near_sdk::env::state_read().unwrap_or_default();
    let result = contract.acl_renounce_role(role);
    let result = near_sdk::serde_json::to_vec(&result)
        .expect("Failed to serialize the return value using JSON.");
    near_sdk::env::value_return(&result);
    near_sdk::env::state_write(&contract);
}
#[cfg(target_arch = "wasm32")]
#[no_mangle]
pub extern "C" fn acl_grant_role() {
    near_sdk::env::setup_panic_hook();
    if near_sdk::env::attached_deposit() != 0 {
        near_sdk::env::panic_str("Method acl_grant_role doesn't accept deposit");
    }
    #[serde(crate = "near_sdk::serde")]
    struct Input {
        role: String,
        account_id: ::near_sdk::AccountId,
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        use near_sdk::serde as _serde;
        #[automatically_derived]
        impl<'de> near_sdk::serde::Deserialize<'de> for Input {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> near_sdk::serde::__private::Result<Self, __D::Error>
            where
                __D: near_sdk::serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "role" => _serde::__private::Ok(__Field::__field0),
                            "account_id" => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"role" => _serde::__private::Ok(__Field::__field0),
                            b"account_id" => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<Input>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = Input;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct Input",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct Input with 2 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match match _serde::de::SeqAccess::next_element::<
                            ::near_sdk::AccountId,
                        >(&mut __seq) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct Input with 2 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(Input {
                            role: __field0,
                            account_id: __field1,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<
                            ::near_sdk::AccountId,
                        > = _serde::__private::None;
                        while let _serde::__private::Some(__key) = match _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("role"),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<
                                            String,
                                        >(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "account_id",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<
                                            ::near_sdk::AccountId,
                                        >(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                _ => {
                                    let _ = match _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("role") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("account_id") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        _serde::__private::Ok(Input {
                            role: __field0,
                            account_id: __field1,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &["role", "account_id"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "Input",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<Input>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    let Input { role, account_id }: Input = near_sdk::serde_json::from_slice(
            &near_sdk::env::input().expect("Expected input since method has arguments."),
        )
        .expect("Failed to deserialize input from JSON.");
    let mut contract: FastBridge = near_sdk::env::state_read().unwrap_or_default();
    let result = contract.acl_grant_role(role, account_id);
    let result = near_sdk::serde_json::to_vec(&result)
        .expect("Failed to serialize the return value using JSON.");
    near_sdk::env::value_return(&result);
    near_sdk::env::state_write(&contract);
}
#[cfg(target_arch = "wasm32")]
#[no_mangle]
pub extern "C" fn acl_has_role() {
    near_sdk::env::setup_panic_hook();
    #[serde(crate = "near_sdk::serde")]
    struct Input {
        role: String,
        account_id: ::near_sdk::AccountId,
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        use near_sdk::serde as _serde;
        #[automatically_derived]
        impl<'de> near_sdk::serde::Deserialize<'de> for Input {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> near_sdk::serde::__private::Result<Self, __D::Error>
            where
                __D: near_sdk::serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "role" => _serde::__private::Ok(__Field::__field0),
                            "account_id" => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"role" => _serde::__private::Ok(__Field::__field0),
                            b"account_id" => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<Input>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = Input;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct Input",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct Input with 2 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match match _serde::de::SeqAccess::next_element::<
                            ::near_sdk::AccountId,
                        >(&mut __seq) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct Input with 2 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(Input {
                            role: __field0,
                            account_id: __field1,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<
                            ::near_sdk::AccountId,
                        > = _serde::__private::None;
                        while let _serde::__private::Some(__key) = match _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("role"),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<
                                            String,
                                        >(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "account_id",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<
                                            ::near_sdk::AccountId,
                                        >(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                _ => {
                                    let _ = match _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("role") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("account_id") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        _serde::__private::Ok(Input {
                            role: __field0,
                            account_id: __field1,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &["role", "account_id"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "Input",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<Input>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    let Input { role, account_id }: Input = near_sdk::serde_json::from_slice(
            &near_sdk::env::input().expect("Expected input since method has arguments."),
        )
        .expect("Failed to deserialize input from JSON.");
    let contract: FastBridge = near_sdk::env::state_read().unwrap_or_default();
    let result = contract.acl_has_role(role, account_id);
    let result = near_sdk::serde_json::to_vec(&result)
        .expect("Failed to serialize the return value using JSON.");
    near_sdk::env::value_return(&result);
}
#[cfg(target_arch = "wasm32")]
#[no_mangle]
pub extern "C" fn acl_has_any_role() {
    near_sdk::env::setup_panic_hook();
    #[serde(crate = "near_sdk::serde")]
    struct Input {
        roles: Vec<String>,
        account_id: ::near_sdk::AccountId,
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        use near_sdk::serde as _serde;
        #[automatically_derived]
        impl<'de> near_sdk::serde::Deserialize<'de> for Input {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> near_sdk::serde::__private::Result<Self, __D::Error>
            where
                __D: near_sdk::serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "roles" => _serde::__private::Ok(__Field::__field0),
                            "account_id" => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"roles" => _serde::__private::Ok(__Field::__field0),
                            b"account_id" => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<Input>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = Input;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct Input",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match match _serde::de::SeqAccess::next_element::<
                            Vec<String>,
                        >(&mut __seq) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct Input with 2 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match match _serde::de::SeqAccess::next_element::<
                            ::near_sdk::AccountId,
                        >(&mut __seq) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct Input with 2 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(Input {
                            roles: __field0,
                            account_id: __field1,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<Vec<String>> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<
                            ::near_sdk::AccountId,
                        > = _serde::__private::None;
                        while let _serde::__private::Some(__key) = match _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("roles"),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<
                                            Vec<String>,
                                        >(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "account_id",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<
                                            ::near_sdk::AccountId,
                                        >(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                _ => {
                                    let _ = match _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("roles") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("account_id") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        _serde::__private::Ok(Input {
                            roles: __field0,
                            account_id: __field1,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &["roles", "account_id"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "Input",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<Input>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    let Input { roles, account_id }: Input = near_sdk::serde_json::from_slice(
            &near_sdk::env::input().expect("Expected input since method has arguments."),
        )
        .expect("Failed to deserialize input from JSON.");
    let contract: FastBridge = near_sdk::env::state_read().unwrap_or_default();
    let result = contract.acl_has_any_role(roles, account_id);
    let result = near_sdk::serde_json::to_vec(&result)
        .expect("Failed to serialize the return value using JSON.");
    near_sdk::env::value_return(&result);
}
#[cfg(target_arch = "wasm32")]
#[no_mangle]
pub extern "C" fn acl_get_super_admins() {
    near_sdk::env::setup_panic_hook();
    #[serde(crate = "near_sdk::serde")]
    struct Input {
        skip: u64,
        limit: u64,
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        use near_sdk::serde as _serde;
        #[automatically_derived]
        impl<'de> near_sdk::serde::Deserialize<'de> for Input {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> near_sdk::serde::__private::Result<Self, __D::Error>
            where
                __D: near_sdk::serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "skip" => _serde::__private::Ok(__Field::__field0),
                            "limit" => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"skip" => _serde::__private::Ok(__Field::__field0),
                            b"limit" => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<Input>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = Input;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct Input",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match match _serde::de::SeqAccess::next_element::<
                            u64,
                        >(&mut __seq) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct Input with 2 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match match _serde::de::SeqAccess::next_element::<
                            u64,
                        >(&mut __seq) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct Input with 2 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(Input {
                            skip: __field0,
                            limit: __field1,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<u64> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<u64> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = match _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("skip"),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<u64>(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("limit"),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<u64>(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                _ => {
                                    let _ = match _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("skip") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("limit") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        _serde::__private::Ok(Input {
                            skip: __field0,
                            limit: __field1,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &["skip", "limit"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "Input",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<Input>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    let Input { skip, limit }: Input = near_sdk::serde_json::from_slice(
            &near_sdk::env::input().expect("Expected input since method has arguments."),
        )
        .expect("Failed to deserialize input from JSON.");
    let contract: FastBridge = near_sdk::env::state_read().unwrap_or_default();
    let result = contract.acl_get_super_admins(skip, limit);
    let result = near_sdk::serde_json::to_vec(&result)
        .expect("Failed to serialize the return value using JSON.");
    near_sdk::env::value_return(&result);
}
#[cfg(target_arch = "wasm32")]
#[no_mangle]
pub extern "C" fn acl_get_admins() {
    near_sdk::env::setup_panic_hook();
    #[serde(crate = "near_sdk::serde")]
    struct Input {
        role: String,
        skip: u64,
        limit: u64,
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        use near_sdk::serde as _serde;
        #[automatically_derived]
        impl<'de> near_sdk::serde::Deserialize<'de> for Input {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> near_sdk::serde::__private::Result<Self, __D::Error>
            where
                __D: near_sdk::serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "role" => _serde::__private::Ok(__Field::__field0),
                            "skip" => _serde::__private::Ok(__Field::__field1),
                            "limit" => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"role" => _serde::__private::Ok(__Field::__field0),
                            b"skip" => _serde::__private::Ok(__Field::__field1),
                            b"limit" => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<Input>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = Input;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct Input",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct Input with 3 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match match _serde::de::SeqAccess::next_element::<
                            u64,
                        >(&mut __seq) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct Input with 3 elements",
                                    ),
                                );
                            }
                        };
                        let __field2 = match match _serde::de::SeqAccess::next_element::<
                            u64,
                        >(&mut __seq) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct Input with 3 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(Input {
                            role: __field0,
                            skip: __field1,
                            limit: __field2,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<u64> = _serde::__private::None;
                        let mut __field2: _serde::__private::Option<u64> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = match _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("role"),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<
                                            String,
                                        >(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("skip"),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<u64>(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("limit"),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<u64>(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                _ => {
                                    let _ = match _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("role") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("skip") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("limit") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        _serde::__private::Ok(Input {
                            role: __field0,
                            skip: __field1,
                            limit: __field2,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &["role", "skip", "limit"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "Input",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<Input>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    let Input { role, skip, limit }: Input = near_sdk::serde_json::from_slice(
            &near_sdk::env::input().expect("Expected input since method has arguments."),
        )
        .expect("Failed to deserialize input from JSON.");
    let contract: FastBridge = near_sdk::env::state_read().unwrap_or_default();
    let result = contract.acl_get_admins(role, skip, limit);
    let result = near_sdk::serde_json::to_vec(&result)
        .expect("Failed to serialize the return value using JSON.");
    near_sdk::env::value_return(&result);
}
#[cfg(target_arch = "wasm32")]
#[no_mangle]
pub extern "C" fn acl_get_grantees() {
    near_sdk::env::setup_panic_hook();
    #[serde(crate = "near_sdk::serde")]
    struct Input {
        role: String,
        skip: u64,
        limit: u64,
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        use near_sdk::serde as _serde;
        #[automatically_derived]
        impl<'de> near_sdk::serde::Deserialize<'de> for Input {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> near_sdk::serde::__private::Result<Self, __D::Error>
            where
                __D: near_sdk::serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "role" => _serde::__private::Ok(__Field::__field0),
                            "skip" => _serde::__private::Ok(__Field::__field1),
                            "limit" => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"role" => _serde::__private::Ok(__Field::__field0),
                            b"skip" => _serde::__private::Ok(__Field::__field1),
                            b"limit" => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<Input>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = Input;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct Input",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct Input with 3 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match match _serde::de::SeqAccess::next_element::<
                            u64,
                        >(&mut __seq) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct Input with 3 elements",
                                    ),
                                );
                            }
                        };
                        let __field2 = match match _serde::de::SeqAccess::next_element::<
                            u64,
                        >(&mut __seq) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct Input with 3 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(Input {
                            role: __field0,
                            skip: __field1,
                            limit: __field2,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<u64> = _serde::__private::None;
                        let mut __field2: _serde::__private::Option<u64> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = match _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("role"),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<
                                            String,
                                        >(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("skip"),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<u64>(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("limit"),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<u64>(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                _ => {
                                    let _ = match _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("role") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("skip") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("limit") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        _serde::__private::Ok(Input {
                            role: __field0,
                            skip: __field1,
                            limit: __field2,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &["role", "skip", "limit"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "Input",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<Input>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    let Input { role, skip, limit }: Input = near_sdk::serde_json::from_slice(
            &near_sdk::env::input().expect("Expected input since method has arguments."),
        )
        .expect("Failed to deserialize input from JSON.");
    let contract: FastBridge = near_sdk::env::state_read().unwrap_or_default();
    let result = contract.acl_get_grantees(role, skip, limit);
    let result = near_sdk::serde_json::to_vec(&result)
        .expect("Failed to serialize the return value using JSON.");
    near_sdk::env::value_return(&result);
}
#[cfg(target_arch = "wasm32")]
#[no_mangle]
pub extern "C" fn acl_get_permissioned_accounts() {
    near_sdk::env::setup_panic_hook();
    let contract: FastBridge = near_sdk::env::state_read().unwrap_or_default();
    let result = contract.acl_get_permissioned_accounts();
    let result = near_sdk::serde_json::to_vec(&result)
        .expect("Failed to serialize the return value using JSON.");
    near_sdk::env::value_return(&result);
}
impl FastBridgeExt {
    pub fn new(
        self,
        eth_bridge_contract: String,
        prover_account: AccountId,
        eth_client_account: AccountId,
        lock_time_min: String,
        lock_time_max: String,
        eth_block_time: Duration,
        whitelist_mode: bool,
        start_nonce: U128,
    ) -> near_sdk::Promise {
        let __args = {
            #[serde(crate = "near_sdk::serde")]
            struct Input<'nearinput> {
                eth_bridge_contract: &'nearinput String,
                prover_account: &'nearinput AccountId,
                eth_client_account: &'nearinput AccountId,
                lock_time_min: &'nearinput String,
                lock_time_max: &'nearinput String,
                eth_block_time: &'nearinput Duration,
                whitelist_mode: &'nearinput bool,
                start_nonce: &'nearinput U128,
            }
            #[doc(hidden)]
            #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
            const _: () = {
                use near_sdk::serde as _serde;
                #[automatically_derived]
                impl<'nearinput> near_sdk::serde::Serialize for Input<'nearinput> {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> near_sdk::serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: near_sdk::serde::Serializer,
                    {
                        let mut __serde_state = match _serde::Serializer::serialize_struct(
                            __serializer,
                            "Input",
                            false as usize + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "eth_bridge_contract",
                            &self.eth_bridge_contract,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "prover_account",
                            &self.prover_account,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "eth_client_account",
                            &self.eth_client_account,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "lock_time_min",
                            &self.lock_time_min,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "lock_time_max",
                            &self.lock_time_max,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "eth_block_time",
                            &self.eth_block_time,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "whitelist_mode",
                            &self.whitelist_mode,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "start_nonce",
                            &self.start_nonce,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            let __args = Input {
                eth_bridge_contract: &eth_bridge_contract,
                prover_account: &prover_account,
                eth_client_account: &eth_client_account,
                lock_time_min: &lock_time_min,
                lock_time_max: &lock_time_max,
                eth_block_time: &eth_block_time,
                whitelist_mode: &whitelist_mode,
                start_nonce: &start_nonce,
            };
            near_sdk::serde_json::to_vec(&__args)
                .expect("Failed to serialize the cross contract args using JSON.")
        };
        near_sdk::Promise::new(self.account_id)
            .function_call_weight(
                "new".to_string(),
                __args,
                self.deposit,
                self.static_gas,
                self.gas_weight,
            )
    }
    pub fn init_transfer(
        self,
        msg: near_sdk::json_types::Base64VecU8,
    ) -> near_sdk::Promise {
        let __args = {
            #[serde(crate = "near_sdk::serde")]
            struct Input<'nearinput> {
                msg: &'nearinput near_sdk::json_types::Base64VecU8,
            }
            #[doc(hidden)]
            #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
            const _: () = {
                use near_sdk::serde as _serde;
                #[automatically_derived]
                impl<'nearinput> near_sdk::serde::Serialize for Input<'nearinput> {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> near_sdk::serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: near_sdk::serde::Serializer,
                    {
                        let mut __serde_state = match _serde::Serializer::serialize_struct(
                            __serializer,
                            "Input",
                            false as usize + 1,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "msg",
                            &self.msg,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            let __args = Input { msg: &msg };
            near_sdk::serde_json::to_vec(&__args)
                .expect("Failed to serialize the cross contract args using JSON.")
        };
        near_sdk::Promise::new(self.account_id)
            .function_call_weight(
                "init_transfer".to_string(),
                __args,
                self.deposit,
                self.static_gas,
                self.gas_weight,
            )
    }
    pub fn init_transfer_callback(
        self,
        transfer_message: TransferMessage,
        sender_id: AccountId,
        update_balance: Option<UpdateBalance>,
    ) -> near_sdk::Promise {
        let __args = {
            struct Input<'nearinput> {
                transfer_message: &'nearinput TransferMessage,
                sender_id: &'nearinput AccountId,
                update_balance: &'nearinput Option<UpdateBalance>,
            }
            impl<'nearinput> borsh::ser::BorshSerialize for Input<'nearinput>
            where
                &'nearinput TransferMessage: borsh::ser::BorshSerialize,
                &'nearinput AccountId: borsh::ser::BorshSerialize,
                &'nearinput Option<UpdateBalance>: borsh::ser::BorshSerialize,
            {
                fn serialize<W: borsh::maybestd::io::Write>(
                    &self,
                    writer: &mut W,
                ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
                    borsh::BorshSerialize::serialize(&self.transfer_message, writer)?;
                    borsh::BorshSerialize::serialize(&self.sender_id, writer)?;
                    borsh::BorshSerialize::serialize(&self.update_balance, writer)?;
                    Ok(())
                }
            }
            let __args = Input {
                transfer_message: &transfer_message,
                sender_id: &sender_id,
                update_balance: &update_balance,
            };
            near_sdk::borsh::BorshSerialize::try_to_vec(&__args)
                .expect("Failed to serialize the cross contract args using Borsh.")
        };
        near_sdk::Promise::new(self.account_id)
            .function_call_weight(
                "init_transfer_callback".to_string(),
                __args,
                self.deposit,
                self.static_gas,
                self.gas_weight,
            )
    }
    pub fn unlock_and_withdraw(
        self,
        nonce: U128,
        proof: near_sdk::json_types::Base64VecU8,
        recipient_id: Option<AccountId>,
    ) -> near_sdk::Promise {
        let __args = {
            #[serde(crate = "near_sdk::serde")]
            struct Input<'nearinput> {
                nonce: &'nearinput U128,
                proof: &'nearinput near_sdk::json_types::Base64VecU8,
                recipient_id: &'nearinput Option<AccountId>,
            }
            #[doc(hidden)]
            #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
            const _: () = {
                use near_sdk::serde as _serde;
                #[automatically_derived]
                impl<'nearinput> near_sdk::serde::Serialize for Input<'nearinput> {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> near_sdk::serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: near_sdk::serde::Serializer,
                    {
                        let mut __serde_state = match _serde::Serializer::serialize_struct(
                            __serializer,
                            "Input",
                            false as usize + 1 + 1 + 1,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "nonce",
                            &self.nonce,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "proof",
                            &self.proof,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "recipient_id",
                            &self.recipient_id,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            let __args = Input {
                nonce: &nonce,
                proof: &proof,
                recipient_id: &recipient_id,
            };
            near_sdk::serde_json::to_vec(&__args)
                .expect("Failed to serialize the cross contract args using JSON.")
        };
        near_sdk::Promise::new(self.account_id)
            .function_call_weight(
                "unlock_and_withdraw".to_string(),
                __args,
                self.deposit,
                self.static_gas,
                self.gas_weight,
            )
    }
    pub fn unlock_and_withdraw_to_aurora_sender(
        self,
        nonce: U128,
        proof: near_sdk::json_types::Base64VecU8,
        recipient_id: AccountId,
        aurora_native_token_account_id: AccountId,
    ) -> near_sdk::Promise {
        let __args = {
            #[serde(crate = "near_sdk::serde")]
            struct Input<'nearinput> {
                nonce: &'nearinput U128,
                proof: &'nearinput near_sdk::json_types::Base64VecU8,
                recipient_id: &'nearinput AccountId,
                aurora_native_token_account_id: &'nearinput AccountId,
            }
            #[doc(hidden)]
            #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
            const _: () = {
                use near_sdk::serde as _serde;
                #[automatically_derived]
                impl<'nearinput> near_sdk::serde::Serialize for Input<'nearinput> {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> near_sdk::serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: near_sdk::serde::Serializer,
                    {
                        let mut __serde_state = match _serde::Serializer::serialize_struct(
                            __serializer,
                            "Input",
                            false as usize + 1 + 1 + 1 + 1,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "nonce",
                            &self.nonce,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "proof",
                            &self.proof,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "recipient_id",
                            &self.recipient_id,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "aurora_native_token_account_id",
                            &self.aurora_native_token_account_id,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            let __args = Input {
                nonce: &nonce,
                proof: &proof,
                recipient_id: &recipient_id,
                aurora_native_token_account_id: &aurora_native_token_account_id,
            };
            near_sdk::serde_json::to_vec(&__args)
                .expect("Failed to serialize the cross contract args using JSON.")
        };
        near_sdk::Promise::new(self.account_id)
            .function_call_weight(
                "unlock_and_withdraw_to_aurora_sender".to_string(),
                __args,
                self.deposit,
                self.static_gas,
                self.gas_weight,
            )
    }
    pub fn unlock_and_withdraw_callback(
        self,
        sender_id: AccountId,
        recipient_id: Option<AccountId>,
        aurora_native_token_account_id: Option<AccountId>,
    ) -> near_sdk::Promise {
        let __args = {
            struct Input<'nearinput> {
                sender_id: &'nearinput AccountId,
                recipient_id: &'nearinput Option<AccountId>,
                aurora_native_token_account_id: &'nearinput Option<AccountId>,
            }
            impl<'nearinput> borsh::ser::BorshSerialize for Input<'nearinput>
            where
                &'nearinput AccountId: borsh::ser::BorshSerialize,
                &'nearinput Option<AccountId>: borsh::ser::BorshSerialize,
                &'nearinput Option<AccountId>: borsh::ser::BorshSerialize,
            {
                fn serialize<W: borsh::maybestd::io::Write>(
                    &self,
                    writer: &mut W,
                ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
                    borsh::BorshSerialize::serialize(&self.sender_id, writer)?;
                    borsh::BorshSerialize::serialize(&self.recipient_id, writer)?;
                    borsh::BorshSerialize::serialize(
                        &self.aurora_native_token_account_id,
                        writer,
                    )?;
                    Ok(())
                }
            }
            let __args = Input {
                sender_id: &sender_id,
                recipient_id: &recipient_id,
                aurora_native_token_account_id: &aurora_native_token_account_id,
            };
            near_sdk::borsh::BorshSerialize::try_to_vec(&__args)
                .expect("Failed to serialize the cross contract args using Borsh.")
        };
        near_sdk::Promise::new(self.account_id)
            .function_call_weight(
                "unlock_and_withdraw_callback".to_string(),
                __args,
                self.deposit,
                self.static_gas,
                self.gas_weight,
            )
    }
    pub fn unlock(
        self,
        nonce: U128,
        proof: near_sdk::json_types::Base64VecU8,
    ) -> near_sdk::Promise {
        let __args = {
            #[serde(crate = "near_sdk::serde")]
            struct Input<'nearinput> {
                nonce: &'nearinput U128,
                proof: &'nearinput near_sdk::json_types::Base64VecU8,
            }
            #[doc(hidden)]
            #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
            const _: () = {
                use near_sdk::serde as _serde;
                #[automatically_derived]
                impl<'nearinput> near_sdk::serde::Serialize for Input<'nearinput> {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> near_sdk::serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: near_sdk::serde::Serializer,
                    {
                        let mut __serde_state = match _serde::Serializer::serialize_struct(
                            __serializer,
                            "Input",
                            false as usize + 1 + 1,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "nonce",
                            &self.nonce,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "proof",
                            &self.proof,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            let __args = Input {
                nonce: &nonce,
                proof: &proof,
            };
            near_sdk::serde_json::to_vec(&__args)
                .expect("Failed to serialize the cross contract args using JSON.")
        };
        near_sdk::Promise::new(self.account_id)
            .function_call_weight(
                "unlock".to_string(),
                __args,
                self.deposit,
                self.static_gas,
                self.gas_weight,
            )
    }
    pub fn unlock_callback(
        self,
        nonce: U128,
        sender_id: AccountId,
    ) -> near_sdk::Promise {
        let __args = {
            struct Input<'nearinput> {
                nonce: &'nearinput U128,
                sender_id: &'nearinput AccountId,
            }
            impl<'nearinput> borsh::ser::BorshSerialize for Input<'nearinput>
            where
                &'nearinput U128: borsh::ser::BorshSerialize,
                &'nearinput AccountId: borsh::ser::BorshSerialize,
            {
                fn serialize<W: borsh::maybestd::io::Write>(
                    &self,
                    writer: &mut W,
                ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
                    borsh::BorshSerialize::serialize(&self.nonce, writer)?;
                    borsh::BorshSerialize::serialize(&self.sender_id, writer)?;
                    Ok(())
                }
            }
            let __args = Input {
                nonce: &nonce,
                sender_id: &sender_id,
            };
            near_sdk::borsh::BorshSerialize::try_to_vec(&__args)
                .expect("Failed to serialize the cross contract args using Borsh.")
        };
        near_sdk::Promise::new(self.account_id)
            .function_call_weight(
                "unlock_callback".to_string(),
                __args,
                self.deposit,
                self.static_gas,
                self.gas_weight,
            )
    }
    pub fn lp_unlock(self, proof: Proof) -> near_sdk::Promise {
        let __args = {
            #[serde(crate = "near_sdk::serde")]
            struct Input<'nearinput> {
                proof: &'nearinput Proof,
            }
            #[doc(hidden)]
            #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
            const _: () = {
                use near_sdk::serde as _serde;
                #[automatically_derived]
                impl<'nearinput> near_sdk::serde::Serialize for Input<'nearinput> {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> near_sdk::serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: near_sdk::serde::Serializer,
                    {
                        let mut __serde_state = match _serde::Serializer::serialize_struct(
                            __serializer,
                            "Input",
                            false as usize + 1,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "proof",
                            &self.proof,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            let __args = Input { proof: &proof };
            near_sdk::serde_json::to_vec(&__args)
                .expect("Failed to serialize the cross contract args using JSON.")
        };
        near_sdk::Promise::new(self.account_id)
            .function_call_weight(
                "lp_unlock".to_string(),
                __args,
                self.deposit,
                self.static_gas,
                self.gas_weight,
            )
    }
    pub fn unlock_stuck_transfer(
        self,
        nonce: U128,
        recipient_id: AccountId,
    ) -> near_sdk::Promise {
        let __args = {
            #[serde(crate = "near_sdk::serde")]
            struct Input<'nearinput> {
                nonce: &'nearinput U128,
                recipient_id: &'nearinput AccountId,
            }
            #[doc(hidden)]
            #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
            const _: () = {
                use near_sdk::serde as _serde;
                #[automatically_derived]
                impl<'nearinput> near_sdk::serde::Serialize for Input<'nearinput> {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> near_sdk::serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: near_sdk::serde::Serializer,
                    {
                        let mut __serde_state = match _serde::Serializer::serialize_struct(
                            __serializer,
                            "Input",
                            false as usize + 1 + 1,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "nonce",
                            &self.nonce,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "recipient_id",
                            &self.recipient_id,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            let __args = Input {
                nonce: &nonce,
                recipient_id: &recipient_id,
            };
            near_sdk::serde_json::to_vec(&__args)
                .expect("Failed to serialize the cross contract args using JSON.")
        };
        near_sdk::Promise::new(self.account_id)
            .function_call_weight(
                "unlock_stuck_transfer".to_string(),
                __args,
                self.deposit,
                self.static_gas,
                self.gas_weight,
            )
    }
    pub fn verify_log_entry_callback(
        self,
        proof: EthTransferEvent,
    ) -> near_sdk::Promise {
        let __args = {
            struct Input<'nearinput> {
                proof: &'nearinput EthTransferEvent,
            }
            impl<'nearinput> borsh::ser::BorshSerialize for Input<'nearinput>
            where
                &'nearinput EthTransferEvent: borsh::ser::BorshSerialize,
            {
                fn serialize<W: borsh::maybestd::io::Write>(
                    &self,
                    writer: &mut W,
                ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
                    borsh::BorshSerialize::serialize(&self.proof, writer)?;
                    Ok(())
                }
            }
            let __args = Input { proof: &proof };
            near_sdk::borsh::BorshSerialize::try_to_vec(&__args)
                .expect("Failed to serialize the cross contract args using Borsh.")
        };
        near_sdk::Promise::new(self.account_id)
            .function_call_weight(
                "verify_log_entry_callback".to_string(),
                __args,
                self.deposit,
                self.static_gas,
                self.gas_weight,
            )
    }
    pub fn get_user_balance(
        self,
        account_id: &AccountId,
        token_id: &AccountId,
    ) -> near_sdk::Promise {
        let __args = {
            #[serde(crate = "near_sdk::serde")]
            struct Input<'nearinput> {
                account_id: &'nearinput AccountId,
                token_id: &'nearinput AccountId,
            }
            #[doc(hidden)]
            #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
            const _: () = {
                use near_sdk::serde as _serde;
                #[automatically_derived]
                impl<'nearinput> near_sdk::serde::Serialize for Input<'nearinput> {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> near_sdk::serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: near_sdk::serde::Serializer,
                    {
                        let mut __serde_state = match _serde::Serializer::serialize_struct(
                            __serializer,
                            "Input",
                            false as usize + 1 + 1,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "account_id",
                            &self.account_id,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "token_id",
                            &self.token_id,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            let __args = Input {
                account_id: &account_id,
                token_id: &token_id,
            };
            near_sdk::serde_json::to_vec(&__args)
                .expect("Failed to serialize the cross contract args using JSON.")
        };
        near_sdk::Promise::new(self.account_id)
            .function_call_weight(
                "get_user_balance".to_string(),
                __args,
                self.deposit,
                self.static_gas,
                self.gas_weight,
            )
    }
    pub fn withdraw(
        self,
        token_id: AccountId,
        amount: Option<U128>,
        recipient_id: Option<AccountId>,
        msg: Option<String>,
    ) -> near_sdk::Promise {
        let __args = {
            #[serde(crate = "near_sdk::serde")]
            struct Input<'nearinput> {
                token_id: &'nearinput AccountId,
                amount: &'nearinput Option<U128>,
                recipient_id: &'nearinput Option<AccountId>,
                msg: &'nearinput Option<String>,
            }
            #[doc(hidden)]
            #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
            const _: () = {
                use near_sdk::serde as _serde;
                #[automatically_derived]
                impl<'nearinput> near_sdk::serde::Serialize for Input<'nearinput> {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> near_sdk::serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: near_sdk::serde::Serializer,
                    {
                        let mut __serde_state = match _serde::Serializer::serialize_struct(
                            __serializer,
                            "Input",
                            false as usize + 1 + 1 + 1 + 1,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "token_id",
                            &self.token_id,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "amount",
                            &self.amount,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "recipient_id",
                            &self.recipient_id,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "msg",
                            &self.msg,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            let __args = Input {
                token_id: &token_id,
                amount: &amount,
                recipient_id: &recipient_id,
                msg: &msg,
            };
            near_sdk::serde_json::to_vec(&__args)
                .expect("Failed to serialize the cross contract args using JSON.")
        };
        near_sdk::Promise::new(self.account_id)
            .function_call_weight(
                "withdraw".to_string(),
                __args,
                self.deposit,
                self.static_gas,
                self.gas_weight,
            )
    }
    pub fn withdraw_callback(
        self,
        token_id: AccountId,
        amount: U128,
        recipient_id: AccountId,
    ) -> near_sdk::Promise {
        let __args = {
            #[serde(crate = "near_sdk::serde")]
            struct Input<'nearinput> {
                token_id: &'nearinput AccountId,
                amount: &'nearinput U128,
                recipient_id: &'nearinput AccountId,
            }
            #[doc(hidden)]
            #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
            const _: () = {
                use near_sdk::serde as _serde;
                #[automatically_derived]
                impl<'nearinput> near_sdk::serde::Serialize for Input<'nearinput> {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> near_sdk::serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: near_sdk::serde::Serializer,
                    {
                        let mut __serde_state = match _serde::Serializer::serialize_struct(
                            __serializer,
                            "Input",
                            false as usize + 1 + 1 + 1,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "token_id",
                            &self.token_id,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "amount",
                            &self.amount,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "recipient_id",
                            &self.recipient_id,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            let __args = Input {
                token_id: &token_id,
                amount: &amount,
                recipient_id: &recipient_id,
            };
            near_sdk::serde_json::to_vec(&__args)
                .expect("Failed to serialize the cross contract args using JSON.")
        };
        near_sdk::Promise::new(self.account_id)
            .function_call_weight(
                "withdraw_callback".to_string(),
                __args,
                self.deposit,
                self.static_gas,
                self.gas_weight,
            )
    }
    pub fn set_prover_account(self, prover_account: AccountId) -> near_sdk::Promise {
        let __args = {
            #[serde(crate = "near_sdk::serde")]
            struct Input<'nearinput> {
                prover_account: &'nearinput AccountId,
            }
            #[doc(hidden)]
            #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
            const _: () = {
                use near_sdk::serde as _serde;
                #[automatically_derived]
                impl<'nearinput> near_sdk::serde::Serialize for Input<'nearinput> {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> near_sdk::serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: near_sdk::serde::Serializer,
                    {
                        let mut __serde_state = match _serde::Serializer::serialize_struct(
                            __serializer,
                            "Input",
                            false as usize + 1,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "prover_account",
                            &self.prover_account,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            let __args = Input {
                prover_account: &prover_account,
            };
            near_sdk::serde_json::to_vec(&__args)
                .expect("Failed to serialize the cross contract args using JSON.")
        };
        near_sdk::Promise::new(self.account_id)
            .function_call_weight(
                "set_prover_account".to_string(),
                __args,
                self.deposit,
                self.static_gas,
                self.gas_weight,
            )
    }
    pub fn set_eth_client_account(self, account_id: AccountId) -> near_sdk::Promise {
        let __args = {
            #[serde(crate = "near_sdk::serde")]
            struct Input<'nearinput> {
                account_id: &'nearinput AccountId,
            }
            #[doc(hidden)]
            #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
            const _: () = {
                use near_sdk::serde as _serde;
                #[automatically_derived]
                impl<'nearinput> near_sdk::serde::Serialize for Input<'nearinput> {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> near_sdk::serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: near_sdk::serde::Serializer,
                    {
                        let mut __serde_state = match _serde::Serializer::serialize_struct(
                            __serializer,
                            "Input",
                            false as usize + 1,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "account_id",
                            &self.account_id,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            let __args = Input { account_id: &account_id };
            near_sdk::serde_json::to_vec(&__args)
                .expect("Failed to serialize the cross contract args using JSON.")
        };
        near_sdk::Promise::new(self.account_id)
            .function_call_weight(
                "set_eth_client_account".to_string(),
                __args,
                self.deposit,
                self.static_gas,
                self.gas_weight,
            )
    }
    pub fn set_eth_bridge_contract_address(self, address: String) -> near_sdk::Promise {
        let __args = {
            #[serde(crate = "near_sdk::serde")]
            struct Input<'nearinput> {
                address: &'nearinput String,
            }
            #[doc(hidden)]
            #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
            const _: () = {
                use near_sdk::serde as _serde;
                #[automatically_derived]
                impl<'nearinput> near_sdk::serde::Serialize for Input<'nearinput> {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> near_sdk::serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: near_sdk::serde::Serializer,
                    {
                        let mut __serde_state = match _serde::Serializer::serialize_struct(
                            __serializer,
                            "Input",
                            false as usize + 1,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "address",
                            &self.address,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            let __args = Input { address: &address };
            near_sdk::serde_json::to_vec(&__args)
                .expect("Failed to serialize the cross contract args using JSON.")
        };
        near_sdk::Promise::new(self.account_id)
            .function_call_weight(
                "set_eth_bridge_contract_address".to_string(),
                __args,
                self.deposit,
                self.static_gas,
                self.gas_weight,
            )
    }
    pub fn get_lock_duration(self) -> near_sdk::Promise {
        let __args = ::alloc::vec::Vec::new();
        near_sdk::Promise::new(self.account_id)
            .function_call_weight(
                "get_lock_duration".to_string(),
                __args,
                self.deposit,
                self.static_gas,
                self.gas_weight,
            )
    }
    pub fn get_pending_balance(self, token_id: AccountId) -> near_sdk::Promise {
        let __args = {
            #[serde(crate = "near_sdk::serde")]
            struct Input<'nearinput> {
                token_id: &'nearinput AccountId,
            }
            #[doc(hidden)]
            #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
            const _: () = {
                use near_sdk::serde as _serde;
                #[automatically_derived]
                impl<'nearinput> near_sdk::serde::Serialize for Input<'nearinput> {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> near_sdk::serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: near_sdk::serde::Serializer,
                    {
                        let mut __serde_state = match _serde::Serializer::serialize_struct(
                            __serializer,
                            "Input",
                            false as usize + 1,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "token_id",
                            &self.token_id,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            let __args = Input { token_id: &token_id };
            near_sdk::serde_json::to_vec(&__args)
                .expect("Failed to serialize the cross contract args using JSON.")
        };
        near_sdk::Promise::new(self.account_id)
            .function_call_weight(
                "get_pending_balance".to_string(),
                __args,
                self.deposit,
                self.static_gas,
                self.gas_weight,
            )
    }
    pub fn get_pending_transfers(
        self,
        from_index: usize,
        limit: usize,
    ) -> near_sdk::Promise {
        let __args = {
            #[serde(crate = "near_sdk::serde")]
            struct Input<'nearinput> {
                from_index: &'nearinput usize,
                limit: &'nearinput usize,
            }
            #[doc(hidden)]
            #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
            const _: () = {
                use near_sdk::serde as _serde;
                #[automatically_derived]
                impl<'nearinput> near_sdk::serde::Serialize for Input<'nearinput> {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> near_sdk::serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: near_sdk::serde::Serializer,
                    {
                        let mut __serde_state = match _serde::Serializer::serialize_struct(
                            __serializer,
                            "Input",
                            false as usize + 1 + 1,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "from_index",
                            &self.from_index,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "limit",
                            &self.limit,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            let __args = Input {
                from_index: &from_index,
                limit: &limit,
            };
            near_sdk::serde_json::to_vec(&__args)
                .expect("Failed to serialize the cross contract args using JSON.")
        };
        near_sdk::Promise::new(self.account_id)
            .function_call_weight(
                "get_pending_transfers".to_string(),
                __args,
                self.deposit,
                self.static_gas,
                self.gas_weight,
            )
    }
    pub fn get_pending_transfer(self, id: String) -> near_sdk::Promise {
        let __args = {
            #[serde(crate = "near_sdk::serde")]
            struct Input<'nearinput> {
                id: &'nearinput String,
            }
            #[doc(hidden)]
            #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
            const _: () = {
                use near_sdk::serde as _serde;
                #[automatically_derived]
                impl<'nearinput> near_sdk::serde::Serialize for Input<'nearinput> {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> near_sdk::serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: near_sdk::serde::Serializer,
                    {
                        let mut __serde_state = match _serde::Serializer::serialize_struct(
                            __serializer,
                            "Input",
                            false as usize + 1,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "id",
                            &self.id,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            let __args = Input { id: &id };
            near_sdk::serde_json::to_vec(&__args)
                .expect("Failed to serialize the cross contract args using JSON.")
        };
        near_sdk::Promise::new(self.account_id)
            .function_call_weight(
                "get_pending_transfer".to_string(),
                __args,
                self.deposit,
                self.static_gas,
                self.gas_weight,
            )
    }
    pub fn set_lock_time(
        self,
        lock_time_min: String,
        lock_time_max: String,
    ) -> near_sdk::Promise {
        let __args = {
            #[serde(crate = "near_sdk::serde")]
            struct Input<'nearinput> {
                lock_time_min: &'nearinput String,
                lock_time_max: &'nearinput String,
            }
            #[doc(hidden)]
            #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
            const _: () = {
                use near_sdk::serde as _serde;
                #[automatically_derived]
                impl<'nearinput> near_sdk::serde::Serialize for Input<'nearinput> {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> near_sdk::serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: near_sdk::serde::Serializer,
                    {
                        let mut __serde_state = match _serde::Serializer::serialize_struct(
                            __serializer,
                            "Input",
                            false as usize + 1 + 1,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "lock_time_min",
                            &self.lock_time_min,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "lock_time_max",
                            &self.lock_time_max,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            let __args = Input {
                lock_time_min: &lock_time_min,
                lock_time_max: &lock_time_max,
            };
            near_sdk::serde_json::to_vec(&__args)
                .expect("Failed to serialize the cross contract args using JSON.")
        };
        near_sdk::Promise::new(self.account_id)
            .function_call_weight(
                "set_lock_time".to_string(),
                __args,
                self.deposit,
                self.static_gas,
                self.gas_weight,
            )
    }
}
impl FastBridge {
    pub fn new(
        eth_bridge_contract: String,
        prover_account: AccountId,
        eth_client_account: AccountId,
        lock_time_min: String,
        lock_time_max: String,
        eth_block_time: Duration,
        whitelist_mode: bool,
        start_nonce: U128,
    ) -> Self {
        let lock_time_min: u64 = parse(lock_time_min.as_str())
            .unwrap()
            .as_nanos()
            .try_into()
            .unwrap();
        let lock_time_max: u64 = parse(lock_time_max.as_str())
            .unwrap()
            .as_nanos()
            .try_into()
            .unwrap();
        if true {
            let msg: &str = &"Error initialize: lock_time_min must be less than lock_time_max";
            if !(lock_time_max > lock_time_min) {
                {
                    ::core::panicking::panic_display(&msg);
                }
            }
        } else if !(lock_time_max > lock_time_min) {
            ::near_sdk::env::panic_str(
                &"Error initialize: lock_time_min must be less than lock_time_max",
            )
        }
        let mut contract = Self {
            pending_transfers: UnorderedMap::new(StorageKey::PendingTransfers),
            pending_transfers_balances: UnorderedMap::new(
                StorageKey::PendingTransfersBalances,
            ),
            token_balances: LookupMap::new(StorageKey::TokenBalances),
            nonce: start_nonce.0,
            prover_account,
            eth_client_account,
            eth_bridge_contract: get_eth_address(eth_bridge_contract),
            lock_duration: LockDuration {
                lock_time_min,
                lock_time_max,
            },
            eth_block_time,
            whitelist_tokens: UnorderedMap::new(StorageKey::WhitelistTokens),
            whitelist_accounts: UnorderedSet::new(StorageKey::WhitelistAccounts),
            is_whitelist_mode_enabled: whitelist_mode,
        };
        if true {
            let msg: &str = &"Failed to initialize super admin";
            if !contract.acl_init_super_admin(near_sdk::env::predecessor_account_id()) {
                {
                    ::core::panicking::panic_display(&msg);
                }
            }
        } else if !contract.acl_init_super_admin(near_sdk::env::predecessor_account_id())
        {
            ::near_sdk::env::panic_str(&"Failed to initialize super admin")
        }
        contract
    }
    /// Initializes a token transfer from NEAR to Ethereum using the provided `TransferMessage`.
    ///
    /// This function is called by the NEAR Fast Bridge contract to initiate a token transfer to Ethereum. The `msg` parameter is a `Base64VecU8` containing the encoded `TransferMessage`. The function decodes the `msg` parameter, checks its validity, and then calls `init_transfer_internal` to initiate the token transfer.
    ///
    /// # Arguments
    ///
    /// * `msg` -- the encoded `TransferMessage` in borsh Base64 format. It contains details about the transaction - `token`, `fee_token`, `amount`, `recipient`, etc.
    pub fn init_transfer(
        &mut self,
        msg: near_sdk::json_types::Base64VecU8,
    ) -> PromiseOrValue<U128> {
        let mut __check_paused = true;
        let __except_roles: Vec<&str> = ::alloc::vec::Vec::new();
        let __except_roles: Vec<String> = __except_roles
            .iter()
            .map(|&x| x.into())
            .collect();
        let may_bypass = self
            .acl_has_any_role(__except_roles, ::near_sdk::env::predecessor_account_id());
        if may_bypass {
            __check_paused = false;
        }
        if __check_paused {
            if true {
                let msg: &str = &"Pausable: Method is paused";
                if !!self.pa_is_paused("init_transfer".to_string()) {
                    {
                        ::core::panicking::panic_display(&msg);
                    }
                }
            } else if !!self.pa_is_paused("init_transfer".to_string()) {
                ::near_sdk::env::panic_str(&"Pausable: Method is paused")
            }
        }
        let transfer_message = TransferMessage::try_from_slice(&msg.0)
            .unwrap_or_else(|_| env::panic_str(
                "Invalid borsh format of the `TransferMessage`",
            ));
        self.init_transfer_internal(
                transfer_message,
                env::predecessor_account_id(),
                None,
            )
            .into()
    }
    fn init_transfer_internal(
        &mut self,
        transfer_message: TransferMessage,
        sender_id: AccountId,
        update_balance: Option<UpdateBalance>,
    ) -> Promise {
        near_sdk::env::log_str(
            &near_sdk::serde_json::to_string(&transfer_message).unwrap(),
        );
        ext_eth_client::ext(self.eth_client_account.clone())
            .with_static_gas(utils::tera_gas(5))
            .last_block_number()
            .then(
                ext_self::ext(env::current_account_id())
                    .with_static_gas(utils::tera_gas(50))
                    .init_transfer_callback(transfer_message, sender_id, update_balance),
            )
    }
    /// This function finalizes the execution flow of the `init_transfer()` function. This function
    /// is called from the `Eth2Client` contract after extracting the last Ethereum block number on Near.
    /// This function validates the transfer message and decreases the token transfer balance and fee
    /// balance for the sender. If an `update_balance` is provided, it increases the sender's balance
    /// accordingly and emits a `FastBridgeDepositEvent`. It then stores the transfer and emits a
    /// `FastBridgeInitTransferEvent` with the `nonce`, `sender_id`, and `transfer_message`.
    ///
    /// # Arguments
    ///
    /// * `last_block_height` -- the last Ethereum block height in LightClient on Near.
    ///
    /// * `transfer_message` -- the details about the transaction: token, fee token, amount, recipient, etc.
    ///    The `TransferMessage` is deserialized from a Borsh-encoded string.
    ///
    /// * `sender_id` -- the account which initiates this transfer.
    ///    The `AccountId` is deserialized from a Borsh-encoded string.
    ///
    /// * `update_balance` -- balance update in case the transfer of tokens and initialization of the transfer
    ///    happen in one transaction. The `UpdateBalance` is deserialized from a Borsh-encoded string.
    pub fn init_transfer_callback(
        &mut self,
        last_block_height: u64,
        transfer_message: TransferMessage,
        sender_id: AccountId,
        update_balance: Option<UpdateBalance>,
    ) -> U128 {
        if true {
            let msg: &str = &"The fee token does not match the transfer token";
            if !(transfer_message.fee.token == transfer_message.transfer.token_near) {
                {
                    ::core::panicking::panic_display(&msg);
                }
            }
        } else if !(transfer_message.fee.token == transfer_message.transfer.token_near) {
            ::near_sdk::env::panic_str(
                &"The fee token does not match the transfer token",
            )
        }
        if true {
            let msg: &str = &"The eth token address and recipient address can't be the same";
            if !(transfer_message.transfer.token_eth != transfer_message.recipient) {
                {
                    ::core::panicking::panic_display(&msg);
                }
            }
        } else if !(transfer_message.transfer.token_eth != transfer_message.recipient) {
            ::near_sdk::env::panic_str(
                &"The eth token address and recipient address can't be the same",
            )
        }
        if let Some(update_balance) = update_balance.as_ref() {
            self.increase_balance(
                &update_balance.sender_id,
                &update_balance.token,
                &update_balance.amount.0,
            );
        }
        let mut transfer_message = transfer_message;
        let lock_period = transfer_message.valid_till - block_timestamp();
        transfer_message
            .valid_till_block_height = Some(
            last_block_height + lock_period / self.eth_block_time,
        );
        self.validate_transfer_message(&transfer_message, &sender_id);
        let token_transfer_balance = self
            .get_user_balance(&sender_id, &transfer_message.transfer.token_near);
        if true {
            let msg: &str = &"Not enough transfer token balance.";
            if !(token_transfer_balance >= transfer_message.transfer.amount) {
                {
                    ::core::panicking::panic_display(&msg);
                }
            }
        } else if !(token_transfer_balance >= transfer_message.transfer.amount) {
            ::near_sdk::env::panic_str(&"Not enough transfer token balance.")
        }
        self.decrease_balance(
            &sender_id,
            &transfer_message.transfer.token_near,
            &transfer_message.transfer.amount.0,
        );
        let token_fee_balance = self
            .get_user_balance(&sender_id, &transfer_message.fee.token);
        if true {
            let msg: &str = &"Not enough fee token balance.";
            if !(token_fee_balance >= transfer_message.fee.amount) {
                {
                    ::core::panicking::panic_display(&msg);
                }
            }
        } else if !(token_fee_balance >= transfer_message.fee.amount) {
            ::near_sdk::env::panic_str(&"Not enough fee token balance.")
        }
        self.decrease_balance(
            &sender_id,
            &transfer_message.fee.token,
            &transfer_message.fee.amount.0,
        );
        let nonce = U128::from(
            self.store_transfers(sender_id.clone(), transfer_message.clone()),
        );
        if let Some(update_balance) = update_balance {
            Event::FastBridgeDepositEvent {
                sender_id: update_balance.sender_id,
                token: update_balance.token,
                amount: update_balance.amount,
            }
                .emit();
        }
        Event::FastBridgeInitTransferEvent {
            nonce,
            sender_id,
            transfer_message,
        }
            .emit();
        U128::from(0)
    }
    pub fn unlock_and_withdraw(
        &self,
        nonce: U128,
        proof: near_sdk::json_types::Base64VecU8,
        recipient_id: Option<AccountId>,
    ) -> Promise {
        let mut __check_paused = true;
        let __except_roles: Vec<&str> = <[_]>::into_vec(
            #[rustc_box]
            ::alloc::boxed::Box::new([Role::UnrestrictedUnlock.into()]),
        );
        let __except_roles: Vec<String> = __except_roles
            .iter()
            .map(|&x| x.into())
            .collect();
        let may_bypass = self
            .acl_has_any_role(__except_roles, ::near_sdk::env::predecessor_account_id());
        if may_bypass {
            __check_paused = false;
        }
        if __check_paused {
            if true {
                let msg: &str = &"Pausable: Method is paused";
                if !!self.pa_is_paused("unlock_and_withdraw".to_string()) {
                    {
                        ::core::panicking::panic_display(&msg);
                    }
                }
            } else if !!self.pa_is_paused("unlock_and_withdraw".to_string()) {
                ::near_sdk::env::panic_str(&"Pausable: Method is paused")
            }
        }
        self.unlock(nonce, proof)
            .then(
                ext_self::ext(current_account_id())
                    .with_static_gas(utils::tera_gas(75))
                    .with_attached_deposit(utils::NO_DEPOSIT)
                    .unlock_and_withdraw_callback(
                        env::predecessor_account_id(),
                        recipient_id,
                        None,
                    ),
            )
    }
    pub fn unlock_and_withdraw_to_aurora_sender(
        &self,
        nonce: U128,
        proof: near_sdk::json_types::Base64VecU8,
        recipient_id: AccountId,
        aurora_native_token_account_id: AccountId,
    ) -> Promise {
        let mut __check_paused = true;
        let __except_roles: Vec<&str> = <[_]>::into_vec(
            #[rustc_box]
            ::alloc::boxed::Box::new([Role::UnrestrictedUnlock.into()]),
        );
        let __except_roles: Vec<String> = __except_roles
            .iter()
            .map(|&x| x.into())
            .collect();
        let may_bypass = self
            .acl_has_any_role(__except_roles, ::near_sdk::env::predecessor_account_id());
        if may_bypass {
            __check_paused = false;
        }
        if __check_paused {
            if true {
                let msg: &str = &"Pausable: Method is paused";
                if !!self
                    .pa_is_paused("unlock_and_withdraw_to_aurora_sender".to_string())
                {
                    {
                        ::core::panicking::panic_display(&msg);
                    }
                }
            } else if !!self
                .pa_is_paused("unlock_and_withdraw_to_aurora_sender".to_string())
            {
                ::near_sdk::env::panic_str(&"Pausable: Method is paused")
            }
        }
        self.unlock(nonce, proof)
            .then(
                ext_self::ext(current_account_id())
                    .with_static_gas(utils::tera_gas(75))
                    .with_attached_deposit(utils::NO_DEPOSIT)
                    .unlock_and_withdraw_callback(
                        env::predecessor_account_id(),
                        Some(recipient_id),
                        Some(aurora_native_token_account_id),
                    ),
            )
    }
    pub fn unlock_and_withdraw_callback(
        &mut self,
        transfer_data: TransferMessage,
        sender_id: AccountId,
        recipient_id: Option<AccountId>,
        aurora_native_token_account_id: Option<AccountId>,
    ) -> Promise {
        let msg = match aurora_native_token_account_id {
            Some(native_token) => {
                let aurora_sender = transfer_data
                    .aurora_sender
                    .unwrap_or_else(|| env::panic_str("Aurora sender can't be None"));
                let aurora_sender_hex = hex::encode(aurora_sender.0);
                if native_token == transfer_data.transfer.token_near {
                    Some({
                        let res = ::alloc::fmt::format(
                            format_args!(
                                "fake.near:0000000000000000000000000000000000000000000000000000000000000000{0}",
                                aurora_sender_hex,
                            ),
                        );
                        res
                    })
                } else {
                    Some(aurora_sender_hex)
                }
            }
            None => None,
        };
        self.withdraw_internal(
            transfer_data.transfer.token_near,
            None,
            sender_id,
            recipient_id,
            msg,
        )
    }
    /// Unlocks the transfer with the given `nonce`, using the provided `proof` of the non-existence
    /// of the transfer on Ethereum. The unlock could be possible only if the transfer on Ethereum
    /// didn't happen and its validity time is already expired.
    /// The function could be executed successfully by any account that provides proof.
    ///
    /// Note If the function is paused, only the account that has the `UnrestrictedUnlock` role is allowed to perform an unlock.
    ///
    /// # Arguments
    ///
    /// * `nonce` - A unique identifier of the transfer.
    /// * `proof` - A Base64-encoded proof of the non-existence of the transfer on Ethereum after the `valid_till` timestamp is passed.
    pub fn unlock(
        &self,
        nonce: U128,
        proof: near_sdk::json_types::Base64VecU8,
    ) -> Promise {
        let mut __check_paused = true;
        let __except_roles: Vec<&str> = <[_]>::into_vec(
            #[rustc_box]
            ::alloc::boxed::Box::new([Role::UnrestrictedUnlock.into()]),
        );
        let __except_roles: Vec<String> = __except_roles
            .iter()
            .map(|&x| x.into())
            .collect();
        let may_bypass = self
            .acl_has_any_role(__except_roles, ::near_sdk::env::predecessor_account_id());
        if may_bypass {
            __check_paused = false;
        }
        if __check_paused {
            if true {
                let msg: &str = &"Pausable: Method is paused";
                if !!self.pa_is_paused("unlock".to_string()) {
                    {
                        ::core::panicking::panic_display(&msg);
                    }
                }
            } else if !!self.pa_is_paused("unlock".to_string()) {
                ::near_sdk::env::panic_str(&"Pausable: Method is paused")
            }
        }
        let proof = UnlockProof::try_from_slice(&proof.0)
            .unwrap_or_else(|_| env::panic_str(
                "Invalid borsh format of the `UnlockProof`",
            ));
        let (_recipient_id, transfer_data) = self
            .get_pending_transfer(nonce.0.to_string())
            .unwrap_or_else(|| near_sdk::env::panic_str("Transfer not found"));
        let storage_key_hash = utils::get_eth_storage_key_hash(
            transfer_data.transfer.token_eth,
            transfer_data.recipient,
            eth_types::U256(nonce.0.into()),
            eth_types::U256(transfer_data.transfer.amount.0.into()),
        );
        let expected_storage_value = ::alloc::vec::Vec::new();
        ext_prover::ext(self.prover_account.clone())
            .with_static_gas(utils::tera_gas(50))
            .with_attached_deposit(utils::NO_DEPOSIT)
            .verify_storage_proof(
                proof.header_data,
                proof.account_proof,
                self.eth_bridge_contract.0.to_vec(),
                proof.account_data,
                storage_key_hash,
                proof.storage_proof,
                expected_storage_value,
                transfer_data.valid_till_block_height,
                None,
                false,
            )
            .then(
                ext_self::ext(current_account_id())
                    .with_static_gas(utils::tera_gas(5))
                    .with_attached_deposit(utils::NO_DEPOSIT)
                    .unlock_callback(nonce, env::predecessor_account_id()),
            )
    }
    /// This function finalizes the execution flow of the `unlock()` function. This function
    /// is called as a callback from the `EthProver` contract after the `proof` of the non-existence
    /// of the transfer has been verified. It unlocks the transfer specified by the nonce, returns the appropriate
    /// amount of locked tokens to the transfer creator, and emits a `FastBridgeUnlockEvent`
    /// with the details of the unlocked transfer.
    ///
    /// This function is only intended for internal use and should not be called directly by external accounts.
    ///
    /// # Arguments
    ///
    /// * `verification_result` - A boolean value indicating whether the proof verification was
    ///   successful.
    /// * `nonce` - The nonce of the transfer to be unlocked.
    /// * `sender_id` - The account ID of the sender that initiated the unlock request.
    ///
    /// # Panics
    ///
    /// This function panics if the transfer specified by the nonce is not found;
    /// if the valid time of the transfer is incorrect; or if the verification of the unlock proof fails.
    pub fn unlock_callback(
        &mut self,
        verification_result: bool,
        nonce: U128,
        sender_id: AccountId,
    ) -> TransferMessage {
        let (recipient_id, transfer_data) = self
            .get_pending_transfer(nonce.0.to_string())
            .unwrap_or_else(|| near_sdk::env::panic_str("Transfer not found"));
        if true {
            let msg: &str = &"Only the original creator of the transfer can perform the unlock";
            if !(transfer_data.aurora_sender.is_none() || recipient_id == sender_id) {
                {
                    ::core::panicking::panic_display(&msg);
                }
            }
        } else if !(transfer_data.aurora_sender.is_none() || recipient_id == sender_id) {
            ::near_sdk::env::panic_str(
                &"Only the original creator of the transfer can perform the unlock",
            )
        }
        if true {
            let msg: &str = &"Valid time is not correct.";
            if !(block_timestamp() > transfer_data.valid_till) {
                {
                    ::core::panicking::panic_display(&msg);
                }
            }
        } else if !(block_timestamp() > transfer_data.valid_till) {
            ::near_sdk::env::panic_str(&"Valid time is not correct.")
        }
        if true {
            let msg: &str = &{
                let res = ::alloc::fmt::format(
                    format_args!("Verification failed for unlock proof"),
                );
                res
            };
            if !verification_result {
                {
                    ::core::panicking::panic_display(&msg);
                }
            }
        } else if !verification_result {
            ::near_sdk::env::panic_str(
                &{
                    let res = ::alloc::fmt::format(
                        format_args!("Verification failed for unlock proof"),
                    );
                    res
                },
            )
        }
        self.increase_balance(
            &recipient_id,
            &transfer_data.transfer.token_near,
            &transfer_data.transfer.amount.0,
        );
        self.increase_balance(
            &recipient_id,
            &transfer_data.fee.token,
            &transfer_data.fee.amount.0,
        );
        self.remove_transfer(&nonce.0.to_string(), &transfer_data);
        Event::FastBridgeUnlockEvent {
            nonce,
            recipient_id,
            transfer_message: transfer_data.clone(),
        }
            .emit();
        transfer_data
    }
    /// Unlocks tokens that were transferred on the Ethereum. The function increases the balance
    /// of the transfer token and transfer fee token for the relayer account on NEAR side, which is obtained
    /// from the proof of the transfer event.
    ///
    /// # Arguments
    ///
    /// * `proof` - A `Proof` for the event of the successful transfer on the Ethereum side.
    ///
    /// # Returns
    ///
    /// A promise that resolves when the proof has been successfully verified.
    ///
    /// # Panics
    ///
    /// The function will panic if the Ethereum Fast Bridge contract address in the provided proof does not
    /// match the expected Fast Bridge contract's address stored in the contract state.
    pub fn lp_unlock(&mut self, proof: Proof) -> Promise {
        let mut __check_paused = true;
        let __except_roles: Vec<&str> = <[_]>::into_vec(
            #[rustc_box]
            ::alloc::boxed::Box::new([Role::UnrestrictedLpUnlock.into()]),
        );
        let __except_roles: Vec<String> = __except_roles
            .iter()
            .map(|&x| x.into())
            .collect();
        let may_bypass = self
            .acl_has_any_role(__except_roles, ::near_sdk::env::predecessor_account_id());
        if may_bypass {
            __check_paused = false;
        }
        if __check_paused {
            if true {
                let msg: &str = &"Pausable: Method is paused";
                if !!self.pa_is_paused("lp_unlock".to_string()) {
                    {
                        ::core::panicking::panic_display(&msg);
                    }
                }
            } else if !!self.pa_is_paused("lp_unlock".to_string()) {
                ::near_sdk::env::panic_str(&"Pausable: Method is paused")
            }
        }
        let parsed_proof = lp_relayer::EthTransferEvent::parse(proof.clone());
        match (&parsed_proof.eth_bridge_contract, &self.eth_bridge_contract) {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                    let kind = ::core::panicking::AssertKind::Eq;
                    ::core::panicking::assert_failed(
                        kind,
                        &*left_val,
                        &*right_val,
                        ::core::option::Option::Some(
                            format_args!(
                                "Event\'s address {0} does not match the eth bridge address {1}",
                                hex::encode(parsed_proof.eth_bridge_contract.0),
                                hex::encode(self.eth_bridge_contract.0),
                            ),
                        ),
                    );
                }
            }
        };
        ext_prover::ext(self.prover_account.clone())
            .with_static_gas(utils::tera_gas(50))
            .with_attached_deposit(utils::NO_DEPOSIT)
            .verify_log_entry(
                proof.log_index,
                proof.log_entry_data,
                proof.receipt_index,
                proof.receipt_data,
                proof.header_data,
                proof.proof,
                false,
            )
            .then(
                ext_self::ext(current_account_id())
                    .with_static_gas(utils::tera_gas(50))
                    .with_attached_deposit(utils::NO_DEPOSIT)
                    .verify_log_entry_callback(parsed_proof),
            )
    }
    /// Force unlocks tokens that were transferred on the Ethereum. The function increases the balance
    /// of the transfer token and transfer fee token for the relayer account on NEAR side.
    ///
    /// The function is allowed to be called only by accounts that have `UnlockManager` role.
    ///
    /// # Arguments
    ///
    /// * `nonce` - The nonce of the transfer to be unlocked.
    /// * `recipient_id` - The account ID that receive the unlocked tokens.
    ///
    /// # Panics
    ///
    /// The function will panic if the transfer is still active or the time has not yet passed to force unlock.
    ///
    pub fn unlock_stuck_transfer(&mut self, nonce: U128, recipient_id: AccountId) {
        let __acl_any_roles: Vec<&str> = <[_]>::into_vec(
            #[rustc_box]
            ::alloc::boxed::Box::new([Role::UnlockManager.into(), Role::DAO.into()]),
        );
        let __acl_any_roles_ser: Vec<String> = __acl_any_roles
            .iter()
            .map(|&role| role.into())
            .collect();
        let __acl_any_account_id = ::near_sdk::env::predecessor_account_id();
        if !self.acl_has_any_role(__acl_any_roles_ser, __acl_any_account_id) {
            let message = {
                let res = ::alloc::fmt::format(
                    format_args!(
                        "Insufficient permissions for method {0} restricted by access control. Requires one of these roles: {1:?}",
                        "unlock_stuck_transfer",
                        __acl_any_roles,
                    ),
                );
                res
            };
            near_sdk::env::panic_str(&message);
        }
        let nonce_str = nonce.0.to_string();
        let (_, transfer_data) = self
            .pending_transfers
            .get(&nonce_str)
            .unwrap_or_else(|| env::panic_str("Transaction not found"));
        let over_timeout_duration = env::block_timestamp()
            .checked_sub(transfer_data.valid_till)
            .unwrap_or_else(|| env::panic_str("Can't unlock active transfer"));
        if true {
            let msg: &str = &"Force unlock isn't allowed yet";
            if !(over_timeout_duration >= MIN_DURATION_ALLOWED_TO_FORCE_UNLOCK_NS) {
                {
                    ::core::panicking::panic_display(&msg);
                }
            }
        } else if !(over_timeout_duration >= MIN_DURATION_ALLOWED_TO_FORCE_UNLOCK_NS) {
            ::near_sdk::env::panic_str(&"Force unlock isn't allowed yet")
        }
        self.increase_balance(
            &recipient_id,
            &transfer_data.transfer.token_near,
            &transfer_data.transfer.amount.0,
        );
        self.increase_balance(
            &recipient_id,
            &transfer_data.fee.token,
            &transfer_data.fee.amount.0,
        );
        self.remove_transfer(&nonce_str, &transfer_data);
        Event::FastBridgeLpUnlockEvent {
            nonce,
            recipient_id,
            transfer_message: transfer_data,
        }
            .emit();
    }
    /// Checks whether the verification of proof was successful and finalizes the execution flow of the `lp_unlock()` function.
    ///
    /// This function is called from the `EthProver` contract after the proof verification.
    /// If the verification is successful, the function checks if the transfer is valid and if so, executes
    /// the transfer on NEAR by increasing the balance of the recipient's account.
    /// It also emits a `FastBridgeLpUnlockEvent` event to signal that a transfer was successfully executed.
    ///
    /// This function is only intended for internal use and should not be called directly by external accounts.
    ///
    /// # Arguments
    ///
    /// * `verification_success`: a boolean value indicating whether the verification of the event log entry was successful.
    /// * `proof`: an `EthTransferEvent` object containing the data of the transfer.
    ///
    /// # Panics
    ///
    /// This function will panic if it cannot find a pending transfer with the given nonce or if any of the checks
    /// on the transfer data fail.
    pub fn verify_log_entry_callback(
        &mut self,
        verification_success: bool,
        proof: EthTransferEvent,
    ) {
        if true {
            let msg: &str = &"Failed to verify the proof";
            if !verification_success {
                {
                    ::core::panicking::panic_display(&msg);
                }
            }
        } else if !verification_success {
            ::near_sdk::env::panic_str(&"Failed to verify the proof")
        }
        let nonce_str = proof.nonce.to_string();
        let transfer = self
            .pending_transfers
            .get(&nonce_str)
            .unwrap_or_else(|| {
                ::core::panicking::panic_fmt(
                    format_args!("Transaction with id: {0} not found", &nonce_str),
                );
            });
        let transfer_data = transfer.1;
        if true {
            let msg: &str = &{
                let res = ::alloc::fmt::format(
                    format_args!(
                        "Wrong recipient {0:?}, expected {1:?}",
                        proof.recipient,
                        transfer_data.recipient,
                    ),
                );
                res
            };
            if !(proof.recipient == transfer_data.recipient) {
                {
                    ::core::panicking::panic_display(&msg);
                }
            }
        } else if !(proof.recipient == transfer_data.recipient) {
            ::near_sdk::env::panic_str(
                &{
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "Wrong recipient {0:?}, expected {1:?}",
                            proof.recipient,
                            transfer_data.recipient,
                        ),
                    );
                    res
                },
            )
        }
        if true {
            let msg: &str = &{
                let res = ::alloc::fmt::format(
                    format_args!(
                        "Wrong token transferred {0:?}, expected {1:?}",
                        proof.token,
                        transfer_data.transfer.token_eth,
                    ),
                );
                res
            };
            if !(proof.token == transfer_data.transfer.token_eth) {
                {
                    ::core::panicking::panic_display(&msg);
                }
            }
        } else if !(proof.token == transfer_data.transfer.token_eth) {
            ::near_sdk::env::panic_str(
                &{
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "Wrong token transferred {0:?}, expected {1:?}",
                            proof.token,
                            transfer_data.transfer.token_eth,
                        ),
                    );
                    res
                },
            )
        }
        if true {
            let msg: &str = &{
                let res = ::alloc::fmt::format(
                    format_args!(
                        "Wrong amount transferred {0}, expected {1}",
                        proof.amount,
                        transfer_data.transfer.amount.0,
                    ),
                );
                res
            };
            if !(proof.amount == transfer_data.transfer.amount.0) {
                {
                    ::core::panicking::panic_display(&msg);
                }
            }
        } else if !(proof.amount == transfer_data.transfer.amount.0) {
            ::near_sdk::env::panic_str(
                &{
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "Wrong amount transferred {0}, expected {1}",
                            proof.amount,
                            transfer_data.transfer.amount.0,
                        ),
                    );
                    res
                },
            )
        }
        let recipient_id = proof.unlock_recipient.parse().unwrap();
        self.increase_balance(
            &recipient_id,
            &transfer_data.transfer.token_near,
            &transfer_data.transfer.amount.0,
        );
        self.increase_balance(
            &recipient_id,
            &transfer_data.fee.token,
            &transfer_data.fee.amount.0,
        );
        self.remove_transfer(&nonce_str, &transfer_data);
        Event::FastBridgeLpUnlockEvent {
            nonce: U128(proof.nonce),
            recipient_id,
            transfer_message: transfer_data,
        }
            .emit();
    }
    /// Gets the user balance of the specified token in this contract. These tokens can be immediately withdrawn.
    /// # Arguments
    ///
    /// * `account_id` - The account ID for which to retrieve the balance.
    /// * `token_id` - The token ID for which to retrieve the balance.
    ///
    /// # Returns
    ///
    /// The balance of the specified token for the specified account.
    pub fn get_user_balance(
        &self,
        account_id: &AccountId,
        token_id: &AccountId,
    ) -> U128 {
        let Some(token_balance) = self.token_balances.get(token_id) else {
            return U128(0);
        };
        token_balance.get(account_id).unwrap_or(0).into()
    }
    fn decrease_balance(
        &mut self,
        account_id: &AccountId,
        token_id: &AccountId,
        amount: &u128,
    ) {
        let mut token_balance = self.token_balances.get(token_id).unwrap();
        let balance = token_balance.get(account_id).unwrap() - amount;
        token_balance.insert(account_id, &balance);
    }
    fn increase_balance(
        &mut self,
        account_id: &AccountId,
        token_id: &AccountId,
        amount: &u128,
    ) {
        if let Some(mut token_balance) = self.token_balances.get(token_id) {
            token_balance
                .insert(
                    account_id,
                    &(token_balance.get(account_id).unwrap_or(0) + amount),
                );
        } else {
            let storage_key = [
                StorageKey::TokenBalancePrefix.try_to_vec().unwrap().as_slice(),
                token_id.try_to_vec().unwrap().as_slice(),
            ]
                .concat();
            let mut user_balance = LookupMap::new(storage_key);
            user_balance.insert(account_id, amount);
            self.token_balances.insert(token_id, &user_balance);
        }
    }
    fn validate_transfer_message(
        &self,
        transfer_message: &TransferMessage,
        sender_id: &AccountId,
    ) {
        if true {
            let msg: &str = &{
                let res = ::alloc::fmt::format(
                    format_args!(
                        "Transfer valid time:{0} not correct, current block timestamp:{1}.",
                        transfer_message.valid_till,
                        block_timestamp(),
                    ),
                );
                res
            };
            if !(transfer_message.valid_till > block_timestamp()) {
                {
                    ::core::panicking::panic_display(&msg);
                }
            }
        } else if !(transfer_message.valid_till > block_timestamp()) {
            ::near_sdk::env::panic_str(
                &{
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "Transfer valid time:{0} not correct, current block timestamp:{1}.",
                            transfer_message.valid_till,
                            block_timestamp(),
                        ),
                    );
                    res
                },
            )
        }
        let lock_period = transfer_message.valid_till - block_timestamp();
        if true {
            let msg: &str = &{
                let res = ::alloc::fmt::format(
                    format_args!(
                        "Lock period:{0} does not fit the terms of the contract.",
                        lock_period,
                    ),
                );
                res
            };
            if !(self.lock_duration.lock_time_min..=self.lock_duration.lock_time_max)
                .contains(&lock_period)
            {
                {
                    ::core::panicking::panic_display(&msg);
                }
            }
        } else if !(self.lock_duration.lock_time_min..=self.lock_duration.lock_time_max)
            .contains(&lock_period)
        {
            ::near_sdk::env::panic_str(
                &{
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "Lock period:{0} does not fit the terms of the contract.",
                            lock_period,
                        ),
                    );
                    res
                },
            )
        }
        self.check_whitelist_token_and_account(
            &transfer_message.transfer.token_near,
            sender_id,
        );
        self.check_whitelist_token_and_account(&transfer_message.fee.token, sender_id);
    }
    fn store_transfers(
        &mut self,
        sender_id: AccountId,
        transfer_message: TransferMessage,
    ) -> u128 {
        let new_balance = self
            .pending_transfers_balances
            .get(&transfer_message.transfer.token_near)
            .unwrap_or(0) + transfer_message.transfer.amount.0;
        self.pending_transfers_balances
            .insert(&transfer_message.transfer.token_near, &new_balance);
        self.nonce += 1;
        let account_pending = (sender_id, transfer_message);
        self.pending_transfers.insert(&self.nonce.to_string(), &account_pending);
        self.nonce
    }
    fn remove_transfer(
        &mut self,
        transfer_id: &String,
        transfer_message: &TransferMessage,
    ) {
        let new_balance = self
            .pending_transfers_balances
            .get(&transfer_message.transfer.token_near)
            .unwrap_or_else(|| env::panic_str("Pending balance does not exist"))
            - transfer_message.transfer.amount.0;
        self.pending_transfers_balances
            .insert(&transfer_message.transfer.token_near, &new_balance);
        self.pending_transfers.remove(transfer_id);
    }
    /// Withdraws the specified `amount` of tokens from the provided token account ID from the balance of the caller.
    ///
    /// # Arguments
    ///
    ///
    /// * `token_id` - an `AccountId` representing the token ID to withdraw from.
    /// * `amount` - an optional `U128` representing the amount to withdraw. If `None` is provided, the entire balance of the caller will be withdrawn.
    ///
    /// # Returns
    ///
    /// A `PromiseOrValue<U128>` indicating the result of the withdrawal operation.
    ///
    /// # Panics
    ///
    /// The function will panic if:
    ///
    /// * The specified `amount` is not a positive number.
    /// * The balance of the caller is insufficient.
    /// * The caller does not have any balance.
    pub fn withdraw(
        &mut self,
        token_id: AccountId,
        amount: Option<U128>,
        recipient_id: Option<AccountId>,
        msg: Option<String>,
    ) -> Promise {
        let mut __check_paused = true;
        let __except_roles: Vec<&str> = <[_]>::into_vec(
            #[rustc_box]
            ::alloc::boxed::Box::new([Role::UnrestrictedWithdraw.into()]),
        );
        let __except_roles: Vec<String> = __except_roles
            .iter()
            .map(|&x| x.into())
            .collect();
        let may_bypass = self
            .acl_has_any_role(__except_roles, ::near_sdk::env::predecessor_account_id());
        if may_bypass {
            __check_paused = false;
        }
        if __check_paused {
            if true {
                let msg: &str = &"Pausable: Method is paused";
                if !!self.pa_is_paused("withdraw".to_string()) {
                    {
                        ::core::panicking::panic_display(&msg);
                    }
                }
            } else if !!self.pa_is_paused("withdraw".to_string()) {
                ::near_sdk::env::panic_str(&"Pausable: Method is paused")
            }
        }
        let sender_id = env::predecessor_account_id();
        self.withdraw_internal(token_id, amount, sender_id, recipient_id, msg)
    }
    fn withdraw_internal(
        &mut self,
        token_id: AccountId,
        amount: Option<U128>,
        sender_id: AccountId,
        recipient_id: Option<AccountId>,
        msg: Option<String>,
    ) -> Promise {
        let user_balance = self.get_user_balance(&sender_id, &token_id);
        let amount = amount.unwrap_or(user_balance);
        if true {
            let msg: &str = &"The amount should be a positive number";
            if !(amount.0 > 0) {
                {
                    ::core::panicking::panic_display(&msg);
                }
            }
        } else if !(amount.0 > 0) {
            ::near_sdk::env::panic_str(&"The amount should be a positive number")
        }
        if true {
            let msg: &str = &"Insufficient user balance";
            if !(amount <= user_balance) {
                {
                    ::core::panicking::panic_display(&msg);
                }
            }
        } else if !(amount <= user_balance) {
            ::near_sdk::env::panic_str(&"Insufficient user balance")
        }
        self.decrease_balance(&sender_id, &token_id, &amount.0);
        let recipient_id = recipient_id.unwrap_or(sender_id);
        if let Some(msg) = msg {
            self.call_ft_transfer_call(token_id, amount, recipient_id, msg)
        } else {
            self.call_ft_transfer(token_id, amount, recipient_id)
        }
    }
    fn call_ft_transfer_call(
        &self,
        token_id: AccountId,
        amount: U128,
        recipient_id: AccountId,
        msg: String,
    ) -> Promise {
        ext_token::ext(token_id.clone())
            .with_static_gas(utils::tera_gas(50))
            .with_attached_deposit(1)
            .ft_transfer_call(recipient_id.clone(), amount, msg)
            .then(
                ext_self::ext(current_account_id())
                    .with_static_gas(utils::tera_gas(5))
                    .with_attached_deposit(utils::NO_DEPOSIT)
                    .withdraw_callback(token_id, amount, recipient_id),
            )
    }
    fn call_ft_transfer(
        &self,
        token_id: AccountId,
        amount: U128,
        recipient_id: AccountId,
    ) -> Promise {
        ext_token::ext(token_id.clone())
            .with_static_gas(utils::tera_gas(5))
            .with_attached_deposit(1)
            .ft_transfer(
                recipient_id.clone(),
                amount,
                Some({
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "Withdraw from: {0} amount: {1}",
                            current_account_id(),
                            u128::try_from(amount).unwrap(),
                        ),
                    );
                    res
                }),
            )
            .then(
                ext_self::ext(current_account_id())
                    .with_static_gas(utils::tera_gas(2))
                    .with_attached_deposit(utils::NO_DEPOSIT)
                    .withdraw_callback(token_id, amount, recipient_id),
            )
    }
    /// This function finalizes the execution flow of the `withdraw()` function. This private function is called after
    /// the `ft_transfer` promise made in the `withdraw` function is resolved. It checks whether the promise was
    /// successful or not, and emits an event if it was. If the promise was not successful, the amount is returned
    /// to the user's balance. This function is only intended for internal use and should not be called directly by
    /// external accounts.
    ///
    /// # Arguments
    ///
    /// * `token_id`: An `AccountId` representing the token being withdrawn.
    /// * `amount`: A `U128` value representing the amount being withdrawn.
    /// * `recipient_id`: An `AccountId` representing the account that will receive the withdrawn funds.
    ///
    /// # Returns
    ///
    /// * A `U128` value representing the amount that was withdrawn, or `0` if the promise was not
    ///   successful and the funds were returned to the user's balance.
    pub fn withdraw_callback(
        &mut self,
        token_id: AccountId,
        amount: U128,
        recipient_id: AccountId,
    ) -> U128 {
        let mut transferred_amount = U128(0);
        if let Some(result) = promise_result_as_success() {
            transferred_amount = if result.is_empty() {
                amount
            } else {
                near_sdk::serde_json::from_slice::<U128>(&result).unwrap()
            };
            Event::FastBridgeWithdrawEvent {
                recipient_id: recipient_id.clone(),
                token: token_id.clone(),
                amount: transferred_amount,
            }
                .emit();
        }
        let refund_amount = amount.0 - transferred_amount.0;
        if refund_amount > 0 {
            self.increase_balance(&recipient_id, &token_id, &refund_amount);
        }
        transferred_amount
    }
    /// Sets the prover account. `EthProver` is a contract that checks the correctness of Ethereum proofs.
    /// The function is allowed to be called only by accounts that have `ConfigManager` or `Role::DAO` roles.
    /// # Arguments
    /// * `prover_account`: An `AccountId` representing the `EthProver` account to use.
    pub fn set_prover_account(&mut self, prover_account: AccountId) {
        let __acl_any_roles: Vec<&str> = <[_]>::into_vec(
            #[rustc_box]
            ::alloc::boxed::Box::new([Role::ConfigManager.into(), Role::DAO.into()]),
        );
        let __acl_any_roles_ser: Vec<String> = __acl_any_roles
            .iter()
            .map(|&role| role.into())
            .collect();
        let __acl_any_account_id = ::near_sdk::env::predecessor_account_id();
        if !self.acl_has_any_role(__acl_any_roles_ser, __acl_any_account_id) {
            let message = {
                let res = ::alloc::fmt::format(
                    format_args!(
                        "Insufficient permissions for method {0} restricted by access control. Requires one of these roles: {1:?}",
                        "set_prover_account",
                        __acl_any_roles,
                    ),
                );
                res
            };
            near_sdk::env::panic_str(&message);
        }
        self.prover_account = prover_account;
    }
    /// Sets the eth client account. `EthClient` is a contract that provide the last block number.
    /// The function is allowed to be called only by accounts that have `ConfigManager` or `Role::DAO` roles.
    /// # Arguments
    /// * `account_id`: An `AccountId` representing the `EthClient` account to use.
    pub fn set_eth_client_account(&mut self, account_id: AccountId) {
        let __acl_any_roles: Vec<&str> = <[_]>::into_vec(
            #[rustc_box]
            ::alloc::boxed::Box::new([Role::ConfigManager.into(), Role::DAO.into()]),
        );
        let __acl_any_roles_ser: Vec<String> = __acl_any_roles
            .iter()
            .map(|&role| role.into())
            .collect();
        let __acl_any_account_id = ::near_sdk::env::predecessor_account_id();
        if !self.acl_has_any_role(__acl_any_roles_ser, __acl_any_account_id) {
            let message = {
                let res = ::alloc::fmt::format(
                    format_args!(
                        "Insufficient permissions for method {0} restricted by access control. Requires one of these roles: {1:?}",
                        "set_eth_client_account",
                        __acl_any_roles,
                    ),
                );
                res
            };
            near_sdk::env::panic_str(&message);
        }
        self.eth_client_account = account_id;
    }
    /// Sets the Ethereum Fast Bridge contract address.
    ///
    /// Note, This address is further used for the verification of operations that utilize the Ethereum proofs.
    /// This is needed so the contract is able to check that proofs originate from the specified address.
    ///
    /// # Arguments
    ///
    /// * `address`: a hex-encoded string representing the address of the Fast Bridge contract on Ethereum.
    pub fn set_eth_bridge_contract_address(&mut self, address: String) {
        let __acl_any_roles: Vec<&str> = <[_]>::into_vec(
            #[rustc_box]
            ::alloc::boxed::Box::new([Role::ConfigManager.into(), Role::DAO.into()]),
        );
        let __acl_any_roles_ser: Vec<String> = __acl_any_roles
            .iter()
            .map(|&role| role.into())
            .collect();
        let __acl_any_account_id = ::near_sdk::env::predecessor_account_id();
        if !self.acl_has_any_role(__acl_any_roles_ser, __acl_any_account_id) {
            let message = {
                let res = ::alloc::fmt::format(
                    format_args!(
                        "Insufficient permissions for method {0} restricted by access control. Requires one of these roles: {1:?}",
                        "set_eth_bridge_contract_address",
                        __acl_any_roles,
                    ),
                );
                res
            };
            near_sdk::env::panic_str(&message);
        }
        self.eth_bridge_contract = fast_bridge_common::get_eth_address(address);
    }
    /// Gets the minimum and maximum possible time for the tokens lock period.
    pub fn get_lock_duration(self) -> LockDuration {
        self.lock_duration
    }
    /// Gets the amount of currently locked tokens in the contract for the specified `token_id`.
    /// If the account has no pending balance, 0 is returned. The fee is not counted.
    ///
    /// # Arguments
    ///
    /// * `token_id` - An account identifier for a token contract.
    ///
    /// # Returns
    ///
    /// The pending balance for the specified token account, or 0 if there is no pending balance.
    pub fn get_pending_balance(&self, token_id: AccountId) -> u128 {
        self.pending_transfers_balances.get(&token_id).unwrap_or(0)
    }
    /// Returns a vector of pending transfers with their associated IDs.
    ///
    /// The vector contains a tuple for each pending transfer, where the first element is the
    /// transfer ID as a string, and the second element is another tuple containing the recipient's
    /// account ID and the transfer message. The function starts at the specified `from_index` and
    /// returns a maximum of `limit` transfers.
    ///
    /// # Arguments
    ///
    /// * `from_index` - The index at which to start retrieving the pending transfers.
    /// * `limit` - The maximum number of transfers to retrieve.
    ///
    /// # Returns
    ///
    /// A vector of tuples, where the first element is a transfer ID and the second element is a tuple
    /// containing the recipient's account ID and the transfer message.
    pub fn get_pending_transfers(
        &self,
        from_index: usize,
        limit: usize,
    ) -> Vec<(String, (AccountId, TransferMessage))> {
        self.pending_transfers.iter().skip(from_index).take(limit).collect::<Vec<_>>()
    }
    /// Gets the pending transfer details for the given transfer ID.
    ///
    /// # Arguments
    ///
    /// * `id` - A string representing the transfer ID (nonce).
    ///
    /// # Returns
    ///
    /// Returns an `Option` containing the account ID and transfer message if the transfer ID exists in
    /// the pending transfers list, or `None` otherwise.
    pub fn get_pending_transfer(
        &self,
        id: String,
    ) -> Option<(AccountId, TransferMessage)> {
        self.pending_transfers.get(&id)
    }
    /// Sets the lock time for the contract.
    ///
    /// The function is allowed to be called only by accounts that have `ConfigManager` role.
    ///
    /// # Arguments
    ///
    /// * `lock_time_min` - A string representing the minimum lock time duration. Uses `parse_duration` crate suffixes for the durations.
    /// * `lock_time_max` - A string representing the maximum lock time duration. Uses `parse_duration` crate suffixes for the durations.
    ///
    /// # Panics
    ///
    /// Panics if `lock_time_min` is greater than or equal to `lock_time_max`.
    ///
    pub fn set_lock_time(&mut self, lock_time_min: String, lock_time_max: String) {
        let __acl_any_roles: Vec<&str> = <[_]>::into_vec(
            #[rustc_box]
            ::alloc::boxed::Box::new([Role::ConfigManager.into(), Role::DAO.into()]),
        );
        let __acl_any_roles_ser: Vec<String> = __acl_any_roles
            .iter()
            .map(|&role| role.into())
            .collect();
        let __acl_any_account_id = ::near_sdk::env::predecessor_account_id();
        if !self.acl_has_any_role(__acl_any_roles_ser, __acl_any_account_id) {
            let message = {
                let res = ::alloc::fmt::format(
                    format_args!(
                        "Insufficient permissions for method {0} restricted by access control. Requires one of these roles: {1:?}",
                        "set_lock_time",
                        __acl_any_roles,
                    ),
                );
                res
            };
            near_sdk::env::panic_str(&message);
        }
        let lock_time_min: u64 = parse(lock_time_min.as_str())
            .unwrap()
            .as_nanos()
            .try_into()
            .unwrap();
        let lock_time_max: u64 = parse(lock_time_max.as_str())
            .unwrap()
            .as_nanos()
            .try_into()
            .unwrap();
        if true {
            let msg: &str = &"Error initialize: lock_time_min must be less than lock_time_max";
            if !(lock_time_max > lock_time_min) {
                {
                    ::core::panicking::panic_display(&msg);
                }
            }
        } else if !(lock_time_max > lock_time_min) {
            ::near_sdk::env::panic_str(
                &"Error initialize: lock_time_min must be less than lock_time_max",
            )
        }
        self
            .lock_duration = LockDuration {
            lock_time_min,
            lock_time_max,
        };
    }
}
#[cfg(target_arch = "wasm32")]
#[no_mangle]
pub extern "C" fn new() {
    near_sdk::env::setup_panic_hook();
    if near_sdk::env::current_account_id() != near_sdk::env::predecessor_account_id() {
        near_sdk::env::panic_str("Method new is private");
    }
    if near_sdk::env::attached_deposit() != 0 {
        near_sdk::env::panic_str("Method new doesn't accept deposit");
    }
    #[serde(crate = "near_sdk::serde")]
    struct Input {
        eth_bridge_contract: String,
        prover_account: AccountId,
        eth_client_account: AccountId,
        lock_time_min: String,
        lock_time_max: String,
        eth_block_time: Duration,
        whitelist_mode: bool,
        start_nonce: U128,
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        use near_sdk::serde as _serde;
        #[automatically_derived]
        impl<'de> near_sdk::serde::Deserialize<'de> for Input {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> near_sdk::serde::__private::Result<Self, __D::Error>
            where
                __D: near_sdk::serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __field4,
                    __field5,
                    __field6,
                    __field7,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            3u64 => _serde::__private::Ok(__Field::__field3),
                            4u64 => _serde::__private::Ok(__Field::__field4),
                            5u64 => _serde::__private::Ok(__Field::__field5),
                            6u64 => _serde::__private::Ok(__Field::__field6),
                            7u64 => _serde::__private::Ok(__Field::__field7),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "eth_bridge_contract" => {
                                _serde::__private::Ok(__Field::__field0)
                            }
                            "prover_account" => _serde::__private::Ok(__Field::__field1),
                            "eth_client_account" => {
                                _serde::__private::Ok(__Field::__field2)
                            }
                            "lock_time_min" => _serde::__private::Ok(__Field::__field3),
                            "lock_time_max" => _serde::__private::Ok(__Field::__field4),
                            "eth_block_time" => _serde::__private::Ok(__Field::__field5),
                            "whitelist_mode" => _serde::__private::Ok(__Field::__field6),
                            "start_nonce" => _serde::__private::Ok(__Field::__field7),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"eth_bridge_contract" => {
                                _serde::__private::Ok(__Field::__field0)
                            }
                            b"prover_account" => _serde::__private::Ok(__Field::__field1),
                            b"eth_client_account" => {
                                _serde::__private::Ok(__Field::__field2)
                            }
                            b"lock_time_min" => _serde::__private::Ok(__Field::__field3),
                            b"lock_time_max" => _serde::__private::Ok(__Field::__field4),
                            b"eth_block_time" => _serde::__private::Ok(__Field::__field5),
                            b"whitelist_mode" => _serde::__private::Ok(__Field::__field6),
                            b"start_nonce" => _serde::__private::Ok(__Field::__field7),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<Input>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = Input;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct Input",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct Input with 8 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match match _serde::de::SeqAccess::next_element::<
                            AccountId,
                        >(&mut __seq) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct Input with 8 elements",
                                    ),
                                );
                            }
                        };
                        let __field2 = match match _serde::de::SeqAccess::next_element::<
                            AccountId,
                        >(&mut __seq) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct Input with 8 elements",
                                    ),
                                );
                            }
                        };
                        let __field3 = match match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        3usize,
                                        &"struct Input with 8 elements",
                                    ),
                                );
                            }
                        };
                        let __field4 = match match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        4usize,
                                        &"struct Input with 8 elements",
                                    ),
                                );
                            }
                        };
                        let __field5 = match match _serde::de::SeqAccess::next_element::<
                            Duration,
                        >(&mut __seq) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        5usize,
                                        &"struct Input with 8 elements",
                                    ),
                                );
                            }
                        };
                        let __field6 = match match _serde::de::SeqAccess::next_element::<
                            bool,
                        >(&mut __seq) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        6usize,
                                        &"struct Input with 8 elements",
                                    ),
                                );
                            }
                        };
                        let __field7 = match match _serde::de::SeqAccess::next_element::<
                            U128,
                        >(&mut __seq) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        7usize,
                                        &"struct Input with 8 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(Input {
                            eth_bridge_contract: __field0,
                            prover_account: __field1,
                            eth_client_account: __field2,
                            lock_time_min: __field3,
                            lock_time_max: __field4,
                            eth_block_time: __field5,
                            whitelist_mode: __field6,
                            start_nonce: __field7,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<AccountId> = _serde::__private::None;
                        let mut __field2: _serde::__private::Option<AccountId> = _serde::__private::None;
                        let mut __field3: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field4: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field5: _serde::__private::Option<Duration> = _serde::__private::None;
                        let mut __field6: _serde::__private::Option<bool> = _serde::__private::None;
                        let mut __field7: _serde::__private::Option<U128> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = match _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "eth_bridge_contract",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<
                                            String,
                                        >(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "prover_account",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<
                                            AccountId,
                                        >(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "eth_client_account",
                                            ),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<
                                            AccountId,
                                        >(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field3 => {
                                    if _serde::__private::Option::is_some(&__field3) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "lock_time_min",
                                            ),
                                        );
                                    }
                                    __field3 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<
                                            String,
                                        >(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field4 => {
                                    if _serde::__private::Option::is_some(&__field4) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "lock_time_max",
                                            ),
                                        );
                                    }
                                    __field4 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<
                                            String,
                                        >(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field5 => {
                                    if _serde::__private::Option::is_some(&__field5) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "eth_block_time",
                                            ),
                                        );
                                    }
                                    __field5 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<
                                            Duration,
                                        >(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field6 => {
                                    if _serde::__private::Option::is_some(&__field6) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "whitelist_mode",
                                            ),
                                        );
                                    }
                                    __field6 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<
                                            bool,
                                        >(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field7 => {
                                    if _serde::__private::Option::is_some(&__field7) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "start_nonce",
                                            ),
                                        );
                                    }
                                    __field7 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<
                                            U128,
                                        >(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                _ => {
                                    let _ = match _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field(
                                    "eth_bridge_contract",
                                ) {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field(
                                    "prover_account",
                                ) {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field(
                                    "eth_client_account",
                                ) {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field3 = match __field3 {
                            _serde::__private::Some(__field3) => __field3,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field(
                                    "lock_time_min",
                                ) {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field4 = match __field4 {
                            _serde::__private::Some(__field4) => __field4,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field(
                                    "lock_time_max",
                                ) {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field5 = match __field5 {
                            _serde::__private::Some(__field5) => __field5,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field(
                                    "eth_block_time",
                                ) {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field6 = match __field6 {
                            _serde::__private::Some(__field6) => __field6,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field(
                                    "whitelist_mode",
                                ) {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field7 = match __field7 {
                            _serde::__private::Some(__field7) => __field7,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("start_nonce") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        _serde::__private::Ok(Input {
                            eth_bridge_contract: __field0,
                            prover_account: __field1,
                            eth_client_account: __field2,
                            lock_time_min: __field3,
                            lock_time_max: __field4,
                            eth_block_time: __field5,
                            whitelist_mode: __field6,
                            start_nonce: __field7,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[
                    "eth_bridge_contract",
                    "prover_account",
                    "eth_client_account",
                    "lock_time_min",
                    "lock_time_max",
                    "eth_block_time",
                    "whitelist_mode",
                    "start_nonce",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "Input",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<Input>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    let Input {
        eth_bridge_contract,
        prover_account,
        eth_client_account,
        lock_time_min,
        lock_time_max,
        eth_block_time,
        whitelist_mode,
        start_nonce,
    }: Input = near_sdk::serde_json::from_slice(
            &near_sdk::env::input().expect("Expected input since method has arguments."),
        )
        .expect("Failed to deserialize input from JSON.");
    if near_sdk::env::state_exists() {
        near_sdk::env::panic_str("The contract has already been initialized");
    }
    let contract = FastBridge::new(
        eth_bridge_contract,
        prover_account,
        eth_client_account,
        lock_time_min,
        lock_time_max,
        eth_block_time,
        whitelist_mode,
        start_nonce,
    );
    near_sdk::env::state_write(&contract);
}
/// Initializes a token transfer from NEAR to Ethereum using the provided `TransferMessage`.
///
/// This function is called by the NEAR Fast Bridge contract to initiate a token transfer to Ethereum. The `msg` parameter is a `Base64VecU8` containing the encoded `TransferMessage`. The function decodes the `msg` parameter, checks its validity, and then calls `init_transfer_internal` to initiate the token transfer.
///
/// # Arguments
///
/// * `msg` -- the encoded `TransferMessage` in borsh Base64 format. It contains details about the transaction - `token`, `fee_token`, `amount`, `recipient`, etc.
#[cfg(target_arch = "wasm32")]
#[no_mangle]
pub extern "C" fn init_transfer() {
    near_sdk::env::setup_panic_hook();
    if near_sdk::env::attached_deposit() != 0 {
        near_sdk::env::panic_str("Method init_transfer doesn't accept deposit");
    }
    #[serde(crate = "near_sdk::serde")]
    struct Input {
        msg: near_sdk::json_types::Base64VecU8,
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        use near_sdk::serde as _serde;
        #[automatically_derived]
        impl<'de> near_sdk::serde::Deserialize<'de> for Input {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> near_sdk::serde::__private::Result<Self, __D::Error>
            where
                __D: near_sdk::serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "msg" => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"msg" => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<Input>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = Input;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct Input",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match match _serde::de::SeqAccess::next_element::<
                            near_sdk::json_types::Base64VecU8,
                        >(&mut __seq) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct Input with 1 element",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(Input { msg: __field0 })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<
                            near_sdk::json_types::Base64VecU8,
                        > = _serde::__private::None;
                        while let _serde::__private::Some(__key) = match _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("msg"),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<
                                            near_sdk::json_types::Base64VecU8,
                                        >(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                _ => {
                                    let _ = match _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("msg") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        _serde::__private::Ok(Input { msg: __field0 })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &["msg"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "Input",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<Input>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    let Input { msg }: Input = near_sdk::serde_json::from_slice(
            &near_sdk::env::input().expect("Expected input since method has arguments."),
        )
        .expect("Failed to deserialize input from JSON.");
    let mut contract: FastBridge = near_sdk::env::state_read().unwrap_or_default();
    let result = contract.init_transfer(msg);
    let result = near_sdk::serde_json::to_vec(&result)
        .expect("Failed to serialize the return value using JSON.");
    near_sdk::env::value_return(&result);
    near_sdk::env::state_write(&contract);
}
/// This function finalizes the execution flow of the `init_transfer()` function. This function
/// is called from the `Eth2Client` contract after extracting the last Ethereum block number on Near.
/// This function validates the transfer message and decreases the token transfer balance and fee
/// balance for the sender. If an `update_balance` is provided, it increases the sender's balance
/// accordingly and emits a `FastBridgeDepositEvent`. It then stores the transfer and emits a
/// `FastBridgeInitTransferEvent` with the `nonce`, `sender_id`, and `transfer_message`.
///
/// # Arguments
///
/// * `last_block_height` -- the last Ethereum block height in LightClient on Near.
///
/// * `transfer_message` -- the details about the transaction: token, fee token, amount, recipient, etc.
///    The `TransferMessage` is deserialized from a Borsh-encoded string.
///
/// * `sender_id` -- the account which initiates this transfer.
///    The `AccountId` is deserialized from a Borsh-encoded string.
///
/// * `update_balance` -- balance update in case the transfer of tokens and initialization of the transfer
///    happen in one transaction. The `UpdateBalance` is deserialized from a Borsh-encoded string.
#[cfg(target_arch = "wasm32")]
#[no_mangle]
pub extern "C" fn init_transfer_callback() {
    near_sdk::env::setup_panic_hook();
    if near_sdk::env::current_account_id() != near_sdk::env::predecessor_account_id() {
        near_sdk::env::panic_str("Method init_transfer_callback is private");
    }
    if near_sdk::env::attached_deposit() != 0 {
        near_sdk::env::panic_str("Method init_transfer_callback doesn't accept deposit");
    }
    struct Input {
        transfer_message: TransferMessage,
        sender_id: AccountId,
        update_balance: Option<UpdateBalance>,
    }
    impl borsh::de::BorshDeserialize for Input
    where
        TransferMessage: borsh::BorshDeserialize,
        AccountId: borsh::BorshDeserialize,
        Option<UpdateBalance>: borsh::BorshDeserialize,
    {
        fn deserialize(
            buf: &mut &[u8],
        ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
            Ok(Self {
                transfer_message: borsh::BorshDeserialize::deserialize(buf)?,
                sender_id: borsh::BorshDeserialize::deserialize(buf)?,
                update_balance: borsh::BorshDeserialize::deserialize(buf)?,
            })
        }
    }
    let Input { transfer_message, sender_id, update_balance }: Input = near_sdk::borsh::BorshDeserialize::try_from_slice(
            &near_sdk::env::input().expect("Expected input since method has arguments."),
        )
        .expect("Failed to deserialize input from Borsh.");
    let data: Vec<u8> = match near_sdk::env::promise_result(0u64) {
        near_sdk::PromiseResult::Successful(x) => x,
        _ => near_sdk::env::panic_str("Callback computation 0 was not successful"),
    };
    let last_block_height: u64 = near_sdk::borsh::BorshDeserialize::try_from_slice(&data)
        .expect("Failed to deserialize callback using Borsh");
    let mut contract: FastBridge = near_sdk::env::state_read().unwrap_or_default();
    let result = contract
        .init_transfer_callback(
            last_block_height,
            transfer_message,
            sender_id,
            update_balance,
        );
    let result = near_sdk::serde_json::to_vec(&result)
        .expect("Failed to serialize the return value using JSON.");
    near_sdk::env::value_return(&result);
    near_sdk::env::state_write(&contract);
}
#[cfg(target_arch = "wasm32")]
#[no_mangle]
pub extern "C" fn unlock_and_withdraw() {
    near_sdk::env::setup_panic_hook();
    #[serde(crate = "near_sdk::serde")]
    struct Input {
        nonce: U128,
        proof: near_sdk::json_types::Base64VecU8,
        recipient_id: Option<AccountId>,
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        use near_sdk::serde as _serde;
        #[automatically_derived]
        impl<'de> near_sdk::serde::Deserialize<'de> for Input {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> near_sdk::serde::__private::Result<Self, __D::Error>
            where
                __D: near_sdk::serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "nonce" => _serde::__private::Ok(__Field::__field0),
                            "proof" => _serde::__private::Ok(__Field::__field1),
                            "recipient_id" => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"nonce" => _serde::__private::Ok(__Field::__field0),
                            b"proof" => _serde::__private::Ok(__Field::__field1),
                            b"recipient_id" => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<Input>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = Input;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct Input",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match match _serde::de::SeqAccess::next_element::<
                            U128,
                        >(&mut __seq) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct Input with 3 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match match _serde::de::SeqAccess::next_element::<
                            near_sdk::json_types::Base64VecU8,
                        >(&mut __seq) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct Input with 3 elements",
                                    ),
                                );
                            }
                        };
                        let __field2 = match match _serde::de::SeqAccess::next_element::<
                            Option<AccountId>,
                        >(&mut __seq) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct Input with 3 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(Input {
                            nonce: __field0,
                            proof: __field1,
                            recipient_id: __field2,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<U128> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<
                            near_sdk::json_types::Base64VecU8,
                        > = _serde::__private::None;
                        let mut __field2: _serde::__private::Option<Option<AccountId>> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = match _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("nonce"),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<
                                            U128,
                                        >(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("proof"),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<
                                            near_sdk::json_types::Base64VecU8,
                                        >(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "recipient_id",
                                            ),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<
                                            Option<AccountId>,
                                        >(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                _ => {
                                    let _ = match _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("nonce") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("proof") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("recipient_id") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        _serde::__private::Ok(Input {
                            nonce: __field0,
                            proof: __field1,
                            recipient_id: __field2,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[
                    "nonce",
                    "proof",
                    "recipient_id",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "Input",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<Input>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    let Input { nonce, proof, recipient_id }: Input = near_sdk::serde_json::from_slice(
            &near_sdk::env::input().expect("Expected input since method has arguments."),
        )
        .expect("Failed to deserialize input from JSON.");
    let contract: FastBridge = near_sdk::env::state_read().unwrap_or_default();
    let result = contract.unlock_and_withdraw(nonce, proof, recipient_id);
    let result = near_sdk::serde_json::to_vec(&result)
        .expect("Failed to serialize the return value using JSON.");
    near_sdk::env::value_return(&result);
}
#[cfg(target_arch = "wasm32")]
#[no_mangle]
pub extern "C" fn unlock_and_withdraw_to_aurora_sender() {
    near_sdk::env::setup_panic_hook();
    #[serde(crate = "near_sdk::serde")]
    struct Input {
        nonce: U128,
        proof: near_sdk::json_types::Base64VecU8,
        recipient_id: AccountId,
        aurora_native_token_account_id: AccountId,
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        use near_sdk::serde as _serde;
        #[automatically_derived]
        impl<'de> near_sdk::serde::Deserialize<'de> for Input {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> near_sdk::serde::__private::Result<Self, __D::Error>
            where
                __D: near_sdk::serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            3u64 => _serde::__private::Ok(__Field::__field3),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "nonce" => _serde::__private::Ok(__Field::__field0),
                            "proof" => _serde::__private::Ok(__Field::__field1),
                            "recipient_id" => _serde::__private::Ok(__Field::__field2),
                            "aurora_native_token_account_id" => {
                                _serde::__private::Ok(__Field::__field3)
                            }
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"nonce" => _serde::__private::Ok(__Field::__field0),
                            b"proof" => _serde::__private::Ok(__Field::__field1),
                            b"recipient_id" => _serde::__private::Ok(__Field::__field2),
                            b"aurora_native_token_account_id" => {
                                _serde::__private::Ok(__Field::__field3)
                            }
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<Input>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = Input;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct Input",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match match _serde::de::SeqAccess::next_element::<
                            U128,
                        >(&mut __seq) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct Input with 4 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match match _serde::de::SeqAccess::next_element::<
                            near_sdk::json_types::Base64VecU8,
                        >(&mut __seq) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct Input with 4 elements",
                                    ),
                                );
                            }
                        };
                        let __field2 = match match _serde::de::SeqAccess::next_element::<
                            AccountId,
                        >(&mut __seq) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct Input with 4 elements",
                                    ),
                                );
                            }
                        };
                        let __field3 = match match _serde::de::SeqAccess::next_element::<
                            AccountId,
                        >(&mut __seq) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        3usize,
                                        &"struct Input with 4 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(Input {
                            nonce: __field0,
                            proof: __field1,
                            recipient_id: __field2,
                            aurora_native_token_account_id: __field3,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<U128> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<
                            near_sdk::json_types::Base64VecU8,
                        > = _serde::__private::None;
                        let mut __field2: _serde::__private::Option<AccountId> = _serde::__private::None;
                        let mut __field3: _serde::__private::Option<AccountId> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = match _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("nonce"),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<
                                            U128,
                                        >(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("proof"),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<
                                            near_sdk::json_types::Base64VecU8,
                                        >(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "recipient_id",
                                            ),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<
                                            AccountId,
                                        >(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field3 => {
                                    if _serde::__private::Option::is_some(&__field3) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "aurora_native_token_account_id",
                                            ),
                                        );
                                    }
                                    __field3 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<
                                            AccountId,
                                        >(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                _ => {
                                    let _ = match _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("nonce") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("proof") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("recipient_id") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field3 = match __field3 {
                            _serde::__private::Some(__field3) => __field3,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field(
                                    "aurora_native_token_account_id",
                                ) {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        _serde::__private::Ok(Input {
                            nonce: __field0,
                            proof: __field1,
                            recipient_id: __field2,
                            aurora_native_token_account_id: __field3,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[
                    "nonce",
                    "proof",
                    "recipient_id",
                    "aurora_native_token_account_id",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "Input",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<Input>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    let Input { nonce, proof, recipient_id, aurora_native_token_account_id }: Input = near_sdk::serde_json::from_slice(
            &near_sdk::env::input().expect("Expected input since method has arguments."),
        )
        .expect("Failed to deserialize input from JSON.");
    let contract: FastBridge = near_sdk::env::state_read().unwrap_or_default();
    let result = contract
        .unlock_and_withdraw_to_aurora_sender(
            nonce,
            proof,
            recipient_id,
            aurora_native_token_account_id,
        );
    let result = near_sdk::serde_json::to_vec(&result)
        .expect("Failed to serialize the return value using JSON.");
    near_sdk::env::value_return(&result);
}
#[cfg(target_arch = "wasm32")]
#[no_mangle]
pub extern "C" fn unlock_and_withdraw_callback() {
    near_sdk::env::setup_panic_hook();
    if near_sdk::env::current_account_id() != near_sdk::env::predecessor_account_id() {
        near_sdk::env::panic_str("Method unlock_and_withdraw_callback is private");
    }
    if near_sdk::env::attached_deposit() != 0 {
        near_sdk::env::panic_str(
            "Method unlock_and_withdraw_callback doesn't accept deposit",
        );
    }
    struct Input {
        sender_id: AccountId,
        recipient_id: Option<AccountId>,
        aurora_native_token_account_id: Option<AccountId>,
    }
    impl borsh::de::BorshDeserialize for Input
    where
        AccountId: borsh::BorshDeserialize,
        Option<AccountId>: borsh::BorshDeserialize,
        Option<AccountId>: borsh::BorshDeserialize,
    {
        fn deserialize(
            buf: &mut &[u8],
        ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
            Ok(Self {
                sender_id: borsh::BorshDeserialize::deserialize(buf)?,
                recipient_id: borsh::BorshDeserialize::deserialize(buf)?,
                aurora_native_token_account_id: borsh::BorshDeserialize::deserialize(
                    buf,
                )?,
            })
        }
    }
    let Input { sender_id, recipient_id, aurora_native_token_account_id }: Input = near_sdk::borsh::BorshDeserialize::try_from_slice(
            &near_sdk::env::input().expect("Expected input since method has arguments."),
        )
        .expect("Failed to deserialize input from Borsh.");
    let data: Vec<u8> = match near_sdk::env::promise_result(0u64) {
        near_sdk::PromiseResult::Successful(x) => x,
        _ => near_sdk::env::panic_str("Callback computation 0 was not successful"),
    };
    let transfer_data: TransferMessage = near_sdk::borsh::BorshDeserialize::try_from_slice(
            &data,
        )
        .expect("Failed to deserialize callback using Borsh");
    let mut contract: FastBridge = near_sdk::env::state_read().unwrap_or_default();
    let result = contract
        .unlock_and_withdraw_callback(
            transfer_data,
            sender_id,
            recipient_id,
            aurora_native_token_account_id,
        );
    let result = near_sdk::serde_json::to_vec(&result)
        .expect("Failed to serialize the return value using JSON.");
    near_sdk::env::value_return(&result);
    near_sdk::env::state_write(&contract);
}
/// Unlocks the transfer with the given `nonce`, using the provided `proof` of the non-existence
/// of the transfer on Ethereum. The unlock could be possible only if the transfer on Ethereum
/// didn't happen and its validity time is already expired.
/// The function could be executed successfully by any account that provides proof.
///
/// Note If the function is paused, only the account that has the `UnrestrictedUnlock` role is allowed to perform an unlock.
///
/// # Arguments
///
/// * `nonce` - A unique identifier of the transfer.
/// * `proof` - A Base64-encoded proof of the non-existence of the transfer on Ethereum after the `valid_till` timestamp is passed.
#[cfg(target_arch = "wasm32")]
#[no_mangle]
pub extern "C" fn unlock() {
    near_sdk::env::setup_panic_hook();
    #[serde(crate = "near_sdk::serde")]
    struct Input {
        nonce: U128,
        proof: near_sdk::json_types::Base64VecU8,
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        use near_sdk::serde as _serde;
        #[automatically_derived]
        impl<'de> near_sdk::serde::Deserialize<'de> for Input {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> near_sdk::serde::__private::Result<Self, __D::Error>
            where
                __D: near_sdk::serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "nonce" => _serde::__private::Ok(__Field::__field0),
                            "proof" => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"nonce" => _serde::__private::Ok(__Field::__field0),
                            b"proof" => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<Input>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = Input;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct Input",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match match _serde::de::SeqAccess::next_element::<
                            U128,
                        >(&mut __seq) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct Input with 2 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match match _serde::de::SeqAccess::next_element::<
                            near_sdk::json_types::Base64VecU8,
                        >(&mut __seq) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct Input with 2 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(Input {
                            nonce: __field0,
                            proof: __field1,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<U128> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<
                            near_sdk::json_types::Base64VecU8,
                        > = _serde::__private::None;
                        while let _serde::__private::Some(__key) = match _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("nonce"),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<
                                            U128,
                                        >(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("proof"),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<
                                            near_sdk::json_types::Base64VecU8,
                                        >(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                _ => {
                                    let _ = match _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("nonce") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("proof") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        _serde::__private::Ok(Input {
                            nonce: __field0,
                            proof: __field1,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &["nonce", "proof"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "Input",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<Input>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    let Input { nonce, proof }: Input = near_sdk::serde_json::from_slice(
            &near_sdk::env::input().expect("Expected input since method has arguments."),
        )
        .expect("Failed to deserialize input from JSON.");
    let contract: FastBridge = near_sdk::env::state_read().unwrap_or_default();
    let result = contract.unlock(nonce, proof);
    let result = near_sdk::serde_json::to_vec(&result)
        .expect("Failed to serialize the return value using JSON.");
    near_sdk::env::value_return(&result);
}
/// This function finalizes the execution flow of the `unlock()` function. This function
/// is called as a callback from the `EthProver` contract after the `proof` of the non-existence
/// of the transfer has been verified. It unlocks the transfer specified by the nonce, returns the appropriate
/// amount of locked tokens to the transfer creator, and emits a `FastBridgeUnlockEvent`
/// with the details of the unlocked transfer.
///
/// This function is only intended for internal use and should not be called directly by external accounts.
///
/// # Arguments
///
/// * `verification_result` - A boolean value indicating whether the proof verification was
///   successful.
/// * `nonce` - The nonce of the transfer to be unlocked.
/// * `sender_id` - The account ID of the sender that initiated the unlock request.
///
/// # Panics
///
/// This function panics if the transfer specified by the nonce is not found;
/// if the valid time of the transfer is incorrect; or if the verification of the unlock proof fails.
#[cfg(target_arch = "wasm32")]
#[no_mangle]
pub extern "C" fn unlock_callback() {
    near_sdk::env::setup_panic_hook();
    if near_sdk::env::current_account_id() != near_sdk::env::predecessor_account_id() {
        near_sdk::env::panic_str("Method unlock_callback is private");
    }
    if near_sdk::env::attached_deposit() != 0 {
        near_sdk::env::panic_str("Method unlock_callback doesn't accept deposit");
    }
    struct Input {
        nonce: U128,
        sender_id: AccountId,
    }
    impl borsh::de::BorshDeserialize for Input
    where
        U128: borsh::BorshDeserialize,
        AccountId: borsh::BorshDeserialize,
    {
        fn deserialize(
            buf: &mut &[u8],
        ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
            Ok(Self {
                nonce: borsh::BorshDeserialize::deserialize(buf)?,
                sender_id: borsh::BorshDeserialize::deserialize(buf)?,
            })
        }
    }
    let Input { nonce, sender_id }: Input = near_sdk::borsh::BorshDeserialize::try_from_slice(
            &near_sdk::env::input().expect("Expected input since method has arguments."),
        )
        .expect("Failed to deserialize input from Borsh.");
    let data: Vec<u8> = match near_sdk::env::promise_result(0u64) {
        near_sdk::PromiseResult::Successful(x) => x,
        _ => near_sdk::env::panic_str("Callback computation 0 was not successful"),
    };
    let verification_result: bool = near_sdk::borsh::BorshDeserialize::try_from_slice(
            &data,
        )
        .expect("Failed to deserialize callback using Borsh");
    let mut contract: FastBridge = near_sdk::env::state_read().unwrap_or_default();
    let result = contract.unlock_callback(verification_result, nonce, sender_id);
    let result = near_sdk::borsh::BorshSerialize::try_to_vec(&result)
        .expect("Failed to serialize the return value using Borsh.");
    near_sdk::env::value_return(&result);
    near_sdk::env::state_write(&contract);
}
/// Unlocks tokens that were transferred on the Ethereum. The function increases the balance
/// of the transfer token and transfer fee token for the relayer account on NEAR side, which is obtained
/// from the proof of the transfer event.
///
/// # Arguments
///
/// * `proof` - A `Proof` for the event of the successful transfer on the Ethereum side.
///
/// # Returns
///
/// A promise that resolves when the proof has been successfully verified.
///
/// # Panics
///
/// The function will panic if the Ethereum Fast Bridge contract address in the provided proof does not
/// match the expected Fast Bridge contract's address stored in the contract state.
#[cfg(target_arch = "wasm32")]
#[no_mangle]
pub extern "C" fn lp_unlock() {
    near_sdk::env::setup_panic_hook();
    if near_sdk::env::attached_deposit() != 0 {
        near_sdk::env::panic_str("Method lp_unlock doesn't accept deposit");
    }
    #[serde(crate = "near_sdk::serde")]
    struct Input {
        proof: Proof,
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        use near_sdk::serde as _serde;
        #[automatically_derived]
        impl<'de> near_sdk::serde::Deserialize<'de> for Input {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> near_sdk::serde::__private::Result<Self, __D::Error>
            where
                __D: near_sdk::serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "proof" => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"proof" => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<Input>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = Input;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct Input",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match match _serde::de::SeqAccess::next_element::<
                            Proof,
                        >(&mut __seq) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct Input with 1 element",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(Input { proof: __field0 })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<Proof> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = match _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("proof"),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<
                                            Proof,
                                        >(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                _ => {
                                    let _ = match _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("proof") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        _serde::__private::Ok(Input { proof: __field0 })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &["proof"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "Input",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<Input>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    let Input { proof }: Input = near_sdk::serde_json::from_slice(
            &near_sdk::env::input().expect("Expected input since method has arguments."),
        )
        .expect("Failed to deserialize input from JSON.");
    let mut contract: FastBridge = near_sdk::env::state_read().unwrap_or_default();
    let result = contract.lp_unlock(proof);
    let result = near_sdk::serde_json::to_vec(&result)
        .expect("Failed to serialize the return value using JSON.");
    near_sdk::env::value_return(&result);
    near_sdk::env::state_write(&contract);
}
/// Force unlocks tokens that were transferred on the Ethereum. The function increases the balance
/// of the transfer token and transfer fee token for the relayer account on NEAR side.
///
/// The function is allowed to be called only by accounts that have `UnlockManager` role.
///
/// # Arguments
///
/// * `nonce` - The nonce of the transfer to be unlocked.
/// * `recipient_id` - The account ID that receive the unlocked tokens.
///
/// # Panics
///
/// The function will panic if the transfer is still active or the time has not yet passed to force unlock.
///
#[cfg(target_arch = "wasm32")]
#[no_mangle]
pub extern "C" fn unlock_stuck_transfer() {
    near_sdk::env::setup_panic_hook();
    if near_sdk::env::attached_deposit() != 0 {
        near_sdk::env::panic_str("Method unlock_stuck_transfer doesn't accept deposit");
    }
    #[serde(crate = "near_sdk::serde")]
    struct Input {
        nonce: U128,
        recipient_id: AccountId,
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        use near_sdk::serde as _serde;
        #[automatically_derived]
        impl<'de> near_sdk::serde::Deserialize<'de> for Input {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> near_sdk::serde::__private::Result<Self, __D::Error>
            where
                __D: near_sdk::serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "nonce" => _serde::__private::Ok(__Field::__field0),
                            "recipient_id" => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"nonce" => _serde::__private::Ok(__Field::__field0),
                            b"recipient_id" => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<Input>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = Input;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct Input",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match match _serde::de::SeqAccess::next_element::<
                            U128,
                        >(&mut __seq) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct Input with 2 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match match _serde::de::SeqAccess::next_element::<
                            AccountId,
                        >(&mut __seq) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct Input with 2 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(Input {
                            nonce: __field0,
                            recipient_id: __field1,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<U128> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<AccountId> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = match _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("nonce"),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<
                                            U128,
                                        >(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "recipient_id",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<
                                            AccountId,
                                        >(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                _ => {
                                    let _ = match _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("nonce") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("recipient_id") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        _serde::__private::Ok(Input {
                            nonce: __field0,
                            recipient_id: __field1,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &["nonce", "recipient_id"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "Input",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<Input>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    let Input { nonce, recipient_id }: Input = near_sdk::serde_json::from_slice(
            &near_sdk::env::input().expect("Expected input since method has arguments."),
        )
        .expect("Failed to deserialize input from JSON.");
    let mut contract: FastBridge = near_sdk::env::state_read().unwrap_or_default();
    contract.unlock_stuck_transfer(nonce, recipient_id);
    near_sdk::env::state_write(&contract);
}
/// Checks whether the verification of proof was successful and finalizes the execution flow of the `lp_unlock()` function.
///
/// This function is called from the `EthProver` contract after the proof verification.
/// If the verification is successful, the function checks if the transfer is valid and if so, executes
/// the transfer on NEAR by increasing the balance of the recipient's account.
/// It also emits a `FastBridgeLpUnlockEvent` event to signal that a transfer was successfully executed.
///
/// This function is only intended for internal use and should not be called directly by external accounts.
///
/// # Arguments
///
/// * `verification_success`: a boolean value indicating whether the verification of the event log entry was successful.
/// * `proof`: an `EthTransferEvent` object containing the data of the transfer.
///
/// # Panics
///
/// This function will panic if it cannot find a pending transfer with the given nonce or if any of the checks
/// on the transfer data fail.
#[cfg(target_arch = "wasm32")]
#[no_mangle]
pub extern "C" fn verify_log_entry_callback() {
    near_sdk::env::setup_panic_hook();
    if near_sdk::env::current_account_id() != near_sdk::env::predecessor_account_id() {
        near_sdk::env::panic_str("Method verify_log_entry_callback is private");
    }
    if near_sdk::env::attached_deposit() != 0 {
        near_sdk::env::panic_str(
            "Method verify_log_entry_callback doesn't accept deposit",
        );
    }
    struct Input {
        proof: EthTransferEvent,
    }
    impl borsh::de::BorshDeserialize for Input
    where
        EthTransferEvent: borsh::BorshDeserialize,
    {
        fn deserialize(
            buf: &mut &[u8],
        ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
            Ok(Self {
                proof: borsh::BorshDeserialize::deserialize(buf)?,
            })
        }
    }
    let Input { proof }: Input = near_sdk::borsh::BorshDeserialize::try_from_slice(
            &near_sdk::env::input().expect("Expected input since method has arguments."),
        )
        .expect("Failed to deserialize input from Borsh.");
    let data: Vec<u8> = match near_sdk::env::promise_result(0u64) {
        near_sdk::PromiseResult::Successful(x) => x,
        _ => near_sdk::env::panic_str("Callback computation 0 was not successful"),
    };
    let verification_success: bool = near_sdk::borsh::BorshDeserialize::try_from_slice(
            &data,
        )
        .expect("Failed to deserialize callback using Borsh");
    let mut contract: FastBridge = near_sdk::env::state_read().unwrap_or_default();
    contract.verify_log_entry_callback(verification_success, proof);
    near_sdk::env::state_write(&contract);
}
/// Gets the user balance of the specified token in this contract. These tokens can be immediately withdrawn.
/// # Arguments
///
/// * `account_id` - The account ID for which to retrieve the balance.
/// * `token_id` - The token ID for which to retrieve the balance.
///
/// # Returns
///
/// The balance of the specified token for the specified account.
#[cfg(target_arch = "wasm32")]
#[no_mangle]
pub extern "C" fn get_user_balance() {
    near_sdk::env::setup_panic_hook();
    #[serde(crate = "near_sdk::serde")]
    struct Input {
        account_id: AccountId,
        token_id: AccountId,
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        use near_sdk::serde as _serde;
        #[automatically_derived]
        impl<'de> near_sdk::serde::Deserialize<'de> for Input {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> near_sdk::serde::__private::Result<Self, __D::Error>
            where
                __D: near_sdk::serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "account_id" => _serde::__private::Ok(__Field::__field0),
                            "token_id" => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"account_id" => _serde::__private::Ok(__Field::__field0),
                            b"token_id" => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<Input>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = Input;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct Input",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match match _serde::de::SeqAccess::next_element::<
                            AccountId,
                        >(&mut __seq) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct Input with 2 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match match _serde::de::SeqAccess::next_element::<
                            AccountId,
                        >(&mut __seq) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct Input with 2 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(Input {
                            account_id: __field0,
                            token_id: __field1,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<AccountId> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<AccountId> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = match _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "account_id",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<
                                            AccountId,
                                        >(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "token_id",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<
                                            AccountId,
                                        >(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                _ => {
                                    let _ = match _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("account_id") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("token_id") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        _serde::__private::Ok(Input {
                            account_id: __field0,
                            token_id: __field1,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &["account_id", "token_id"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "Input",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<Input>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    let Input { account_id, token_id }: Input = near_sdk::serde_json::from_slice(
            &near_sdk::env::input().expect("Expected input since method has arguments."),
        )
        .expect("Failed to deserialize input from JSON.");
    let contract: FastBridge = near_sdk::env::state_read().unwrap_or_default();
    let result = contract.get_user_balance(&account_id, &token_id);
    let result = near_sdk::serde_json::to_vec(&result)
        .expect("Failed to serialize the return value using JSON.");
    near_sdk::env::value_return(&result);
}
/// Withdraws the specified `amount` of tokens from the provided token account ID from the balance of the caller.
///
/// # Arguments
///
///
/// * `token_id` - an `AccountId` representing the token ID to withdraw from.
/// * `amount` - an optional `U128` representing the amount to withdraw. If `None` is provided, the entire balance of the caller will be withdrawn.
///
/// # Returns
///
/// A `PromiseOrValue<U128>` indicating the result of the withdrawal operation.
///
/// # Panics
///
/// The function will panic if:
///
/// * The specified `amount` is not a positive number.
/// * The balance of the caller is insufficient.
/// * The caller does not have any balance.
#[cfg(target_arch = "wasm32")]
#[no_mangle]
pub extern "C" fn withdraw() {
    near_sdk::env::setup_panic_hook();
    #[serde(crate = "near_sdk::serde")]
    struct Input {
        token_id: AccountId,
        amount: Option<U128>,
        recipient_id: Option<AccountId>,
        msg: Option<String>,
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        use near_sdk::serde as _serde;
        #[automatically_derived]
        impl<'de> near_sdk::serde::Deserialize<'de> for Input {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> near_sdk::serde::__private::Result<Self, __D::Error>
            where
                __D: near_sdk::serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            3u64 => _serde::__private::Ok(__Field::__field3),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "token_id" => _serde::__private::Ok(__Field::__field0),
                            "amount" => _serde::__private::Ok(__Field::__field1),
                            "recipient_id" => _serde::__private::Ok(__Field::__field2),
                            "msg" => _serde::__private::Ok(__Field::__field3),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"token_id" => _serde::__private::Ok(__Field::__field0),
                            b"amount" => _serde::__private::Ok(__Field::__field1),
                            b"recipient_id" => _serde::__private::Ok(__Field::__field2),
                            b"msg" => _serde::__private::Ok(__Field::__field3),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<Input>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = Input;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct Input",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match match _serde::de::SeqAccess::next_element::<
                            AccountId,
                        >(&mut __seq) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct Input with 4 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match match _serde::de::SeqAccess::next_element::<
                            Option<U128>,
                        >(&mut __seq) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct Input with 4 elements",
                                    ),
                                );
                            }
                        };
                        let __field2 = match match _serde::de::SeqAccess::next_element::<
                            Option<AccountId>,
                        >(&mut __seq) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct Input with 4 elements",
                                    ),
                                );
                            }
                        };
                        let __field3 = match match _serde::de::SeqAccess::next_element::<
                            Option<String>,
                        >(&mut __seq) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        3usize,
                                        &"struct Input with 4 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(Input {
                            token_id: __field0,
                            amount: __field1,
                            recipient_id: __field2,
                            msg: __field3,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<AccountId> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<Option<U128>> = _serde::__private::None;
                        let mut __field2: _serde::__private::Option<Option<AccountId>> = _serde::__private::None;
                        let mut __field3: _serde::__private::Option<Option<String>> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = match _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "token_id",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<
                                            AccountId,
                                        >(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("amount"),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<
                                            Option<U128>,
                                        >(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "recipient_id",
                                            ),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<
                                            Option<AccountId>,
                                        >(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field3 => {
                                    if _serde::__private::Option::is_some(&__field3) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("msg"),
                                        );
                                    }
                                    __field3 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<
                                            Option<String>,
                                        >(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                _ => {
                                    let _ = match _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("token_id") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("amount") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("recipient_id") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field3 = match __field3 {
                            _serde::__private::Some(__field3) => __field3,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("msg") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        _serde::__private::Ok(Input {
                            token_id: __field0,
                            amount: __field1,
                            recipient_id: __field2,
                            msg: __field3,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[
                    "token_id",
                    "amount",
                    "recipient_id",
                    "msg",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "Input",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<Input>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    let Input { token_id, amount, recipient_id, msg }: Input = near_sdk::serde_json::from_slice(
            &near_sdk::env::input().expect("Expected input since method has arguments."),
        )
        .expect("Failed to deserialize input from JSON.");
    let mut contract: FastBridge = near_sdk::env::state_read().unwrap_or_default();
    let result = contract.withdraw(token_id, amount, recipient_id, msg);
    let result = near_sdk::serde_json::to_vec(&result)
        .expect("Failed to serialize the return value using JSON.");
    near_sdk::env::value_return(&result);
    near_sdk::env::state_write(&contract);
}
/// This function finalizes the execution flow of the `withdraw()` function. This private function is called after
/// the `ft_transfer` promise made in the `withdraw` function is resolved. It checks whether the promise was
/// successful or not, and emits an event if it was. If the promise was not successful, the amount is returned
/// to the user's balance. This function is only intended for internal use and should not be called directly by
/// external accounts.
///
/// # Arguments
///
/// * `token_id`: An `AccountId` representing the token being withdrawn.
/// * `amount`: A `U128` value representing the amount being withdrawn.
/// * `recipient_id`: An `AccountId` representing the account that will receive the withdrawn funds.
///
/// # Returns
///
/// * A `U128` value representing the amount that was withdrawn, or `0` if the promise was not
///   successful and the funds were returned to the user's balance.
#[cfg(target_arch = "wasm32")]
#[no_mangle]
pub extern "C" fn withdraw_callback() {
    near_sdk::env::setup_panic_hook();
    if near_sdk::env::current_account_id() != near_sdk::env::predecessor_account_id() {
        near_sdk::env::panic_str("Method withdraw_callback is private");
    }
    if near_sdk::env::attached_deposit() != 0 {
        near_sdk::env::panic_str("Method withdraw_callback doesn't accept deposit");
    }
    #[serde(crate = "near_sdk::serde")]
    struct Input {
        token_id: AccountId,
        amount: U128,
        recipient_id: AccountId,
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        use near_sdk::serde as _serde;
        #[automatically_derived]
        impl<'de> near_sdk::serde::Deserialize<'de> for Input {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> near_sdk::serde::__private::Result<Self, __D::Error>
            where
                __D: near_sdk::serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "token_id" => _serde::__private::Ok(__Field::__field0),
                            "amount" => _serde::__private::Ok(__Field::__field1),
                            "recipient_id" => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"token_id" => _serde::__private::Ok(__Field::__field0),
                            b"amount" => _serde::__private::Ok(__Field::__field1),
                            b"recipient_id" => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<Input>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = Input;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct Input",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match match _serde::de::SeqAccess::next_element::<
                            AccountId,
                        >(&mut __seq) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct Input with 3 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match match _serde::de::SeqAccess::next_element::<
                            U128,
                        >(&mut __seq) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct Input with 3 elements",
                                    ),
                                );
                            }
                        };
                        let __field2 = match match _serde::de::SeqAccess::next_element::<
                            AccountId,
                        >(&mut __seq) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct Input with 3 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(Input {
                            token_id: __field0,
                            amount: __field1,
                            recipient_id: __field2,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<AccountId> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<U128> = _serde::__private::None;
                        let mut __field2: _serde::__private::Option<AccountId> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = match _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "token_id",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<
                                            AccountId,
                                        >(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("amount"),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<
                                            U128,
                                        >(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "recipient_id",
                                            ),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<
                                            AccountId,
                                        >(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                _ => {
                                    let _ = match _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("token_id") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("amount") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("recipient_id") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        _serde::__private::Ok(Input {
                            token_id: __field0,
                            amount: __field1,
                            recipient_id: __field2,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[
                    "token_id",
                    "amount",
                    "recipient_id",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "Input",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<Input>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    let Input { token_id, amount, recipient_id }: Input = near_sdk::serde_json::from_slice(
            &near_sdk::env::input().expect("Expected input since method has arguments."),
        )
        .expect("Failed to deserialize input from JSON.");
    let mut contract: FastBridge = near_sdk::env::state_read().unwrap_or_default();
    let result = contract.withdraw_callback(token_id, amount, recipient_id);
    let result = near_sdk::serde_json::to_vec(&result)
        .expect("Failed to serialize the return value using JSON.");
    near_sdk::env::value_return(&result);
    near_sdk::env::state_write(&contract);
}
/// Sets the prover account. `EthProver` is a contract that checks the correctness of Ethereum proofs.
/// The function is allowed to be called only by accounts that have `ConfigManager` or `Role::DAO` roles.
/// # Arguments
/// * `prover_account`: An `AccountId` representing the `EthProver` account to use.
#[cfg(target_arch = "wasm32")]
#[no_mangle]
pub extern "C" fn set_prover_account() {
    near_sdk::env::setup_panic_hook();
    if near_sdk::env::attached_deposit() != 0 {
        near_sdk::env::panic_str("Method set_prover_account doesn't accept deposit");
    }
    #[serde(crate = "near_sdk::serde")]
    struct Input {
        prover_account: AccountId,
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        use near_sdk::serde as _serde;
        #[automatically_derived]
        impl<'de> near_sdk::serde::Deserialize<'de> for Input {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> near_sdk::serde::__private::Result<Self, __D::Error>
            where
                __D: near_sdk::serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "prover_account" => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"prover_account" => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<Input>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = Input;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct Input",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match match _serde::de::SeqAccess::next_element::<
                            AccountId,
                        >(&mut __seq) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct Input with 1 element",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(Input { prover_account: __field0 })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<AccountId> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = match _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "prover_account",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<
                                            AccountId,
                                        >(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                _ => {
                                    let _ = match _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field(
                                    "prover_account",
                                ) {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        _serde::__private::Ok(Input { prover_account: __field0 })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &["prover_account"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "Input",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<Input>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    let Input { prover_account }: Input = near_sdk::serde_json::from_slice(
            &near_sdk::env::input().expect("Expected input since method has arguments."),
        )
        .expect("Failed to deserialize input from JSON.");
    let mut contract: FastBridge = near_sdk::env::state_read().unwrap_or_default();
    contract.set_prover_account(prover_account);
    near_sdk::env::state_write(&contract);
}
/// Sets the eth client account. `EthClient` is a contract that provide the last block number.
/// The function is allowed to be called only by accounts that have `ConfigManager` or `Role::DAO` roles.
/// # Arguments
/// * `account_id`: An `AccountId` representing the `EthClient` account to use.
#[cfg(target_arch = "wasm32")]
#[no_mangle]
pub extern "C" fn set_eth_client_account() {
    near_sdk::env::setup_panic_hook();
    if near_sdk::env::attached_deposit() != 0 {
        near_sdk::env::panic_str("Method set_eth_client_account doesn't accept deposit");
    }
    #[serde(crate = "near_sdk::serde")]
    struct Input {
        account_id: AccountId,
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        use near_sdk::serde as _serde;
        #[automatically_derived]
        impl<'de> near_sdk::serde::Deserialize<'de> for Input {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> near_sdk::serde::__private::Result<Self, __D::Error>
            where
                __D: near_sdk::serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "account_id" => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"account_id" => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<Input>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = Input;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct Input",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match match _serde::de::SeqAccess::next_element::<
                            AccountId,
                        >(&mut __seq) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct Input with 1 element",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(Input { account_id: __field0 })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<AccountId> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = match _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "account_id",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<
                                            AccountId,
                                        >(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                _ => {
                                    let _ = match _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("account_id") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        _serde::__private::Ok(Input { account_id: __field0 })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &["account_id"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "Input",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<Input>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    let Input { account_id }: Input = near_sdk::serde_json::from_slice(
            &near_sdk::env::input().expect("Expected input since method has arguments."),
        )
        .expect("Failed to deserialize input from JSON.");
    let mut contract: FastBridge = near_sdk::env::state_read().unwrap_or_default();
    contract.set_eth_client_account(account_id);
    near_sdk::env::state_write(&contract);
}
/// Sets the Ethereum Fast Bridge contract address.
///
/// Note, This address is further used for the verification of operations that utilize the Ethereum proofs.
/// This is needed so the contract is able to check that proofs originate from the specified address.
///
/// # Arguments
///
/// * `address`: a hex-encoded string representing the address of the Fast Bridge contract on Ethereum.
#[cfg(target_arch = "wasm32")]
#[no_mangle]
pub extern "C" fn set_eth_bridge_contract_address() {
    near_sdk::env::setup_panic_hook();
    if near_sdk::env::attached_deposit() != 0 {
        near_sdk::env::panic_str(
            "Method set_eth_bridge_contract_address doesn't accept deposit",
        );
    }
    #[serde(crate = "near_sdk::serde")]
    struct Input {
        address: String,
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        use near_sdk::serde as _serde;
        #[automatically_derived]
        impl<'de> near_sdk::serde::Deserialize<'de> for Input {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> near_sdk::serde::__private::Result<Self, __D::Error>
            where
                __D: near_sdk::serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "address" => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"address" => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<Input>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = Input;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct Input",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct Input with 1 element",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(Input { address: __field0 })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = match _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "address",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<
                                            String,
                                        >(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                _ => {
                                    let _ = match _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("address") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        _serde::__private::Ok(Input { address: __field0 })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &["address"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "Input",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<Input>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    let Input { address }: Input = near_sdk::serde_json::from_slice(
            &near_sdk::env::input().expect("Expected input since method has arguments."),
        )
        .expect("Failed to deserialize input from JSON.");
    let mut contract: FastBridge = near_sdk::env::state_read().unwrap_or_default();
    contract.set_eth_bridge_contract_address(address);
    near_sdk::env::state_write(&contract);
}
/// Gets the minimum and maximum possible time for the tokens lock period.
#[cfg(target_arch = "wasm32")]
#[no_mangle]
pub extern "C" fn get_lock_duration() {
    near_sdk::env::setup_panic_hook();
    let contract: FastBridge = near_sdk::env::state_read().unwrap_or_default();
    let result = contract.get_lock_duration();
    let result = near_sdk::serde_json::to_vec(&result)
        .expect("Failed to serialize the return value using JSON.");
    near_sdk::env::value_return(&result);
}
/// Gets the amount of currently locked tokens in the contract for the specified `token_id`.
/// If the account has no pending balance, 0 is returned. The fee is not counted.
///
/// # Arguments
///
/// * `token_id` - An account identifier for a token contract.
///
/// # Returns
///
/// The pending balance for the specified token account, or 0 if there is no pending balance.
#[cfg(target_arch = "wasm32")]
#[no_mangle]
pub extern "C" fn get_pending_balance() {
    near_sdk::env::setup_panic_hook();
    #[serde(crate = "near_sdk::serde")]
    struct Input {
        token_id: AccountId,
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        use near_sdk::serde as _serde;
        #[automatically_derived]
        impl<'de> near_sdk::serde::Deserialize<'de> for Input {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> near_sdk::serde::__private::Result<Self, __D::Error>
            where
                __D: near_sdk::serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "token_id" => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"token_id" => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<Input>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = Input;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct Input",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match match _serde::de::SeqAccess::next_element::<
                            AccountId,
                        >(&mut __seq) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct Input with 1 element",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(Input { token_id: __field0 })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<AccountId> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = match _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "token_id",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<
                                            AccountId,
                                        >(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                _ => {
                                    let _ = match _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("token_id") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        _serde::__private::Ok(Input { token_id: __field0 })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &["token_id"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "Input",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<Input>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    let Input { token_id }: Input = near_sdk::serde_json::from_slice(
            &near_sdk::env::input().expect("Expected input since method has arguments."),
        )
        .expect("Failed to deserialize input from JSON.");
    let contract: FastBridge = near_sdk::env::state_read().unwrap_or_default();
    let result = contract.get_pending_balance(token_id);
    let result = near_sdk::serde_json::to_vec(&result)
        .expect("Failed to serialize the return value using JSON.");
    near_sdk::env::value_return(&result);
}
/// Returns a vector of pending transfers with their associated IDs.
///
/// The vector contains a tuple for each pending transfer, where the first element is the
/// transfer ID as a string, and the second element is another tuple containing the recipient's
/// account ID and the transfer message. The function starts at the specified `from_index` and
/// returns a maximum of `limit` transfers.
///
/// # Arguments
///
/// * `from_index` - The index at which to start retrieving the pending transfers.
/// * `limit` - The maximum number of transfers to retrieve.
///
/// # Returns
///
/// A vector of tuples, where the first element is a transfer ID and the second element is a tuple
/// containing the recipient's account ID and the transfer message.
#[cfg(target_arch = "wasm32")]
#[no_mangle]
pub extern "C" fn get_pending_transfers() {
    near_sdk::env::setup_panic_hook();
    #[serde(crate = "near_sdk::serde")]
    struct Input {
        from_index: usize,
        limit: usize,
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        use near_sdk::serde as _serde;
        #[automatically_derived]
        impl<'de> near_sdk::serde::Deserialize<'de> for Input {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> near_sdk::serde::__private::Result<Self, __D::Error>
            where
                __D: near_sdk::serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "from_index" => _serde::__private::Ok(__Field::__field0),
                            "limit" => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"from_index" => _serde::__private::Ok(__Field::__field0),
                            b"limit" => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<Input>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = Input;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct Input",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match match _serde::de::SeqAccess::next_element::<
                            usize,
                        >(&mut __seq) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct Input with 2 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match match _serde::de::SeqAccess::next_element::<
                            usize,
                        >(&mut __seq) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct Input with 2 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(Input {
                            from_index: __field0,
                            limit: __field1,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<usize> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<usize> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = match _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "from_index",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<
                                            usize,
                                        >(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("limit"),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<
                                            usize,
                                        >(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                _ => {
                                    let _ = match _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("from_index") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("limit") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        _serde::__private::Ok(Input {
                            from_index: __field0,
                            limit: __field1,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &["from_index", "limit"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "Input",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<Input>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    let Input { from_index, limit }: Input = near_sdk::serde_json::from_slice(
            &near_sdk::env::input().expect("Expected input since method has arguments."),
        )
        .expect("Failed to deserialize input from JSON.");
    let contract: FastBridge = near_sdk::env::state_read().unwrap_or_default();
    let result = contract.get_pending_transfers(from_index, limit);
    let result = near_sdk::serde_json::to_vec(&result)
        .expect("Failed to serialize the return value using JSON.");
    near_sdk::env::value_return(&result);
}
/// Gets the pending transfer details for the given transfer ID.
///
/// # Arguments
///
/// * `id` - A string representing the transfer ID (nonce).
///
/// # Returns
///
/// Returns an `Option` containing the account ID and transfer message if the transfer ID exists in
/// the pending transfers list, or `None` otherwise.
#[cfg(target_arch = "wasm32")]
#[no_mangle]
pub extern "C" fn get_pending_transfer() {
    near_sdk::env::setup_panic_hook();
    #[serde(crate = "near_sdk::serde")]
    struct Input {
        id: String,
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        use near_sdk::serde as _serde;
        #[automatically_derived]
        impl<'de> near_sdk::serde::Deserialize<'de> for Input {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> near_sdk::serde::__private::Result<Self, __D::Error>
            where
                __D: near_sdk::serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "id" => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"id" => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<Input>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = Input;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct Input",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct Input with 1 element",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(Input { id: __field0 })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = match _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("id"),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<
                                            String,
                                        >(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                _ => {
                                    let _ = match _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("id") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        _serde::__private::Ok(Input { id: __field0 })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &["id"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "Input",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<Input>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    let Input { id }: Input = near_sdk::serde_json::from_slice(
            &near_sdk::env::input().expect("Expected input since method has arguments."),
        )
        .expect("Failed to deserialize input from JSON.");
    let contract: FastBridge = near_sdk::env::state_read().unwrap_or_default();
    let result = contract.get_pending_transfer(id);
    let result = near_sdk::serde_json::to_vec(&result)
        .expect("Failed to serialize the return value using JSON.");
    near_sdk::env::value_return(&result);
}
/// Sets the lock time for the contract.
///
/// The function is allowed to be called only by accounts that have `ConfigManager` role.
///
/// # Arguments
///
/// * `lock_time_min` - A string representing the minimum lock time duration. Uses `parse_duration` crate suffixes for the durations.
/// * `lock_time_max` - A string representing the maximum lock time duration. Uses `parse_duration` crate suffixes for the durations.
///
/// # Panics
///
/// Panics if `lock_time_min` is greater than or equal to `lock_time_max`.
///
#[cfg(target_arch = "wasm32")]
#[no_mangle]
pub extern "C" fn set_lock_time() {
    near_sdk::env::setup_panic_hook();
    if near_sdk::env::attached_deposit() != 0 {
        near_sdk::env::panic_str("Method set_lock_time doesn't accept deposit");
    }
    #[serde(crate = "near_sdk::serde")]
    struct Input {
        lock_time_min: String,
        lock_time_max: String,
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        use near_sdk::serde as _serde;
        #[automatically_derived]
        impl<'de> near_sdk::serde::Deserialize<'de> for Input {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> near_sdk::serde::__private::Result<Self, __D::Error>
            where
                __D: near_sdk::serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "lock_time_min" => _serde::__private::Ok(__Field::__field0),
                            "lock_time_max" => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"lock_time_min" => _serde::__private::Ok(__Field::__field0),
                            b"lock_time_max" => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<Input>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = Input;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct Input",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct Input with 2 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct Input with 2 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(Input {
                            lock_time_min: __field0,
                            lock_time_max: __field1,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<String> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = match _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "lock_time_min",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<
                                            String,
                                        >(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "lock_time_max",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<
                                            String,
                                        >(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                _ => {
                                    let _ = match _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field(
                                    "lock_time_min",
                                ) {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field(
                                    "lock_time_max",
                                ) {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        _serde::__private::Ok(Input {
                            lock_time_min: __field0,
                            lock_time_max: __field1,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[
                    "lock_time_min",
                    "lock_time_max",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "Input",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<Input>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    let Input { lock_time_min, lock_time_max }: Input = near_sdk::serde_json::from_slice(
            &near_sdk::env::input().expect("Expected input since method has arguments."),
        )
        .expect("Failed to deserialize input from JSON.");
    let mut contract: FastBridge = near_sdk::env::state_read().unwrap_or_default();
    contract.set_lock_time(lock_time_min, lock_time_max);
    near_sdk::env::state_write(&contract);
}
